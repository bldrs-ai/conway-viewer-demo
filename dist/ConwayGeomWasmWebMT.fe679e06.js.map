{"mappings":"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","sources":["<anon>","node_modules/@bldrs-ai/conway/compiled/dependencies/conway-geom/Dist/ConwayGeomWasmWebMT.js"],"sourcesContent":["\n      var $parcel$global = globalThis;\n    \nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\nvar parcelRequire = $parcel$global[\"parcelRequireb460\"];\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"dKqf5\", function(module, exports) {\n\n$parcel$export(module.exports, \"default\", () => $a023ed70d02b2fd9$export$2e2bcd8739ae039);\nvar $a023ed70d02b2fd9$var$ConwayGeomWasm = (()=>{\n    var _scriptName = typeof document != 'undefined' ? document.currentScript?.src : undefined;\n    return function(moduleArg = {}) {\n        var moduleRtn;\n        function GROWABLE_HEAP_I8() {\n            if (wasmMemory.buffer != HEAP8.buffer) updateMemoryViews();\n            return HEAP8;\n        }\n        function GROWABLE_HEAP_U8() {\n            if (wasmMemory.buffer != HEAP8.buffer) updateMemoryViews();\n            return HEAPU8;\n        }\n        function GROWABLE_HEAP_I16() {\n            if (wasmMemory.buffer != HEAP8.buffer) updateMemoryViews();\n            return HEAP16;\n        }\n        function GROWABLE_HEAP_U16() {\n            if (wasmMemory.buffer != HEAP8.buffer) updateMemoryViews();\n            return HEAPU16;\n        }\n        function GROWABLE_HEAP_I32() {\n            if (wasmMemory.buffer != HEAP8.buffer) updateMemoryViews();\n            return HEAP32;\n        }\n        function GROWABLE_HEAP_U32() {\n            if (wasmMemory.buffer != HEAP8.buffer) updateMemoryViews();\n            return HEAPU32;\n        }\n        function GROWABLE_HEAP_F32() {\n            if (wasmMemory.buffer != HEAP8.buffer) updateMemoryViews();\n            return HEAPF32;\n        }\n        function GROWABLE_HEAP_F64() {\n            if (wasmMemory.buffer != HEAP8.buffer) updateMemoryViews();\n            return HEAPF64;\n        }\n        var Module = moduleArg;\n        var readyPromiseResolve, readyPromiseReject;\n        var readyPromise = new Promise((resolve, reject)=>{\n            readyPromiseResolve = resolve;\n            readyPromiseReject = reject;\n        });\n        var ENVIRONMENT_IS_WEB = typeof window == \"object\";\n        var ENVIRONMENT_IS_WORKER = typeof WorkerGlobalScope != \"undefined\";\n        var ENVIRONMENT_IS_NODE = false;\n        var ENVIRONMENT_IS_PTHREAD = ENVIRONMENT_IS_WORKER && self.name?.startsWith(\"em-pthread\");\n        var moduleOverrides = Object.assign({}, Module);\n        var arguments_ = [];\n        var thisProgram = \"./this.program\";\n        var quit_ = (status, toThrow)=>{\n            throw toThrow;\n        };\n        var scriptDirectory = \"\";\n        function locateFile(path) {\n            if (Module[\"locateFile\"]) return Module[\"locateFile\"](path, scriptDirectory);\n            return scriptDirectory + path;\n        }\n        var readAsync, readBinary;\n        if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {\n            if (ENVIRONMENT_IS_WORKER) scriptDirectory = self.location.href;\n            else if (typeof document != \"undefined\" && document.currentScript) scriptDirectory = document.currentScript.src;\n            if (_scriptName) scriptDirectory = _scriptName;\n            if (scriptDirectory.startsWith(\"blob:\")) scriptDirectory = \"\";\n            else scriptDirectory = scriptDirectory.substr(0, scriptDirectory.replace(/[?#].*/, \"\").lastIndexOf(\"/\") + 1);\n            if (ENVIRONMENT_IS_WORKER) readBinary = (url)=>{\n                var xhr = new XMLHttpRequest;\n                xhr.open(\"GET\", url, false);\n                xhr.responseType = \"arraybuffer\";\n                xhr.send(null);\n                return new Uint8Array(xhr.response);\n            };\n            readAsync = (url)=>fetch(url, {\n                    credentials: \"same-origin\"\n                }).then((response)=>{\n                    if (response.ok) return response.arrayBuffer();\n                    return Promise.reject(new Error(response.status + \" : \" + response.url));\n                });\n        }\n        var out = Module[\"print\"] || console.log.bind(console);\n        var err = Module[\"printErr\"] || console.error.bind(console);\n        Object.assign(Module, moduleOverrides);\n        moduleOverrides = null;\n        if (Module[\"arguments\"]) arguments_ = Module[\"arguments\"];\n        if (Module[\"thisProgram\"]) thisProgram = Module[\"thisProgram\"];\n        var wasmBinary = Module[\"wasmBinary\"];\n        var wasmMemory;\n        var wasmModule;\n        var ABORT = false;\n        var EXITSTATUS;\n        function assert(condition, text) {\n            if (!condition) abort(text);\n        }\n        var HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;\n        function updateMemoryViews() {\n            var b = wasmMemory.buffer;\n            Module[\"HEAP8\"] = HEAP8 = new Int8Array(b);\n            Module[\"HEAP16\"] = HEAP16 = new Int16Array(b);\n            Module[\"HEAPU8\"] = HEAPU8 = new Uint8Array(b);\n            Module[\"HEAPU16\"] = HEAPU16 = new Uint16Array(b);\n            Module[\"HEAP32\"] = HEAP32 = new Int32Array(b);\n            Module[\"HEAPU32\"] = HEAPU32 = new Uint32Array(b);\n            Module[\"HEAPF32\"] = HEAPF32 = new Float32Array(b);\n            Module[\"HEAPF64\"] = HEAPF64 = new Float64Array(b);\n        }\n        if (ENVIRONMENT_IS_PTHREAD) {\n            var wasmModuleReceived;\n            var initializedJS = false;\n            function threadPrintErr(...args) {\n                var text = args.join(\" \");\n                console.error(text);\n            }\n            if (!Module[\"printErr\"]) err = threadPrintErr;\n            function threadAlert(...args) {\n                var text = args.join(\" \");\n                postMessage({\n                    cmd: \"alert\",\n                    text: text,\n                    threadId: _pthread_self()\n                });\n            }\n            self.alert = threadAlert;\n            self.onunhandledrejection = (e)=>{\n                throw e.reason || e;\n            };\n            function handleMessage(e) {\n                try {\n                    var msgData = e[\"data\"];\n                    var cmd = msgData.cmd;\n                    if (cmd === \"load\") {\n                        let messageQueue = [];\n                        self.onmessage = (e)=>messageQueue.push(e);\n                        self.startWorker = (instance)=>{\n                            postMessage({\n                                cmd: \"loaded\"\n                            });\n                            for (let msg of messageQueue)handleMessage(msg);\n                            self.onmessage = handleMessage;\n                        };\n                        for (const handler of msgData.handlers)if (!Module[handler] || Module[handler].proxy) {\n                            Module[handler] = (...args)=>{\n                                postMessage({\n                                    cmd: \"callHandler\",\n                                    handler: handler,\n                                    args: args\n                                });\n                            };\n                            if (handler == \"print\") out = Module[handler];\n                            if (handler == \"printErr\") err = Module[handler];\n                        }\n                        wasmMemory = msgData.wasmMemory;\n                        updateMemoryViews();\n                        wasmModuleReceived(msgData.wasmModule);\n                    } else if (cmd === \"run\") {\n                        establishStackSpace(msgData.pthread_ptr);\n                        __emscripten_thread_init(msgData.pthread_ptr, 0, 0, 1, 0, 0);\n                        PThread.receiveObjectTransfer(msgData);\n                        PThread.threadInitTLS();\n                        __emscripten_thread_mailbox_await(msgData.pthread_ptr);\n                        if (!initializedJS) {\n                            __embind_initialize_bindings();\n                            initializedJS = true;\n                        }\n                        try {\n                            invokeEntryPoint(msgData.start_routine, msgData.arg);\n                        } catch (ex) {\n                            if (ex != \"unwind\") throw ex;\n                        }\n                    } else if (msgData.target === \"setimmediate\") ;\n                    else if (cmd === \"checkMailbox\") {\n                        if (initializedJS) checkMailbox();\n                    } else if (cmd) {\n                        err(`worker: received unknown command ${cmd}`);\n                        err(msgData);\n                    }\n                } catch (ex) {\n                    __emscripten_thread_crashed();\n                    throw ex;\n                }\n            }\n            self.onmessage = handleMessage;\n        }\n        if (!ENVIRONMENT_IS_PTHREAD) {\n            if (Module[\"wasmMemory\"]) wasmMemory = Module[\"wasmMemory\"];\n            else {\n                var INITIAL_MEMORY = Module[\"INITIAL_MEMORY\"] || 16777216;\n                wasmMemory = new WebAssembly.Memory({\n                    initial: INITIAL_MEMORY / 65536,\n                    maximum: 65536,\n                    shared: true\n                });\n            }\n            updateMemoryViews();\n        }\n        var __ATPRERUN__ = [];\n        var __ATINIT__ = [];\n        var __ATPOSTRUN__ = [];\n        var runtimeInitialized = false;\n        function preRun() {\n            if (Module[\"preRun\"]) {\n                if (typeof Module[\"preRun\"] == \"function\") Module[\"preRun\"] = [\n                    Module[\"preRun\"]\n                ];\n                while(Module[\"preRun\"].length)addOnPreRun(Module[\"preRun\"].shift());\n            }\n            callRuntimeCallbacks(__ATPRERUN__);\n        }\n        function initRuntime() {\n            runtimeInitialized = true;\n            if (ENVIRONMENT_IS_PTHREAD) return;\n            if (!Module[\"noFSInit\"] && !FS.initialized) FS.init();\n            FS.ignorePermissions = false;\n            TTY.init();\n            callRuntimeCallbacks(__ATINIT__);\n        }\n        function postRun() {\n            if (ENVIRONMENT_IS_PTHREAD) return;\n            if (Module[\"postRun\"]) {\n                if (typeof Module[\"postRun\"] == \"function\") Module[\"postRun\"] = [\n                    Module[\"postRun\"]\n                ];\n                while(Module[\"postRun\"].length)addOnPostRun(Module[\"postRun\"].shift());\n            }\n            callRuntimeCallbacks(__ATPOSTRUN__);\n        }\n        function addOnPreRun(cb) {\n            __ATPRERUN__.unshift(cb);\n        }\n        function addOnInit(cb) {\n            __ATINIT__.unshift(cb);\n        }\n        function addOnPostRun(cb) {\n            __ATPOSTRUN__.unshift(cb);\n        }\n        var runDependencies = 0;\n        var runDependencyWatcher = null;\n        var dependenciesFulfilled = null;\n        function getUniqueRunDependency(id) {\n            return id;\n        }\n        function addRunDependency(id) {\n            runDependencies++;\n            Module[\"monitorRunDependencies\"]?.(runDependencies);\n        }\n        function removeRunDependency(id) {\n            runDependencies--;\n            Module[\"monitorRunDependencies\"]?.(runDependencies);\n            if (runDependencies == 0) {\n                if (runDependencyWatcher !== null) {\n                    clearInterval(runDependencyWatcher);\n                    runDependencyWatcher = null;\n                }\n                if (dependenciesFulfilled) {\n                    var callback = dependenciesFulfilled;\n                    dependenciesFulfilled = null;\n                    callback();\n                }\n            }\n        }\n        function abort(what) {\n            Module[\"onAbort\"]?.(what);\n            what = \"Aborted(\" + what + \")\";\n            err(what);\n            ABORT = true;\n            what += \". Build with -sASSERTIONS for more info.\";\n            var e = new WebAssembly.RuntimeError(what);\n            readyPromiseReject(e);\n            throw e;\n        }\n        var dataURIPrefix = \"data:application/octet-stream;base64,\";\n        var isDataURI = (filename)=>filename.startsWith(dataURIPrefix);\n        function findWasmBinary() {\n            var f = \"ConwayGeomWasmWebMT.wasm\";\n            if (!isDataURI(f)) return locateFile(f);\n            return f;\n        }\n        var wasmBinaryFile;\n        function getBinarySync(file) {\n            if (file == wasmBinaryFile && wasmBinary) return new Uint8Array(wasmBinary);\n            if (readBinary) return readBinary(file);\n            throw \"both async and sync fetching of the wasm failed\";\n        }\n        function getBinaryPromise(binaryFile) {\n            if (!wasmBinary) return readAsync(binaryFile).then((response)=>new Uint8Array(response), ()=>getBinarySync(binaryFile));\n            return Promise.resolve().then(()=>getBinarySync(binaryFile));\n        }\n        function instantiateArrayBuffer(binaryFile, imports, receiver) {\n            return getBinaryPromise(binaryFile).then((binary)=>WebAssembly.instantiate(binary, imports)).then(receiver, (reason)=>{\n                err(`failed to asynchronously prepare wasm: ${reason}`);\n                abort(reason);\n            });\n        }\n        function instantiateAsync(binary, binaryFile, imports, callback) {\n            if (!binary && typeof WebAssembly.instantiateStreaming == \"function\" && !isDataURI(binaryFile) && typeof fetch == \"function\") return fetch(binaryFile, {\n                credentials: \"same-origin\"\n            }).then((response)=>{\n                var result = WebAssembly.instantiateStreaming(response, imports);\n                return result.then(callback, function(reason) {\n                    err(`wasm streaming compile failed: ${reason}`);\n                    err(\"falling back to ArrayBuffer instantiation\");\n                    return instantiateArrayBuffer(binaryFile, imports, callback);\n                });\n            });\n            return instantiateArrayBuffer(binaryFile, imports, callback);\n        }\n        function getWasmImports() {\n            assignWasmImports();\n            return {\n                a: wasmImports\n            };\n        }\n        function createWasm() {\n            function receiveInstance(instance, module) {\n                wasmExports = instance.exports;\n                wasmExports = applySignatureConversions(wasmExports);\n                registerTLSInit(wasmExports[\"ub\"]);\n                wasmTable = wasmExports[\"pb\"];\n                addOnInit(wasmExports[\"nb\"]);\n                wasmModule = module;\n                removeRunDependency(\"wasm-instantiate\");\n                return wasmExports;\n            }\n            addRunDependency(\"wasm-instantiate\");\n            function receiveInstantiationResult(result) {\n                receiveInstance(result[\"instance\"], result[\"module\"]);\n            }\n            var info = getWasmImports();\n            if (Module[\"instantiateWasm\"]) try {\n                return Module[\"instantiateWasm\"](info, receiveInstance);\n            } catch (e) {\n                err(`Module.instantiateWasm callback failed with error: ${e}`);\n                readyPromiseReject(e);\n            }\n            if (ENVIRONMENT_IS_PTHREAD) return new Promise((resolve)=>{\n                wasmModuleReceived = (module)=>{\n                    var instance = new WebAssembly.Instance(module, getWasmImports());\n                    receiveInstance(instance, module);\n                    resolve();\n                };\n            });\n            wasmBinaryFile ??= findWasmBinary();\n            instantiateAsync(wasmBinary, wasmBinaryFile, info, receiveInstantiationResult).catch(readyPromiseReject);\n            return {};\n        }\n        var tempDouble;\n        var tempI64;\n        var ASM_CONSTS = {\n            106532: ($0)=>{\n                let globalScope = typeof window !== \"undefined\" ? window : $parcel$global;\n                if (typeof globalScope[\"logInfo\"] === \"function\") globalScope[\"logInfo\"](UTF8ToString($0));\n            },\n            106701: ($0)=>{\n                let globalScope = typeof window !== \"undefined\" ? window : $parcel$global;\n                if (typeof globalScope[\"logWarning\"] === \"function\") globalScope[\"logWarning\"](UTF8ToString($0));\n            },\n            106876: ($0)=>{\n                let globalScope = typeof window !== \"undefined\" ? window : $parcel$global;\n                if (typeof globalScope[\"logError\"] === \"function\") globalScope[\"logError\"](UTF8ToString($0));\n            }\n        };\n        class ExitStatus {\n            name = \"ExitStatus\";\n            constructor(status){\n                this.message = `Program terminated with exit(${status})`;\n                this.status = status;\n            }\n        }\n        var terminateWorker = (worker)=>{\n            worker.terminate();\n            worker.onmessage = (e)=>{};\n        };\n        var cleanupThread = (pthread_ptr)=>{\n            var worker = PThread.pthreads[pthread_ptr];\n            PThread.returnWorkerToPool(worker);\n        };\n        var spawnThread = (threadParams)=>{\n            var worker = PThread.getNewWorker();\n            if (!worker) return 6;\n            PThread.runningWorkers.push(worker);\n            PThread.pthreads[threadParams.pthread_ptr] = worker;\n            worker.pthread_ptr = threadParams.pthread_ptr;\n            var msg = {\n                cmd: \"run\",\n                start_routine: threadParams.startRoutine,\n                arg: threadParams.arg,\n                pthread_ptr: threadParams.pthread_ptr\n            };\n            worker.postMessage(msg, threadParams.transferList);\n            return 0;\n        };\n        var runtimeKeepaliveCounter = 0;\n        var keepRuntimeAlive = ()=>noExitRuntime || runtimeKeepaliveCounter > 0;\n        var stackSave = ()=>_emscripten_stack_get_current();\n        var stackRestore = (val)=>__emscripten_stack_restore(val);\n        var stackAlloc = (sz)=>__emscripten_stack_alloc(sz);\n        var convertI32PairToI53Checked = (lo, hi)=>hi + 2097152 >>> 0 < 4194305 - !!lo ? (lo >>> 0) + hi * 4294967296 : NaN;\n        var proxyToMainThread = (funcIndex, emAsmAddr, sync, ...callArgs)=>{\n            var serializedNumCallArgs = callArgs.length;\n            var sp = stackSave();\n            var args = stackAlloc(serializedNumCallArgs * 8);\n            var b = args >>> 3;\n            for(var i = 0; i < callArgs.length; i++){\n                var arg = callArgs[i];\n                GROWABLE_HEAP_F64()[b + i >>> 0] = arg;\n            }\n            var rtn = __emscripten_run_on_main_thread_js(funcIndex, emAsmAddr, serializedNumCallArgs, args, sync);\n            stackRestore(sp);\n            return rtn;\n        };\n        function _proc_exit(code) {\n            if (ENVIRONMENT_IS_PTHREAD) return proxyToMainThread(0, 0, 1, code);\n            EXITSTATUS = code;\n            if (!keepRuntimeAlive()) {\n                PThread.terminateAllThreads();\n                Module[\"onExit\"]?.(code);\n                ABORT = true;\n            }\n            quit_(code, new ExitStatus(code));\n        }\n        var handleException = (e)=>{\n            if (e instanceof ExitStatus || e == \"unwind\") return EXITSTATUS;\n            quit_(1, e);\n        };\n        function exitOnMainThread(returnCode) {\n            if (ENVIRONMENT_IS_PTHREAD) return proxyToMainThread(1, 0, 0, returnCode);\n            _exit(returnCode);\n        }\n        var exitJS = (status, implicit)=>{\n            EXITSTATUS = status;\n            if (ENVIRONMENT_IS_PTHREAD) {\n                exitOnMainThread(status);\n                throw \"unwind\";\n            }\n            _proc_exit(status);\n        };\n        var _exit = exitJS;\n        var PThread = {\n            unusedWorkers: [],\n            runningWorkers: [],\n            tlsInitFunctions: [],\n            pthreads: {},\n            init () {\n                if (!ENVIRONMENT_IS_PTHREAD) PThread.initMainThread();\n            },\n            initMainThread () {\n                var pthreadPoolSize = Math.max(navigator.hardwareConcurrency - 1, 1);\n                while(pthreadPoolSize--)PThread.allocateUnusedWorker();\n                addOnPreRun(()=>{\n                    addRunDependency(\"loading-workers\");\n                    PThread.loadWasmModuleToAllWorkers(()=>removeRunDependency(\"loading-workers\"));\n                });\n            },\n            terminateAllThreads: ()=>{\n                for (var worker of PThread.runningWorkers)terminateWorker(worker);\n                for (var worker of PThread.unusedWorkers)terminateWorker(worker);\n                PThread.unusedWorkers = [];\n                PThread.runningWorkers = [];\n                PThread.pthreads = {};\n            },\n            returnWorkerToPool: (worker)=>{\n                var pthread_ptr = worker.pthread_ptr;\n                delete PThread.pthreads[pthread_ptr];\n                PThread.unusedWorkers.push(worker);\n                PThread.runningWorkers.splice(PThread.runningWorkers.indexOf(worker), 1);\n                worker.pthread_ptr = 0;\n                __emscripten_thread_free_data(pthread_ptr);\n            },\n            receiveObjectTransfer (data) {},\n            threadInitTLS () {\n                PThread.tlsInitFunctions.forEach((f)=>f());\n            },\n            loadWasmModuleToWorker: (worker)=>new Promise((onFinishedLoading)=>{\n                    worker.onmessage = (e)=>{\n                        var d = e[\"data\"];\n                        var cmd = d.cmd;\n                        if (d.targetThread && d.targetThread != _pthread_self()) {\n                            var targetWorker = PThread.pthreads[d.targetThread];\n                            if (targetWorker) targetWorker.postMessage(d, d.transferList);\n                            else err(`Internal error! Worker sent a message \"${cmd}\" to target pthread ${d.targetThread}, but that thread no longer exists!`);\n                            return;\n                        }\n                        if (cmd === \"checkMailbox\") checkMailbox();\n                        else if (cmd === \"spawnThread\") spawnThread(d);\n                        else if (cmd === \"cleanupThread\") cleanupThread(d.thread);\n                        else if (cmd === \"loaded\") {\n                            worker.loaded = true;\n                            onFinishedLoading(worker);\n                        } else if (cmd === \"alert\") alert(`Thread ${d.threadId}: ${d.text}`);\n                        else if (d.target === \"setimmediate\") worker.postMessage(d);\n                        else if (cmd === \"callHandler\") Module[d.handler](...d.args);\n                        else if (cmd) err(`worker sent an unknown command ${cmd}`);\n                    };\n                    worker.onerror = (e)=>{\n                        var message = \"worker sent an error!\";\n                        err(`${message} ${e.filename}:${e.lineno}: ${e.message}`);\n                        throw e;\n                    };\n                    var handlers = [];\n                    var knownHandlers = [\n                        \"onExit\",\n                        \"onAbort\",\n                        \"print\",\n                        \"printErr\"\n                    ];\n                    for (var handler of knownHandlers)if (Module.propertyIsEnumerable(handler)) handlers.push(handler);\n                    worker.postMessage({\n                        cmd: \"load\",\n                        handlers: handlers,\n                        wasmMemory: wasmMemory,\n                        wasmModule: wasmModule\n                    });\n                }),\n            loadWasmModuleToAllWorkers (onMaybeReady) {\n                if (ENVIRONMENT_IS_PTHREAD) return onMaybeReady();\n                let pthreadPoolReady = Promise.all(PThread.unusedWorkers.map(PThread.loadWasmModuleToWorker));\n                pthreadPoolReady.then(onMaybeReady);\n            },\n            allocateUnusedWorker () {\n                var worker;\n                var workerOptions = {\n                    type: \"module\",\n                    name: \"em-pthread\"\n                };\n                var pthreadMainJs = _scriptName;\n                if (Module[\"mainScriptUrlOrBlob\"]) {\n                    pthreadMainJs = Module[\"mainScriptUrlOrBlob\"];\n                    if (typeof pthreadMainJs != \"string\") pthreadMainJs = URL.createObjectURL(pthreadMainJs);\n                }\n                worker = new Worker(pthreadMainJs, workerOptions);\n                PThread.unusedWorkers.push(worker);\n            },\n            getNewWorker () {\n                if (PThread.unusedWorkers.length == 0) {\n                    PThread.allocateUnusedWorker();\n                    PThread.loadWasmModuleToWorker(PThread.unusedWorkers[0]);\n                }\n                return PThread.unusedWorkers.pop();\n            }\n        };\n        var callRuntimeCallbacks = (callbacks)=>{\n            while(callbacks.length > 0)callbacks.shift()(Module);\n        };\n        var establishStackSpace = (pthread_ptr)=>{\n            updateMemoryViews();\n            var stackHigh = GROWABLE_HEAP_U32()[pthread_ptr + 52 >>> 2 >>> 0];\n            var stackSize = GROWABLE_HEAP_U32()[pthread_ptr + 56 >>> 2 >>> 0];\n            var stackLow = stackHigh - stackSize;\n            _emscripten_stack_set_limits(stackHigh, stackLow);\n            stackRestore(stackHigh);\n        };\n        var wasmTableMirror = [];\n        var wasmTable;\n        var getWasmTableEntry = (funcPtr)=>{\n            var func = wasmTableMirror[funcPtr];\n            if (!func) {\n                if (funcPtr >= wasmTableMirror.length) wasmTableMirror.length = funcPtr + 1;\n                wasmTableMirror[funcPtr] = func = wasmTable.get(funcPtr);\n            }\n            return func;\n        };\n        var invokeEntryPoint = (ptr, arg)=>{\n            runtimeKeepaliveCounter = 0;\n            noExitRuntime = 0;\n            var result = getWasmTableEntry(ptr)(arg);\n            function finish(result) {\n                if (keepRuntimeAlive()) EXITSTATUS = result;\n                else __emscripten_thread_exit(result);\n            }\n            finish(result);\n        };\n        var noExitRuntime = Module[\"noExitRuntime\"] || true;\n        var registerTLSInit = (tlsInitFunc)=>PThread.tlsInitFunctions.push(tlsInitFunc);\n        var exceptionCaught = [];\n        var uncaughtExceptionCount = 0;\n        function ___cxa_begin_catch(ptr) {\n            ptr >>>= 0;\n            var info = new ExceptionInfo(ptr);\n            if (!info.get_caught()) {\n                info.set_caught(true);\n                uncaughtExceptionCount--;\n            }\n            info.set_rethrown(false);\n            exceptionCaught.push(info);\n            ___cxa_increment_exception_refcount(ptr);\n            return ___cxa_get_exception_ptr(ptr);\n        }\n        var exceptionLast = 0;\n        var ___cxa_end_catch = ()=>{\n            _setThrew(0, 0);\n            var info = exceptionCaught.pop();\n            ___cxa_decrement_exception_refcount(info.excPtr);\n            exceptionLast = 0;\n        };\n        class ExceptionInfo {\n            constructor(excPtr){\n                this.excPtr = excPtr;\n                this.ptr = excPtr - 24;\n            }\n            set_type(type) {\n                GROWABLE_HEAP_U32()[this.ptr + 4 >>> 2 >>> 0] = type;\n            }\n            get_type() {\n                return GROWABLE_HEAP_U32()[this.ptr + 4 >>> 2 >>> 0];\n            }\n            set_destructor(destructor) {\n                GROWABLE_HEAP_U32()[this.ptr + 8 >>> 2 >>> 0] = destructor;\n            }\n            get_destructor() {\n                return GROWABLE_HEAP_U32()[this.ptr + 8 >>> 2 >>> 0];\n            }\n            set_caught(caught) {\n                caught = caught ? 1 : 0;\n                GROWABLE_HEAP_I8()[this.ptr + 12 >>> 0] = caught;\n            }\n            get_caught() {\n                return GROWABLE_HEAP_I8()[this.ptr + 12 >>> 0] != 0;\n            }\n            set_rethrown(rethrown) {\n                rethrown = rethrown ? 1 : 0;\n                GROWABLE_HEAP_I8()[this.ptr + 13 >>> 0] = rethrown;\n            }\n            get_rethrown() {\n                return GROWABLE_HEAP_I8()[this.ptr + 13 >>> 0] != 0;\n            }\n            init(type, destructor) {\n                this.set_adjusted_ptr(0);\n                this.set_type(type);\n                this.set_destructor(destructor);\n            }\n            set_adjusted_ptr(adjustedPtr) {\n                GROWABLE_HEAP_U32()[this.ptr + 16 >>> 2 >>> 0] = adjustedPtr;\n            }\n            get_adjusted_ptr() {\n                return GROWABLE_HEAP_U32()[this.ptr + 16 >>> 2 >>> 0];\n            }\n        }\n        function ___resumeException(ptr) {\n            ptr >>>= 0;\n            if (!exceptionLast) exceptionLast = ptr;\n            throw exceptionLast;\n        }\n        var setTempRet0 = (val)=>__emscripten_tempret_set(val);\n        var findMatchingCatch = (args)=>{\n            var thrown = exceptionLast;\n            if (!thrown) {\n                setTempRet0(0);\n                return 0;\n            }\n            var info = new ExceptionInfo(thrown);\n            info.set_adjusted_ptr(thrown);\n            var thrownType = info.get_type();\n            if (!thrownType) {\n                setTempRet0(0);\n                return thrown;\n            }\n            for (var caughtType of args){\n                if (caughtType === 0 || caughtType === thrownType) break;\n                var adjusted_ptr_addr = info.ptr + 16;\n                if (___cxa_can_catch(caughtType, thrownType, adjusted_ptr_addr)) {\n                    setTempRet0(caughtType);\n                    return thrown;\n                }\n            }\n            setTempRet0(thrownType);\n            return thrown;\n        };\n        function ___cxa_find_matching_catch_2() {\n            return findMatchingCatch([]);\n        }\n        function ___cxa_find_matching_catch_3(arg0) {\n            arg0 >>>= 0;\n            return findMatchingCatch([\n                arg0\n            ]);\n        }\n        function ___cxa_find_matching_catch_4(arg0, arg1) {\n            arg0 >>>= 0;\n            arg1 >>>= 0;\n            return findMatchingCatch([\n                arg0,\n                arg1\n            ]);\n        }\n        var ___cxa_rethrow = ()=>{\n            var info = exceptionCaught.pop();\n            if (!info) abort(\"no exception to throw\");\n            var ptr = info.excPtr;\n            if (!info.get_rethrown()) {\n                exceptionCaught.push(info);\n                info.set_rethrown(true);\n                info.set_caught(false);\n                uncaughtExceptionCount++;\n            }\n            exceptionLast = ptr;\n            throw exceptionLast;\n        };\n        function ___cxa_throw(ptr, type, destructor) {\n            ptr >>>= 0;\n            type >>>= 0;\n            destructor >>>= 0;\n            var info = new ExceptionInfo(ptr);\n            info.init(type, destructor);\n            exceptionLast = ptr;\n            uncaughtExceptionCount++;\n            throw exceptionLast;\n        }\n        var ___cxa_uncaught_exceptions = ()=>uncaughtExceptionCount;\n        function pthreadCreateProxied(pthread_ptr, attr, startRoutine, arg) {\n            if (ENVIRONMENT_IS_PTHREAD) return proxyToMainThread(2, 0, 1, pthread_ptr, attr, startRoutine, arg);\n            return ___pthread_create_js(pthread_ptr, attr, startRoutine, arg);\n        }\n        var _emscripten_has_threading_support = ()=>typeof SharedArrayBuffer != \"undefined\";\n        function ___pthread_create_js(pthread_ptr, attr, startRoutine, arg) {\n            pthread_ptr >>>= 0;\n            attr >>>= 0;\n            startRoutine >>>= 0;\n            arg >>>= 0;\n            if (!_emscripten_has_threading_support()) return 6;\n            var transferList = [];\n            var error = 0;\n            if (ENVIRONMENT_IS_PTHREAD && (transferList.length === 0 || error)) return pthreadCreateProxied(pthread_ptr, attr, startRoutine, arg);\n            if (error) return error;\n            var threadParams = {\n                startRoutine: startRoutine,\n                pthread_ptr: pthread_ptr,\n                arg: arg,\n                transferList: transferList\n            };\n            if (ENVIRONMENT_IS_PTHREAD) {\n                threadParams.cmd = \"spawnThread\";\n                postMessage(threadParams, transferList);\n                return 0;\n            }\n            return spawnThread(threadParams);\n        }\n        var syscallGetVarargI = ()=>{\n            var ret = GROWABLE_HEAP_I32()[+SYSCALLS.varargs >>> 2 >>> 0];\n            SYSCALLS.varargs += 4;\n            return ret;\n        };\n        var syscallGetVarargP = syscallGetVarargI;\n        var PATH = {\n            isAbs: (path)=>path.charAt(0) === \"/\",\n            splitPath: (filename)=>{\n                var splitPathRe = /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\n                return splitPathRe.exec(filename).slice(1);\n            },\n            normalizeArray: (parts, allowAboveRoot)=>{\n                var up = 0;\n                for(var i = parts.length - 1; i >= 0; i--){\n                    var last = parts[i];\n                    if (last === \".\") parts.splice(i, 1);\n                    else if (last === \"..\") {\n                        parts.splice(i, 1);\n                        up++;\n                    } else if (up) {\n                        parts.splice(i, 1);\n                        up--;\n                    }\n                }\n                if (allowAboveRoot) for(; up; up--)parts.unshift(\"..\");\n                return parts;\n            },\n            normalize: (path)=>{\n                var isAbsolute = PATH.isAbs(path), trailingSlash = path.substr(-1) === \"/\";\n                path = PATH.normalizeArray(path.split(\"/\").filter((p)=>!!p), !isAbsolute).join(\"/\");\n                if (!path && !isAbsolute) path = \".\";\n                if (path && trailingSlash) path += \"/\";\n                return (isAbsolute ? \"/\" : \"\") + path;\n            },\n            dirname: (path)=>{\n                var result = PATH.splitPath(path), root = result[0], dir = result[1];\n                if (!root && !dir) return \".\";\n                if (dir) dir = dir.substr(0, dir.length - 1);\n                return root + dir;\n            },\n            basename: (path)=>{\n                if (path === \"/\") return \"/\";\n                path = PATH.normalize(path);\n                path = path.replace(/\\/$/, \"\");\n                var lastSlash = path.lastIndexOf(\"/\");\n                if (lastSlash === -1) return path;\n                return path.substr(lastSlash + 1);\n            },\n            join: (...paths)=>PATH.normalize(paths.join(\"/\")),\n            join2: (l, r)=>PATH.normalize(l + \"/\" + r)\n        };\n        var initRandomFill = ()=>{\n            if (typeof crypto == \"object\" && typeof crypto[\"getRandomValues\"] == \"function\") return (view)=>(view.set(crypto.getRandomValues(new Uint8Array(view.byteLength))), view);\n            else abort(\"initRandomDevice\");\n        };\n        var randomFill = (view)=>(randomFill = initRandomFill())(view);\n        var PATH_FS = {\n            resolve: (...args)=>{\n                var resolvedPath = \"\", resolvedAbsolute = false;\n                for(var i = args.length - 1; i >= -1 && !resolvedAbsolute; i--){\n                    var path = i >= 0 ? args[i] : FS.cwd();\n                    if (typeof path != \"string\") throw new TypeError(\"Arguments to path.resolve must be strings\");\n                    else if (!path) return \"\";\n                    resolvedPath = path + \"/\" + resolvedPath;\n                    resolvedAbsolute = PATH.isAbs(path);\n                }\n                resolvedPath = PATH.normalizeArray(resolvedPath.split(\"/\").filter((p)=>!!p), !resolvedAbsolute).join(\"/\");\n                return (resolvedAbsolute ? \"/\" : \"\") + resolvedPath || \".\";\n            },\n            relative: (from, to)=>{\n                from = PATH_FS.resolve(from).substr(1);\n                to = PATH_FS.resolve(to).substr(1);\n                function trim(arr) {\n                    var start = 0;\n                    for(; start < arr.length; start++){\n                        if (arr[start] !== \"\") break;\n                    }\n                    var end = arr.length - 1;\n                    for(; end >= 0; end--){\n                        if (arr[end] !== \"\") break;\n                    }\n                    if (start > end) return [];\n                    return arr.slice(start, end - start + 1);\n                }\n                var fromParts = trim(from.split(\"/\"));\n                var toParts = trim(to.split(\"/\"));\n                var length = Math.min(fromParts.length, toParts.length);\n                var samePartsLength = length;\n                for(var i = 0; i < length; i++)if (fromParts[i] !== toParts[i]) {\n                    samePartsLength = i;\n                    break;\n                }\n                var outputParts = [];\n                for(var i = samePartsLength; i < fromParts.length; i++)outputParts.push(\"..\");\n                outputParts = outputParts.concat(toParts.slice(samePartsLength));\n                return outputParts.join(\"/\");\n            }\n        };\n        var UTF8Decoder = typeof TextDecoder != \"undefined\" ? new TextDecoder : undefined;\n        var UTF8ArrayToString = (heapOrArray, idx = 0, maxBytesToRead = NaN)=>{\n            idx >>>= 0;\n            var endIdx = idx + maxBytesToRead;\n            var endPtr = idx;\n            while(heapOrArray[endPtr] && !(endPtr >= endIdx))++endPtr;\n            if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) return UTF8Decoder.decode(heapOrArray.buffer instanceof ArrayBuffer ? heapOrArray.subarray(idx, endPtr) : heapOrArray.slice(idx, endPtr));\n            var str = \"\";\n            while(idx < endPtr){\n                var u0 = heapOrArray[idx++];\n                if (!(u0 & 128)) {\n                    str += String.fromCharCode(u0);\n                    continue;\n                }\n                var u1 = heapOrArray[idx++] & 63;\n                if ((u0 & 224) == 192) {\n                    str += String.fromCharCode((u0 & 31) << 6 | u1);\n                    continue;\n                }\n                var u2 = heapOrArray[idx++] & 63;\n                if ((u0 & 240) == 224) u0 = (u0 & 15) << 12 | u1 << 6 | u2;\n                else u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heapOrArray[idx++] & 63;\n                if (u0 < 65536) str += String.fromCharCode(u0);\n                else {\n                    var ch = u0 - 65536;\n                    str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);\n                }\n            }\n            return str;\n        };\n        var FS_stdin_getChar_buffer = [];\n        var lengthBytesUTF8 = (str)=>{\n            var len = 0;\n            for(var i = 0; i < str.length; ++i){\n                var c = str.charCodeAt(i);\n                if (c <= 127) len++;\n                else if (c <= 2047) len += 2;\n                else if (c >= 55296 && c <= 57343) {\n                    len += 4;\n                    ++i;\n                } else len += 3;\n            }\n            return len;\n        };\n        var stringToUTF8Array = (str, heap, outIdx, maxBytesToWrite)=>{\n            outIdx >>>= 0;\n            if (!(maxBytesToWrite > 0)) return 0;\n            var startIdx = outIdx;\n            var endIdx = outIdx + maxBytesToWrite - 1;\n            for(var i = 0; i < str.length; ++i){\n                var u = str.charCodeAt(i);\n                if (u >= 55296 && u <= 57343) {\n                    var u1 = str.charCodeAt(++i);\n                    u = 65536 + ((u & 1023) << 10) | u1 & 1023;\n                }\n                if (u <= 127) {\n                    if (outIdx >= endIdx) break;\n                    heap[outIdx++ >>> 0] = u;\n                } else if (u <= 2047) {\n                    if (outIdx + 1 >= endIdx) break;\n                    heap[outIdx++ >>> 0] = 192 | u >> 6;\n                    heap[outIdx++ >>> 0] = 128 | u & 63;\n                } else if (u <= 65535) {\n                    if (outIdx + 2 >= endIdx) break;\n                    heap[outIdx++ >>> 0] = 224 | u >> 12;\n                    heap[outIdx++ >>> 0] = 128 | u >> 6 & 63;\n                    heap[outIdx++ >>> 0] = 128 | u & 63;\n                } else {\n                    if (outIdx + 3 >= endIdx) break;\n                    heap[outIdx++ >>> 0] = 240 | u >> 18;\n                    heap[outIdx++ >>> 0] = 128 | u >> 12 & 63;\n                    heap[outIdx++ >>> 0] = 128 | u >> 6 & 63;\n                    heap[outIdx++ >>> 0] = 128 | u & 63;\n                }\n            }\n            heap[outIdx >>> 0] = 0;\n            return outIdx - startIdx;\n        };\n        function intArrayFromString(stringy, dontAddNull, length) {\n            var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;\n            var u8array = new Array(len);\n            var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);\n            if (dontAddNull) u8array.length = numBytesWritten;\n            return u8array;\n        }\n        var FS_stdin_getChar = ()=>{\n            if (!FS_stdin_getChar_buffer.length) {\n                var result = null;\n                if (typeof window != \"undefined\" && typeof window.prompt == \"function\") {\n                    result = window.prompt(\"Input: \");\n                    if (result !== null) result += \"\\n\";\n                }\n                if (!result) return null;\n                FS_stdin_getChar_buffer = intArrayFromString(result, true);\n            }\n            return FS_stdin_getChar_buffer.shift();\n        };\n        var TTY = {\n            ttys: [],\n            init () {},\n            shutdown () {},\n            register (dev, ops) {\n                TTY.ttys[dev] = {\n                    input: [],\n                    output: [],\n                    ops: ops\n                };\n                FS.registerDevice(dev, TTY.stream_ops);\n            },\n            stream_ops: {\n                open (stream) {\n                    var tty = TTY.ttys[stream.node.rdev];\n                    if (!tty) throw new FS.ErrnoError(43);\n                    stream.tty = tty;\n                    stream.seekable = false;\n                },\n                close (stream) {\n                    stream.tty.ops.fsync(stream.tty);\n                },\n                fsync (stream) {\n                    stream.tty.ops.fsync(stream.tty);\n                },\n                read (stream, buffer, offset, length, pos) {\n                    if (!stream.tty || !stream.tty.ops.get_char) throw new FS.ErrnoError(60);\n                    var bytesRead = 0;\n                    for(var i = 0; i < length; i++){\n                        var result;\n                        try {\n                            result = stream.tty.ops.get_char(stream.tty);\n                        } catch (e) {\n                            throw new FS.ErrnoError(29);\n                        }\n                        if (result === undefined && bytesRead === 0) throw new FS.ErrnoError(6);\n                        if (result === null || result === undefined) break;\n                        bytesRead++;\n                        buffer[offset + i] = result;\n                    }\n                    if (bytesRead) stream.node.timestamp = Date.now();\n                    return bytesRead;\n                },\n                write (stream, buffer, offset, length, pos) {\n                    if (!stream.tty || !stream.tty.ops.put_char) throw new FS.ErrnoError(60);\n                    try {\n                        for(var i = 0; i < length; i++)stream.tty.ops.put_char(stream.tty, buffer[offset + i]);\n                    } catch (e) {\n                        throw new FS.ErrnoError(29);\n                    }\n                    if (length) stream.node.timestamp = Date.now();\n                    return i;\n                }\n            },\n            default_tty_ops: {\n                get_char (tty) {\n                    return FS_stdin_getChar();\n                },\n                put_char (tty, val) {\n                    if (val === null || val === 10) {\n                        out(UTF8ArrayToString(tty.output));\n                        tty.output = [];\n                    } else if (val != 0) tty.output.push(val);\n                },\n                fsync (tty) {\n                    if (tty.output && tty.output.length > 0) {\n                        out(UTF8ArrayToString(tty.output));\n                        tty.output = [];\n                    }\n                },\n                ioctl_tcgets (tty) {\n                    return {\n                        c_iflag: 25856,\n                        c_oflag: 5,\n                        c_cflag: 191,\n                        c_lflag: 35387,\n                        c_cc: [\n                            3,\n                            28,\n                            127,\n                            21,\n                            4,\n                            0,\n                            1,\n                            0,\n                            17,\n                            19,\n                            26,\n                            0,\n                            18,\n                            15,\n                            23,\n                            22,\n                            0,\n                            0,\n                            0,\n                            0,\n                            0,\n                            0,\n                            0,\n                            0,\n                            0,\n                            0,\n                            0,\n                            0,\n                            0,\n                            0,\n                            0,\n                            0\n                        ]\n                    };\n                },\n                ioctl_tcsets (tty, optional_actions, data) {\n                    return 0;\n                },\n                ioctl_tiocgwinsz (tty) {\n                    return [\n                        24,\n                        80\n                    ];\n                }\n            },\n            default_tty1_ops: {\n                put_char (tty, val) {\n                    if (val === null || val === 10) {\n                        err(UTF8ArrayToString(tty.output));\n                        tty.output = [];\n                    } else if (val != 0) tty.output.push(val);\n                },\n                fsync (tty) {\n                    if (tty.output && tty.output.length > 0) {\n                        err(UTF8ArrayToString(tty.output));\n                        tty.output = [];\n                    }\n                }\n            }\n        };\n        var alignMemory = (size, alignment)=>Math.ceil(size / alignment) * alignment;\n        var mmapAlloc = (size)=>{\n            abort();\n        };\n        var MEMFS = {\n            ops_table: null,\n            mount (mount) {\n                return MEMFS.createNode(null, \"/\", 16895, 0);\n            },\n            createNode (parent, name, mode, dev) {\n                if (FS.isBlkdev(mode) || FS.isFIFO(mode)) throw new FS.ErrnoError(63);\n                MEMFS.ops_table ||= {\n                    dir: {\n                        node: {\n                            getattr: MEMFS.node_ops.getattr,\n                            setattr: MEMFS.node_ops.setattr,\n                            lookup: MEMFS.node_ops.lookup,\n                            mknod: MEMFS.node_ops.mknod,\n                            rename: MEMFS.node_ops.rename,\n                            unlink: MEMFS.node_ops.unlink,\n                            rmdir: MEMFS.node_ops.rmdir,\n                            readdir: MEMFS.node_ops.readdir,\n                            symlink: MEMFS.node_ops.symlink\n                        },\n                        stream: {\n                            llseek: MEMFS.stream_ops.llseek\n                        }\n                    },\n                    file: {\n                        node: {\n                            getattr: MEMFS.node_ops.getattr,\n                            setattr: MEMFS.node_ops.setattr\n                        },\n                        stream: {\n                            llseek: MEMFS.stream_ops.llseek,\n                            read: MEMFS.stream_ops.read,\n                            write: MEMFS.stream_ops.write,\n                            allocate: MEMFS.stream_ops.allocate,\n                            mmap: MEMFS.stream_ops.mmap,\n                            msync: MEMFS.stream_ops.msync\n                        }\n                    },\n                    link: {\n                        node: {\n                            getattr: MEMFS.node_ops.getattr,\n                            setattr: MEMFS.node_ops.setattr,\n                            readlink: MEMFS.node_ops.readlink\n                        },\n                        stream: {}\n                    },\n                    chrdev: {\n                        node: {\n                            getattr: MEMFS.node_ops.getattr,\n                            setattr: MEMFS.node_ops.setattr\n                        },\n                        stream: FS.chrdev_stream_ops\n                    }\n                };\n                var node = FS.createNode(parent, name, mode, dev);\n                if (FS.isDir(node.mode)) {\n                    node.node_ops = MEMFS.ops_table.dir.node;\n                    node.stream_ops = MEMFS.ops_table.dir.stream;\n                    node.contents = {};\n                } else if (FS.isFile(node.mode)) {\n                    node.node_ops = MEMFS.ops_table.file.node;\n                    node.stream_ops = MEMFS.ops_table.file.stream;\n                    node.usedBytes = 0;\n                    node.contents = null;\n                } else if (FS.isLink(node.mode)) {\n                    node.node_ops = MEMFS.ops_table.link.node;\n                    node.stream_ops = MEMFS.ops_table.link.stream;\n                } else if (FS.isChrdev(node.mode)) {\n                    node.node_ops = MEMFS.ops_table.chrdev.node;\n                    node.stream_ops = MEMFS.ops_table.chrdev.stream;\n                }\n                node.timestamp = Date.now();\n                if (parent) {\n                    parent.contents[name] = node;\n                    parent.timestamp = node.timestamp;\n                }\n                return node;\n            },\n            getFileDataAsTypedArray (node) {\n                if (!node.contents) return new Uint8Array(0);\n                if (node.contents.subarray) return node.contents.subarray(0, node.usedBytes);\n                return new Uint8Array(node.contents);\n            },\n            expandFileStorage (node, newCapacity) {\n                var prevCapacity = node.contents ? node.contents.length : 0;\n                if (prevCapacity >= newCapacity) return;\n                var CAPACITY_DOUBLING_MAX = 1048576;\n                newCapacity = Math.max(newCapacity, prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125) >>> 0);\n                if (prevCapacity != 0) newCapacity = Math.max(newCapacity, 256);\n                var oldContents = node.contents;\n                node.contents = new Uint8Array(newCapacity);\n                if (node.usedBytes > 0) node.contents.set(oldContents.subarray(0, node.usedBytes), 0);\n            },\n            resizeFileStorage (node, newSize) {\n                if (node.usedBytes == newSize) return;\n                if (newSize == 0) {\n                    node.contents = null;\n                    node.usedBytes = 0;\n                } else {\n                    var oldContents = node.contents;\n                    node.contents = new Uint8Array(newSize);\n                    if (oldContents) node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes)));\n                    node.usedBytes = newSize;\n                }\n            },\n            node_ops: {\n                getattr (node) {\n                    var attr = {};\n                    attr.dev = FS.isChrdev(node.mode) ? node.id : 1;\n                    attr.ino = node.id;\n                    attr.mode = node.mode;\n                    attr.nlink = 1;\n                    attr.uid = 0;\n                    attr.gid = 0;\n                    attr.rdev = node.rdev;\n                    if (FS.isDir(node.mode)) attr.size = 4096;\n                    else if (FS.isFile(node.mode)) attr.size = node.usedBytes;\n                    else if (FS.isLink(node.mode)) attr.size = node.link.length;\n                    else attr.size = 0;\n                    attr.atime = new Date(node.timestamp);\n                    attr.mtime = new Date(node.timestamp);\n                    attr.ctime = new Date(node.timestamp);\n                    attr.blksize = 4096;\n                    attr.blocks = Math.ceil(attr.size / attr.blksize);\n                    return attr;\n                },\n                setattr (node, attr) {\n                    if (attr.mode !== undefined) node.mode = attr.mode;\n                    if (attr.timestamp !== undefined) node.timestamp = attr.timestamp;\n                    if (attr.size !== undefined) MEMFS.resizeFileStorage(node, attr.size);\n                },\n                lookup (parent, name) {\n                    throw MEMFS.doesNotExistError;\n                },\n                mknod (parent, name, mode, dev) {\n                    return MEMFS.createNode(parent, name, mode, dev);\n                },\n                rename (old_node, new_dir, new_name) {\n                    if (FS.isDir(old_node.mode)) {\n                        var new_node;\n                        try {\n                            new_node = FS.lookupNode(new_dir, new_name);\n                        } catch (e) {}\n                        if (new_node) {\n                            for(var i in new_node.contents)throw new FS.ErrnoError(55);\n                        }\n                    }\n                    delete old_node.parent.contents[old_node.name];\n                    old_node.parent.timestamp = Date.now();\n                    old_node.name = new_name;\n                    new_dir.contents[new_name] = old_node;\n                    new_dir.timestamp = old_node.parent.timestamp;\n                },\n                unlink (parent, name) {\n                    delete parent.contents[name];\n                    parent.timestamp = Date.now();\n                },\n                rmdir (parent, name) {\n                    var node = FS.lookupNode(parent, name);\n                    for(var i in node.contents)throw new FS.ErrnoError(55);\n                    delete parent.contents[name];\n                    parent.timestamp = Date.now();\n                },\n                readdir (node) {\n                    var entries = [\n                        \".\",\n                        \"..\"\n                    ];\n                    for (var key of Object.keys(node.contents))entries.push(key);\n                    return entries;\n                },\n                symlink (parent, newname, oldpath) {\n                    var node = MEMFS.createNode(parent, newname, 41471, 0);\n                    node.link = oldpath;\n                    return node;\n                },\n                readlink (node) {\n                    if (!FS.isLink(node.mode)) throw new FS.ErrnoError(28);\n                    return node.link;\n                }\n            },\n            stream_ops: {\n                read (stream, buffer, offset, length, position) {\n                    var contents = stream.node.contents;\n                    if (position >= stream.node.usedBytes) return 0;\n                    var size = Math.min(stream.node.usedBytes - position, length);\n                    if (size > 8 && contents.subarray) buffer.set(contents.subarray(position, position + size), offset);\n                    else for(var i = 0; i < size; i++)buffer[offset + i] = contents[position + i];\n                    return size;\n                },\n                write (stream, buffer, offset, length, position, canOwn) {\n                    if (buffer.buffer === GROWABLE_HEAP_I8().buffer) canOwn = false;\n                    if (!length) return 0;\n                    var node = stream.node;\n                    node.timestamp = Date.now();\n                    if (buffer.subarray && (!node.contents || node.contents.subarray)) {\n                        if (canOwn) {\n                            node.contents = buffer.subarray(offset, offset + length);\n                            node.usedBytes = length;\n                            return length;\n                        } else if (node.usedBytes === 0 && position === 0) {\n                            node.contents = buffer.slice(offset, offset + length);\n                            node.usedBytes = length;\n                            return length;\n                        } else if (position + length <= node.usedBytes) {\n                            node.contents.set(buffer.subarray(offset, offset + length), position);\n                            return length;\n                        }\n                    }\n                    MEMFS.expandFileStorage(node, position + length);\n                    if (node.contents.subarray && buffer.subarray) node.contents.set(buffer.subarray(offset, offset + length), position);\n                    else for(var i = 0; i < length; i++)node.contents[position + i] = buffer[offset + i];\n                    node.usedBytes = Math.max(node.usedBytes, position + length);\n                    return length;\n                },\n                llseek (stream, offset, whence) {\n                    var position = offset;\n                    if (whence === 1) position += stream.position;\n                    else if (whence === 2) {\n                        if (FS.isFile(stream.node.mode)) position += stream.node.usedBytes;\n                    }\n                    if (position < 0) throw new FS.ErrnoError(28);\n                    return position;\n                },\n                allocate (stream, offset, length) {\n                    MEMFS.expandFileStorage(stream.node, offset + length);\n                    stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length);\n                },\n                mmap (stream, length, position, prot, flags) {\n                    if (!FS.isFile(stream.node.mode)) throw new FS.ErrnoError(43);\n                    var ptr;\n                    var allocated;\n                    var contents = stream.node.contents;\n                    if (!(flags & 2) && contents && contents.buffer === GROWABLE_HEAP_I8().buffer) {\n                        allocated = false;\n                        ptr = contents.byteOffset;\n                    } else {\n                        allocated = true;\n                        ptr = mmapAlloc(length);\n                        if (!ptr) throw new FS.ErrnoError(48);\n                        if (contents) {\n                            if (position > 0 || position + length < contents.length) {\n                                if (contents.subarray) contents = contents.subarray(position, position + length);\n                                else contents = Array.prototype.slice.call(contents, position, position + length);\n                            }\n                            GROWABLE_HEAP_I8().set(contents, ptr >>> 0);\n                        }\n                    }\n                    return {\n                        ptr: ptr,\n                        allocated: allocated\n                    };\n                },\n                msync (stream, buffer, offset, length, mmapFlags) {\n                    MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false);\n                    return 0;\n                }\n            }\n        };\n        var asyncLoad = (url, onload, onerror, noRunDep)=>{\n            var dep = !noRunDep ? getUniqueRunDependency(`al ${url}`) : \"\";\n            readAsync(url).then((arrayBuffer)=>{\n                onload(new Uint8Array(arrayBuffer));\n                if (dep) removeRunDependency(dep);\n            }, (err)=>{\n                if (onerror) onerror();\n                else throw `Loading data file \"${url}\" failed.`;\n            });\n            if (dep) addRunDependency(dep);\n        };\n        var FS_createDataFile = (parent, name, fileData, canRead, canWrite, canOwn)=>{\n            FS.createDataFile(parent, name, fileData, canRead, canWrite, canOwn);\n        };\n        var preloadPlugins = Module[\"preloadPlugins\"] || [];\n        var FS_handledByPreloadPlugin = (byteArray, fullname, finish, onerror)=>{\n            if (typeof Browser != \"undefined\") Browser.init();\n            var handled = false;\n            preloadPlugins.forEach((plugin)=>{\n                if (handled) return;\n                if (plugin[\"canHandle\"](fullname)) {\n                    plugin[\"handle\"](byteArray, fullname, finish, onerror);\n                    handled = true;\n                }\n            });\n            return handled;\n        };\n        var FS_createPreloadedFile = (parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish)=>{\n            var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent;\n            var dep = getUniqueRunDependency(`cp ${fullname}`);\n            function processData(byteArray) {\n                function finish(byteArray) {\n                    preFinish?.();\n                    if (!dontCreateFile) FS_createDataFile(parent, name, byteArray, canRead, canWrite, canOwn);\n                    onload?.();\n                    removeRunDependency(dep);\n                }\n                if (FS_handledByPreloadPlugin(byteArray, fullname, finish, ()=>{\n                    onerror?.();\n                    removeRunDependency(dep);\n                })) return;\n                finish(byteArray);\n            }\n            addRunDependency(dep);\n            if (typeof url == \"string\") asyncLoad(url, processData, onerror);\n            else processData(url);\n        };\n        var FS_modeStringToFlags = (str)=>{\n            var flagModes = {\n                r: 0,\n                \"r+\": 2,\n                w: 577,\n                \"w+\": 578,\n                a: 1089,\n                \"a+\": 1090\n            };\n            var flags = flagModes[str];\n            if (typeof flags == \"undefined\") throw new Error(`Unknown file open mode: ${str}`);\n            return flags;\n        };\n        var FS_getMode = (canRead, canWrite)=>{\n            var mode = 0;\n            if (canRead) mode |= 365;\n            if (canWrite) mode |= 146;\n            return mode;\n        };\n        var WORKERFS = {\n            DIR_MODE: 16895,\n            FILE_MODE: 33279,\n            reader: null,\n            mount (mount) {\n                assert(ENVIRONMENT_IS_WORKER);\n                WORKERFS.reader ??= new FileReaderSync;\n                var root = WORKERFS.createNode(null, \"/\", WORKERFS.DIR_MODE, 0);\n                var createdParents = {};\n                function ensureParent(path) {\n                    var parts = path.split(\"/\");\n                    var parent = root;\n                    for(var i = 0; i < parts.length - 1; i++){\n                        var curr = parts.slice(0, i + 1).join(\"/\");\n                        createdParents[curr] ||= WORKERFS.createNode(parent, parts[i], WORKERFS.DIR_MODE, 0);\n                        parent = createdParents[curr];\n                    }\n                    return parent;\n                }\n                function base(path) {\n                    var parts = path.split(\"/\");\n                    return parts[parts.length - 1];\n                }\n                Array.prototype.forEach.call(mount.opts[\"files\"] || [], function(file) {\n                    WORKERFS.createNode(ensureParent(file.name), base(file.name), WORKERFS.FILE_MODE, 0, file, file.lastModifiedDate);\n                });\n                (mount.opts[\"blobs\"] || []).forEach((obj)=>{\n                    WORKERFS.createNode(ensureParent(obj[\"name\"]), base(obj[\"name\"]), WORKERFS.FILE_MODE, 0, obj[\"data\"]);\n                });\n                (mount.opts[\"packages\"] || []).forEach((pack)=>{\n                    pack[\"metadata\"].files.forEach((file)=>{\n                        var name = file.filename.substr(1);\n                        WORKERFS.createNode(ensureParent(name), base(name), WORKERFS.FILE_MODE, 0, pack[\"blob\"].slice(file.start, file.end));\n                    });\n                });\n                return root;\n            },\n            createNode (parent, name, mode, dev, contents, mtime) {\n                var node = FS.createNode(parent, name, mode);\n                node.mode = mode;\n                node.node_ops = WORKERFS.node_ops;\n                node.stream_ops = WORKERFS.stream_ops;\n                node.timestamp = (mtime || new Date).getTime();\n                assert(WORKERFS.FILE_MODE !== WORKERFS.DIR_MODE);\n                if (mode === WORKERFS.FILE_MODE) {\n                    node.size = contents.size;\n                    node.contents = contents;\n                } else {\n                    node.size = 4096;\n                    node.contents = {};\n                }\n                if (parent) parent.contents[name] = node;\n                return node;\n            },\n            node_ops: {\n                getattr (node) {\n                    return {\n                        dev: 1,\n                        ino: node.id,\n                        mode: node.mode,\n                        nlink: 1,\n                        uid: 0,\n                        gid: 0,\n                        rdev: 0,\n                        size: node.size,\n                        atime: new Date(node.timestamp),\n                        mtime: new Date(node.timestamp),\n                        ctime: new Date(node.timestamp),\n                        blksize: 4096,\n                        blocks: Math.ceil(node.size / 4096)\n                    };\n                },\n                setattr (node, attr) {\n                    if (attr.mode !== undefined) node.mode = attr.mode;\n                    if (attr.timestamp !== undefined) node.timestamp = attr.timestamp;\n                },\n                lookup (parent, name) {\n                    throw new FS.ErrnoError(44);\n                },\n                mknod (parent, name, mode, dev) {\n                    throw new FS.ErrnoError(63);\n                },\n                rename (oldNode, newDir, newName) {\n                    throw new FS.ErrnoError(63);\n                },\n                unlink (parent, name) {\n                    throw new FS.ErrnoError(63);\n                },\n                rmdir (parent, name) {\n                    throw new FS.ErrnoError(63);\n                },\n                readdir (node) {\n                    var entries = [\n                        \".\",\n                        \"..\"\n                    ];\n                    for (var key of Object.keys(node.contents))entries.push(key);\n                    return entries;\n                },\n                symlink (parent, newName, oldPath) {\n                    throw new FS.ErrnoError(63);\n                }\n            },\n            stream_ops: {\n                read (stream, buffer, offset, length, position) {\n                    if (position >= stream.node.size) return 0;\n                    var chunk = stream.node.contents.slice(position, position + length);\n                    var ab = WORKERFS.reader.readAsArrayBuffer(chunk);\n                    buffer.set(new Uint8Array(ab), offset);\n                    return chunk.size;\n                },\n                write (stream, buffer, offset, length, position) {\n                    throw new FS.ErrnoError(29);\n                },\n                llseek (stream, offset, whence) {\n                    var position = offset;\n                    if (whence === 1) position += stream.position;\n                    else if (whence === 2) {\n                        if (FS.isFile(stream.node.mode)) position += stream.node.size;\n                    }\n                    if (position < 0) throw new FS.ErrnoError(28);\n                    return position;\n                }\n            }\n        };\n        var FS = {\n            root: null,\n            mounts: [],\n            devices: {},\n            streams: [],\n            nextInode: 1,\n            nameTable: null,\n            currentPath: \"/\",\n            initialized: false,\n            ignorePermissions: true,\n            ErrnoError: class {\n                name = \"ErrnoError\";\n                constructor(errno){\n                    this.errno = errno;\n                }\n            },\n            filesystems: null,\n            syncFSRequests: 0,\n            readFiles: {},\n            FSStream: class {\n                shared = {};\n                get object() {\n                    return this.node;\n                }\n                set object(val) {\n                    this.node = val;\n                }\n                get isRead() {\n                    return (this.flags & 2097155) !== 1;\n                }\n                get isWrite() {\n                    return (this.flags & 2097155) !== 0;\n                }\n                get isAppend() {\n                    return this.flags & 1024;\n                }\n                get flags() {\n                    return this.shared.flags;\n                }\n                set flags(val) {\n                    this.shared.flags = val;\n                }\n                get position() {\n                    return this.shared.position;\n                }\n                set position(val) {\n                    this.shared.position = val;\n                }\n            },\n            FSNode: class {\n                node_ops = {};\n                stream_ops = {};\n                readMode = 365;\n                writeMode = 146;\n                mounted = null;\n                constructor(parent, name, mode, rdev){\n                    if (!parent) parent = this;\n                    this.parent = parent;\n                    this.mount = parent.mount;\n                    this.id = FS.nextInode++;\n                    this.name = name;\n                    this.mode = mode;\n                    this.rdev = rdev;\n                }\n                get read() {\n                    return (this.mode & this.readMode) === this.readMode;\n                }\n                set read(val) {\n                    val ? this.mode |= this.readMode : this.mode &= ~this.readMode;\n                }\n                get write() {\n                    return (this.mode & this.writeMode) === this.writeMode;\n                }\n                set write(val) {\n                    val ? this.mode |= this.writeMode : this.mode &= ~this.writeMode;\n                }\n                get isFolder() {\n                    return FS.isDir(this.mode);\n                }\n                get isDevice() {\n                    return FS.isChrdev(this.mode);\n                }\n            },\n            lookupPath (path, opts = {}) {\n                path = PATH_FS.resolve(path);\n                if (!path) return {\n                    path: \"\",\n                    node: null\n                };\n                var defaults = {\n                    follow_mount: true,\n                    recurse_count: 0\n                };\n                opts = Object.assign(defaults, opts);\n                if (opts.recurse_count > 8) throw new FS.ErrnoError(32);\n                var parts = path.split(\"/\").filter((p)=>!!p);\n                var current = FS.root;\n                var current_path = \"/\";\n                for(var i = 0; i < parts.length; i++){\n                    var islast = i === parts.length - 1;\n                    if (islast && opts.parent) break;\n                    current = FS.lookupNode(current, parts[i]);\n                    current_path = PATH.join2(current_path, parts[i]);\n                    if (FS.isMountpoint(current)) {\n                        if (!islast || islast && opts.follow_mount) current = current.mounted.root;\n                    }\n                    if (!islast || opts.follow) {\n                        var count = 0;\n                        while(FS.isLink(current.mode)){\n                            var link = FS.readlink(current_path);\n                            current_path = PATH_FS.resolve(PATH.dirname(current_path), link);\n                            var lookup = FS.lookupPath(current_path, {\n                                recurse_count: opts.recurse_count + 1\n                            });\n                            current = lookup.node;\n                            if (count++ > 40) throw new FS.ErrnoError(32);\n                        }\n                    }\n                }\n                return {\n                    path: current_path,\n                    node: current\n                };\n            },\n            getPath (node) {\n                var path;\n                while(true){\n                    if (FS.isRoot(node)) {\n                        var mount = node.mount.mountpoint;\n                        if (!path) return mount;\n                        return mount[mount.length - 1] !== \"/\" ? `${mount}/${path}` : mount + path;\n                    }\n                    path = path ? `${node.name}/${path}` : node.name;\n                    node = node.parent;\n                }\n            },\n            hashName (parentid, name) {\n                var hash = 0;\n                for(var i = 0; i < name.length; i++)hash = (hash << 5) - hash + name.charCodeAt(i) | 0;\n                return (parentid + hash >>> 0) % FS.nameTable.length;\n            },\n            hashAddNode (node) {\n                var hash = FS.hashName(node.parent.id, node.name);\n                node.name_next = FS.nameTable[hash];\n                FS.nameTable[hash] = node;\n            },\n            hashRemoveNode (node) {\n                var hash = FS.hashName(node.parent.id, node.name);\n                if (FS.nameTable[hash] === node) FS.nameTable[hash] = node.name_next;\n                else {\n                    var current = FS.nameTable[hash];\n                    while(current){\n                        if (current.name_next === node) {\n                            current.name_next = node.name_next;\n                            break;\n                        }\n                        current = current.name_next;\n                    }\n                }\n            },\n            lookupNode (parent, name) {\n                var errCode = FS.mayLookup(parent);\n                if (errCode) throw new FS.ErrnoError(errCode);\n                var hash = FS.hashName(parent.id, name);\n                for(var node = FS.nameTable[hash]; node; node = node.name_next){\n                    var nodeName = node.name;\n                    if (node.parent.id === parent.id && nodeName === name) return node;\n                }\n                return FS.lookup(parent, name);\n            },\n            createNode (parent, name, mode, rdev) {\n                var node = new FS.FSNode(parent, name, mode, rdev);\n                FS.hashAddNode(node);\n                return node;\n            },\n            destroyNode (node) {\n                FS.hashRemoveNode(node);\n            },\n            isRoot (node) {\n                return node === node.parent;\n            },\n            isMountpoint (node) {\n                return !!node.mounted;\n            },\n            isFile (mode) {\n                return (mode & 61440) === 32768;\n            },\n            isDir (mode) {\n                return (mode & 61440) === 16384;\n            },\n            isLink (mode) {\n                return (mode & 61440) === 40960;\n            },\n            isChrdev (mode) {\n                return (mode & 61440) === 8192;\n            },\n            isBlkdev (mode) {\n                return (mode & 61440) === 24576;\n            },\n            isFIFO (mode) {\n                return (mode & 61440) === 4096;\n            },\n            isSocket (mode) {\n                return (mode & 49152) === 49152;\n            },\n            flagsToPermissionString (flag) {\n                var perms = [\n                    \"r\",\n                    \"w\",\n                    \"rw\"\n                ][flag & 3];\n                if (flag & 512) perms += \"w\";\n                return perms;\n            },\n            nodePermissions (node, perms) {\n                if (FS.ignorePermissions) return 0;\n                if (perms.includes(\"r\") && !(node.mode & 292)) return 2;\n                else if (perms.includes(\"w\") && !(node.mode & 146)) return 2;\n                else if (perms.includes(\"x\") && !(node.mode & 73)) return 2;\n                return 0;\n            },\n            mayLookup (dir) {\n                if (!FS.isDir(dir.mode)) return 54;\n                var errCode = FS.nodePermissions(dir, \"x\");\n                if (errCode) return errCode;\n                if (!dir.node_ops.lookup) return 2;\n                return 0;\n            },\n            mayCreate (dir, name) {\n                try {\n                    var node = FS.lookupNode(dir, name);\n                    return 20;\n                } catch (e) {}\n                return FS.nodePermissions(dir, \"wx\");\n            },\n            mayDelete (dir, name, isdir) {\n                var node;\n                try {\n                    node = FS.lookupNode(dir, name);\n                } catch (e) {\n                    return e.errno;\n                }\n                var errCode = FS.nodePermissions(dir, \"wx\");\n                if (errCode) return errCode;\n                if (isdir) {\n                    if (!FS.isDir(node.mode)) return 54;\n                    if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) return 10;\n                } else {\n                    if (FS.isDir(node.mode)) return 31;\n                }\n                return 0;\n            },\n            mayOpen (node, flags) {\n                if (!node) return 44;\n                if (FS.isLink(node.mode)) return 32;\n                else if (FS.isDir(node.mode)) {\n                    if (FS.flagsToPermissionString(flags) !== \"r\" || flags & 512) return 31;\n                }\n                return FS.nodePermissions(node, FS.flagsToPermissionString(flags));\n            },\n            MAX_OPEN_FDS: 4096,\n            nextfd () {\n                for(var fd = 0; fd <= FS.MAX_OPEN_FDS; fd++){\n                    if (!FS.streams[fd]) return fd;\n                }\n                throw new FS.ErrnoError(33);\n            },\n            getStreamChecked (fd) {\n                var stream = FS.getStream(fd);\n                if (!stream) throw new FS.ErrnoError(8);\n                return stream;\n            },\n            getStream: (fd)=>FS.streams[fd],\n            createStream (stream, fd = -1) {\n                stream = Object.assign(new FS.FSStream, stream);\n                if (fd == -1) fd = FS.nextfd();\n                stream.fd = fd;\n                FS.streams[fd] = stream;\n                return stream;\n            },\n            closeStream (fd) {\n                FS.streams[fd] = null;\n            },\n            dupStream (origStream, fd = -1) {\n                var stream = FS.createStream(origStream, fd);\n                stream.stream_ops?.dup?.(stream);\n                return stream;\n            },\n            chrdev_stream_ops: {\n                open (stream) {\n                    var device = FS.getDevice(stream.node.rdev);\n                    stream.stream_ops = device.stream_ops;\n                    stream.stream_ops.open?.(stream);\n                },\n                llseek () {\n                    throw new FS.ErrnoError(70);\n                }\n            },\n            major: (dev)=>dev >> 8,\n            minor: (dev)=>dev & 255,\n            makedev: (ma, mi)=>ma << 8 | mi,\n            registerDevice (dev, ops) {\n                FS.devices[dev] = {\n                    stream_ops: ops\n                };\n            },\n            getDevice: (dev)=>FS.devices[dev],\n            getMounts (mount) {\n                var mounts = [];\n                var check = [\n                    mount\n                ];\n                while(check.length){\n                    var m = check.pop();\n                    mounts.push(m);\n                    check.push(...m.mounts);\n                }\n                return mounts;\n            },\n            syncfs (populate, callback) {\n                if (typeof populate == \"function\") {\n                    callback = populate;\n                    populate = false;\n                }\n                FS.syncFSRequests++;\n                if (FS.syncFSRequests > 1) err(`warning: ${FS.syncFSRequests} FS.syncfs operations in flight at once, probably just doing extra work`);\n                var mounts = FS.getMounts(FS.root.mount);\n                var completed = 0;\n                function doCallback(errCode) {\n                    FS.syncFSRequests--;\n                    return callback(errCode);\n                }\n                function done(errCode) {\n                    if (errCode) {\n                        if (!done.errored) {\n                            done.errored = true;\n                            return doCallback(errCode);\n                        }\n                        return;\n                    }\n                    if (++completed >= mounts.length) doCallback(null);\n                }\n                mounts.forEach((mount)=>{\n                    if (!mount.type.syncfs) return done(null);\n                    mount.type.syncfs(mount, populate, done);\n                });\n            },\n            mount (type, opts, mountpoint) {\n                var root = mountpoint === \"/\";\n                var pseudo = !mountpoint;\n                var node;\n                if (root && FS.root) throw new FS.ErrnoError(10);\n                else if (!root && !pseudo) {\n                    var lookup = FS.lookupPath(mountpoint, {\n                        follow_mount: false\n                    });\n                    mountpoint = lookup.path;\n                    node = lookup.node;\n                    if (FS.isMountpoint(node)) throw new FS.ErrnoError(10);\n                    if (!FS.isDir(node.mode)) throw new FS.ErrnoError(54);\n                }\n                var mount = {\n                    type: type,\n                    opts: opts,\n                    mountpoint: mountpoint,\n                    mounts: []\n                };\n                var mountRoot = type.mount(mount);\n                mountRoot.mount = mount;\n                mount.root = mountRoot;\n                if (root) FS.root = mountRoot;\n                else if (node) {\n                    node.mounted = mount;\n                    if (node.mount) node.mount.mounts.push(mount);\n                }\n                return mountRoot;\n            },\n            unmount (mountpoint) {\n                var lookup = FS.lookupPath(mountpoint, {\n                    follow_mount: false\n                });\n                if (!FS.isMountpoint(lookup.node)) throw new FS.ErrnoError(28);\n                var node = lookup.node;\n                var mount = node.mounted;\n                var mounts = FS.getMounts(mount);\n                Object.keys(FS.nameTable).forEach((hash)=>{\n                    var current = FS.nameTable[hash];\n                    while(current){\n                        var next = current.name_next;\n                        if (mounts.includes(current.mount)) FS.destroyNode(current);\n                        current = next;\n                    }\n                });\n                node.mounted = null;\n                var idx = node.mount.mounts.indexOf(mount);\n                node.mount.mounts.splice(idx, 1);\n            },\n            lookup (parent, name) {\n                return parent.node_ops.lookup(parent, name);\n            },\n            mknod (path, mode, dev) {\n                var lookup = FS.lookupPath(path, {\n                    parent: true\n                });\n                var parent = lookup.node;\n                var name = PATH.basename(path);\n                if (!name || name === \".\" || name === \"..\") throw new FS.ErrnoError(28);\n                var errCode = FS.mayCreate(parent, name);\n                if (errCode) throw new FS.ErrnoError(errCode);\n                if (!parent.node_ops.mknod) throw new FS.ErrnoError(63);\n                return parent.node_ops.mknod(parent, name, mode, dev);\n            },\n            create (path, mode) {\n                mode = mode !== undefined ? mode : 438;\n                mode &= 4095;\n                mode |= 32768;\n                return FS.mknod(path, mode, 0);\n            },\n            mkdir (path, mode) {\n                mode = mode !== undefined ? mode : 511;\n                mode &= 1023;\n                mode |= 16384;\n                return FS.mknod(path, mode, 0);\n            },\n            mkdirTree (path, mode) {\n                var dirs = path.split(\"/\");\n                var d = \"\";\n                for(var i = 0; i < dirs.length; ++i){\n                    if (!dirs[i]) continue;\n                    d += \"/\" + dirs[i];\n                    try {\n                        FS.mkdir(d, mode);\n                    } catch (e) {\n                        if (e.errno != 20) throw e;\n                    }\n                }\n            },\n            mkdev (path, mode, dev) {\n                if (typeof dev == \"undefined\") {\n                    dev = mode;\n                    mode = 438;\n                }\n                mode |= 8192;\n                return FS.mknod(path, mode, dev);\n            },\n            symlink (oldpath, newpath) {\n                if (!PATH_FS.resolve(oldpath)) throw new FS.ErrnoError(44);\n                var lookup = FS.lookupPath(newpath, {\n                    parent: true\n                });\n                var parent = lookup.node;\n                if (!parent) throw new FS.ErrnoError(44);\n                var newname = PATH.basename(newpath);\n                var errCode = FS.mayCreate(parent, newname);\n                if (errCode) throw new FS.ErrnoError(errCode);\n                if (!parent.node_ops.symlink) throw new FS.ErrnoError(63);\n                return parent.node_ops.symlink(parent, newname, oldpath);\n            },\n            rename (old_path, new_path) {\n                var old_dirname = PATH.dirname(old_path);\n                var new_dirname = PATH.dirname(new_path);\n                var old_name = PATH.basename(old_path);\n                var new_name = PATH.basename(new_path);\n                var lookup, old_dir, new_dir;\n                lookup = FS.lookupPath(old_path, {\n                    parent: true\n                });\n                old_dir = lookup.node;\n                lookup = FS.lookupPath(new_path, {\n                    parent: true\n                });\n                new_dir = lookup.node;\n                if (!old_dir || !new_dir) throw new FS.ErrnoError(44);\n                if (old_dir.mount !== new_dir.mount) throw new FS.ErrnoError(75);\n                var old_node = FS.lookupNode(old_dir, old_name);\n                var relative = PATH_FS.relative(old_path, new_dirname);\n                if (relative.charAt(0) !== \".\") throw new FS.ErrnoError(28);\n                relative = PATH_FS.relative(new_path, old_dirname);\n                if (relative.charAt(0) !== \".\") throw new FS.ErrnoError(55);\n                var new_node;\n                try {\n                    new_node = FS.lookupNode(new_dir, new_name);\n                } catch (e) {}\n                if (old_node === new_node) return;\n                var isdir = FS.isDir(old_node.mode);\n                var errCode = FS.mayDelete(old_dir, old_name, isdir);\n                if (errCode) throw new FS.ErrnoError(errCode);\n                errCode = new_node ? FS.mayDelete(new_dir, new_name, isdir) : FS.mayCreate(new_dir, new_name);\n                if (errCode) throw new FS.ErrnoError(errCode);\n                if (!old_dir.node_ops.rename) throw new FS.ErrnoError(63);\n                if (FS.isMountpoint(old_node) || new_node && FS.isMountpoint(new_node)) throw new FS.ErrnoError(10);\n                if (new_dir !== old_dir) {\n                    errCode = FS.nodePermissions(old_dir, \"w\");\n                    if (errCode) throw new FS.ErrnoError(errCode);\n                }\n                FS.hashRemoveNode(old_node);\n                try {\n                    old_dir.node_ops.rename(old_node, new_dir, new_name);\n                    old_node.parent = new_dir;\n                } catch (e) {\n                    throw e;\n                } finally{\n                    FS.hashAddNode(old_node);\n                }\n            },\n            rmdir (path) {\n                var lookup = FS.lookupPath(path, {\n                    parent: true\n                });\n                var parent = lookup.node;\n                var name = PATH.basename(path);\n                var node = FS.lookupNode(parent, name);\n                var errCode = FS.mayDelete(parent, name, true);\n                if (errCode) throw new FS.ErrnoError(errCode);\n                if (!parent.node_ops.rmdir) throw new FS.ErrnoError(63);\n                if (FS.isMountpoint(node)) throw new FS.ErrnoError(10);\n                parent.node_ops.rmdir(parent, name);\n                FS.destroyNode(node);\n            },\n            readdir (path) {\n                var lookup = FS.lookupPath(path, {\n                    follow: true\n                });\n                var node = lookup.node;\n                if (!node.node_ops.readdir) throw new FS.ErrnoError(54);\n                return node.node_ops.readdir(node);\n            },\n            unlink (path) {\n                var lookup = FS.lookupPath(path, {\n                    parent: true\n                });\n                var parent = lookup.node;\n                if (!parent) throw new FS.ErrnoError(44);\n                var name = PATH.basename(path);\n                var node = FS.lookupNode(parent, name);\n                var errCode = FS.mayDelete(parent, name, false);\n                if (errCode) throw new FS.ErrnoError(errCode);\n                if (!parent.node_ops.unlink) throw new FS.ErrnoError(63);\n                if (FS.isMountpoint(node)) throw new FS.ErrnoError(10);\n                parent.node_ops.unlink(parent, name);\n                FS.destroyNode(node);\n            },\n            readlink (path) {\n                var lookup = FS.lookupPath(path);\n                var link = lookup.node;\n                if (!link) throw new FS.ErrnoError(44);\n                if (!link.node_ops.readlink) throw new FS.ErrnoError(28);\n                return PATH_FS.resolve(FS.getPath(link.parent), link.node_ops.readlink(link));\n            },\n            stat (path, dontFollow) {\n                var lookup = FS.lookupPath(path, {\n                    follow: !dontFollow\n                });\n                var node = lookup.node;\n                if (!node) throw new FS.ErrnoError(44);\n                if (!node.node_ops.getattr) throw new FS.ErrnoError(63);\n                return node.node_ops.getattr(node);\n            },\n            lstat (path) {\n                return FS.stat(path, true);\n            },\n            chmod (path, mode, dontFollow) {\n                var node;\n                if (typeof path == \"string\") {\n                    var lookup = FS.lookupPath(path, {\n                        follow: !dontFollow\n                    });\n                    node = lookup.node;\n                } else node = path;\n                if (!node.node_ops.setattr) throw new FS.ErrnoError(63);\n                node.node_ops.setattr(node, {\n                    mode: mode & 4095 | node.mode & -4096,\n                    timestamp: Date.now()\n                });\n            },\n            lchmod (path, mode) {\n                FS.chmod(path, mode, true);\n            },\n            fchmod (fd, mode) {\n                var stream = FS.getStreamChecked(fd);\n                FS.chmod(stream.node, mode);\n            },\n            chown (path, uid, gid, dontFollow) {\n                var node;\n                if (typeof path == \"string\") {\n                    var lookup = FS.lookupPath(path, {\n                        follow: !dontFollow\n                    });\n                    node = lookup.node;\n                } else node = path;\n                if (!node.node_ops.setattr) throw new FS.ErrnoError(63);\n                node.node_ops.setattr(node, {\n                    timestamp: Date.now()\n                });\n            },\n            lchown (path, uid, gid) {\n                FS.chown(path, uid, gid, true);\n            },\n            fchown (fd, uid, gid) {\n                var stream = FS.getStreamChecked(fd);\n                FS.chown(stream.node, uid, gid);\n            },\n            truncate (path, len) {\n                if (len < 0) throw new FS.ErrnoError(28);\n                var node;\n                if (typeof path == \"string\") {\n                    var lookup = FS.lookupPath(path, {\n                        follow: true\n                    });\n                    node = lookup.node;\n                } else node = path;\n                if (!node.node_ops.setattr) throw new FS.ErrnoError(63);\n                if (FS.isDir(node.mode)) throw new FS.ErrnoError(31);\n                if (!FS.isFile(node.mode)) throw new FS.ErrnoError(28);\n                var errCode = FS.nodePermissions(node, \"w\");\n                if (errCode) throw new FS.ErrnoError(errCode);\n                node.node_ops.setattr(node, {\n                    size: len,\n                    timestamp: Date.now()\n                });\n            },\n            ftruncate (fd, len) {\n                var stream = FS.getStreamChecked(fd);\n                if ((stream.flags & 2097155) === 0) throw new FS.ErrnoError(28);\n                FS.truncate(stream.node, len);\n            },\n            utime (path, atime, mtime) {\n                var lookup = FS.lookupPath(path, {\n                    follow: true\n                });\n                var node = lookup.node;\n                node.node_ops.setattr(node, {\n                    timestamp: Math.max(atime, mtime)\n                });\n            },\n            open (path, flags, mode) {\n                if (path === \"\") throw new FS.ErrnoError(44);\n                flags = typeof flags == \"string\" ? FS_modeStringToFlags(flags) : flags;\n                if (flags & 64) {\n                    mode = typeof mode == \"undefined\" ? 438 : mode;\n                    mode = mode & 4095 | 32768;\n                } else mode = 0;\n                var node;\n                if (typeof path == \"object\") node = path;\n                else {\n                    path = PATH.normalize(path);\n                    try {\n                        var lookup = FS.lookupPath(path, {\n                            follow: !(flags & 131072)\n                        });\n                        node = lookup.node;\n                    } catch (e) {}\n                }\n                var created = false;\n                if (flags & 64) {\n                    if (node) {\n                        if (flags & 128) throw new FS.ErrnoError(20);\n                    } else {\n                        node = FS.mknod(path, mode, 0);\n                        created = true;\n                    }\n                }\n                if (!node) throw new FS.ErrnoError(44);\n                if (FS.isChrdev(node.mode)) flags &= -513;\n                if (flags & 65536 && !FS.isDir(node.mode)) throw new FS.ErrnoError(54);\n                if (!created) {\n                    var errCode = FS.mayOpen(node, flags);\n                    if (errCode) throw new FS.ErrnoError(errCode);\n                }\n                if (flags & 512 && !created) FS.truncate(node, 0);\n                flags &= -131713;\n                var stream = FS.createStream({\n                    node: node,\n                    path: FS.getPath(node),\n                    flags: flags,\n                    seekable: true,\n                    position: 0,\n                    stream_ops: node.stream_ops,\n                    ungotten: [],\n                    error: false\n                });\n                if (stream.stream_ops.open) stream.stream_ops.open(stream);\n                if (Module[\"logReadFiles\"] && !(flags & 1)) {\n                    if (!(path in FS.readFiles)) FS.readFiles[path] = 1;\n                }\n                return stream;\n            },\n            close (stream) {\n                if (FS.isClosed(stream)) throw new FS.ErrnoError(8);\n                if (stream.getdents) stream.getdents = null;\n                try {\n                    if (stream.stream_ops.close) stream.stream_ops.close(stream);\n                } catch (e) {\n                    throw e;\n                } finally{\n                    FS.closeStream(stream.fd);\n                }\n                stream.fd = null;\n            },\n            isClosed (stream) {\n                return stream.fd === null;\n            },\n            llseek (stream, offset, whence) {\n                if (FS.isClosed(stream)) throw new FS.ErrnoError(8);\n                if (!stream.seekable || !stream.stream_ops.llseek) throw new FS.ErrnoError(70);\n                if (whence != 0 && whence != 1 && whence != 2) throw new FS.ErrnoError(28);\n                stream.position = stream.stream_ops.llseek(stream, offset, whence);\n                stream.ungotten = [];\n                return stream.position;\n            },\n            read (stream, buffer, offset, length, position) {\n                if (length < 0 || position < 0) throw new FS.ErrnoError(28);\n                if (FS.isClosed(stream)) throw new FS.ErrnoError(8);\n                if ((stream.flags & 2097155) === 1) throw new FS.ErrnoError(8);\n                if (FS.isDir(stream.node.mode)) throw new FS.ErrnoError(31);\n                if (!stream.stream_ops.read) throw new FS.ErrnoError(28);\n                var seeking = typeof position != \"undefined\";\n                if (!seeking) position = stream.position;\n                else if (!stream.seekable) throw new FS.ErrnoError(70);\n                var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position);\n                if (!seeking) stream.position += bytesRead;\n                return bytesRead;\n            },\n            write (stream, buffer, offset, length, position, canOwn) {\n                if (length < 0 || position < 0) throw new FS.ErrnoError(28);\n                if (FS.isClosed(stream)) throw new FS.ErrnoError(8);\n                if ((stream.flags & 2097155) === 0) throw new FS.ErrnoError(8);\n                if (FS.isDir(stream.node.mode)) throw new FS.ErrnoError(31);\n                if (!stream.stream_ops.write) throw new FS.ErrnoError(28);\n                if (stream.seekable && stream.flags & 1024) FS.llseek(stream, 0, 2);\n                var seeking = typeof position != \"undefined\";\n                if (!seeking) position = stream.position;\n                else if (!stream.seekable) throw new FS.ErrnoError(70);\n                var bytesWritten = stream.stream_ops.write(stream, buffer, offset, length, position, canOwn);\n                if (!seeking) stream.position += bytesWritten;\n                return bytesWritten;\n            },\n            allocate (stream, offset, length) {\n                if (FS.isClosed(stream)) throw new FS.ErrnoError(8);\n                if (offset < 0 || length <= 0) throw new FS.ErrnoError(28);\n                if ((stream.flags & 2097155) === 0) throw new FS.ErrnoError(8);\n                if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) throw new FS.ErrnoError(43);\n                if (!stream.stream_ops.allocate) throw new FS.ErrnoError(138);\n                stream.stream_ops.allocate(stream, offset, length);\n            },\n            mmap (stream, length, position, prot, flags) {\n                if ((prot & 2) !== 0 && (flags & 2) === 0 && (stream.flags & 2097155) !== 2) throw new FS.ErrnoError(2);\n                if ((stream.flags & 2097155) === 1) throw new FS.ErrnoError(2);\n                if (!stream.stream_ops.mmap) throw new FS.ErrnoError(43);\n                if (!length) throw new FS.ErrnoError(28);\n                return stream.stream_ops.mmap(stream, length, position, prot, flags);\n            },\n            msync (stream, buffer, offset, length, mmapFlags) {\n                if (!stream.stream_ops.msync) return 0;\n                return stream.stream_ops.msync(stream, buffer, offset, length, mmapFlags);\n            },\n            ioctl (stream, cmd, arg) {\n                if (!stream.stream_ops.ioctl) throw new FS.ErrnoError(59);\n                return stream.stream_ops.ioctl(stream, cmd, arg);\n            },\n            readFile (path, opts = {}) {\n                opts.flags = opts.flags || 0;\n                opts.encoding = opts.encoding || \"binary\";\n                if (opts.encoding !== \"utf8\" && opts.encoding !== \"binary\") throw new Error(`Invalid encoding type \"${opts.encoding}\"`);\n                var ret;\n                var stream = FS.open(path, opts.flags);\n                var stat = FS.stat(path);\n                var length = stat.size;\n                var buf = new Uint8Array(length);\n                FS.read(stream, buf, 0, length, 0);\n                if (opts.encoding === \"utf8\") ret = UTF8ArrayToString(buf);\n                else if (opts.encoding === \"binary\") ret = buf;\n                FS.close(stream);\n                return ret;\n            },\n            writeFile (path, data, opts = {}) {\n                opts.flags = opts.flags || 577;\n                var stream = FS.open(path, opts.flags, opts.mode);\n                if (typeof data == \"string\") {\n                    var buf = new Uint8Array(lengthBytesUTF8(data) + 1);\n                    var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);\n                    FS.write(stream, buf, 0, actualNumBytes, undefined, opts.canOwn);\n                } else if (ArrayBuffer.isView(data)) FS.write(stream, data, 0, data.byteLength, undefined, opts.canOwn);\n                else throw new Error(\"Unsupported data type\");\n                FS.close(stream);\n            },\n            cwd: ()=>FS.currentPath,\n            chdir (path) {\n                var lookup = FS.lookupPath(path, {\n                    follow: true\n                });\n                if (lookup.node === null) throw new FS.ErrnoError(44);\n                if (!FS.isDir(lookup.node.mode)) throw new FS.ErrnoError(54);\n                var errCode = FS.nodePermissions(lookup.node, \"x\");\n                if (errCode) throw new FS.ErrnoError(errCode);\n                FS.currentPath = lookup.path;\n            },\n            createDefaultDirectories () {\n                FS.mkdir(\"/tmp\");\n                FS.mkdir(\"/home\");\n                FS.mkdir(\"/home/web_user\");\n            },\n            createDefaultDevices () {\n                FS.mkdir(\"/dev\");\n                FS.registerDevice(FS.makedev(1, 3), {\n                    read: ()=>0,\n                    write: (stream, buffer, offset, length, pos)=>length,\n                    llseek: ()=>0\n                });\n                FS.mkdev(\"/dev/null\", FS.makedev(1, 3));\n                TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);\n                TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);\n                FS.mkdev(\"/dev/tty\", FS.makedev(5, 0));\n                FS.mkdev(\"/dev/tty1\", FS.makedev(6, 0));\n                var randomBuffer = new Uint8Array(1024), randomLeft = 0;\n                var randomByte = ()=>{\n                    if (randomLeft === 0) randomLeft = randomFill(randomBuffer).byteLength;\n                    return randomBuffer[--randomLeft];\n                };\n                FS.createDevice(\"/dev\", \"random\", randomByte);\n                FS.createDevice(\"/dev\", \"urandom\", randomByte);\n                FS.mkdir(\"/dev/shm\");\n                FS.mkdir(\"/dev/shm/tmp\");\n            },\n            createSpecialDirectories () {\n                FS.mkdir(\"/proc\");\n                var proc_self = FS.mkdir(\"/proc/self\");\n                FS.mkdir(\"/proc/self/fd\");\n                FS.mount({\n                    mount () {\n                        var node = FS.createNode(proc_self, \"fd\", 16895, 73);\n                        node.node_ops = {\n                            lookup (parent, name) {\n                                var fd = +name;\n                                var stream = FS.getStreamChecked(fd);\n                                var ret = {\n                                    parent: null,\n                                    mount: {\n                                        mountpoint: \"fake\"\n                                    },\n                                    node_ops: {\n                                        readlink: ()=>stream.path\n                                    }\n                                };\n                                ret.parent = ret;\n                                return ret;\n                            }\n                        };\n                        return node;\n                    }\n                }, {}, \"/proc/self/fd\");\n            },\n            createStandardStreams (input, output, error) {\n                if (input) FS.createDevice(\"/dev\", \"stdin\", input);\n                else FS.symlink(\"/dev/tty\", \"/dev/stdin\");\n                if (output) FS.createDevice(\"/dev\", \"stdout\", null, output);\n                else FS.symlink(\"/dev/tty\", \"/dev/stdout\");\n                if (error) FS.createDevice(\"/dev\", \"stderr\", null, error);\n                else FS.symlink(\"/dev/tty1\", \"/dev/stderr\");\n                var stdin = FS.open(\"/dev/stdin\", 0);\n                var stdout = FS.open(\"/dev/stdout\", 1);\n                var stderr = FS.open(\"/dev/stderr\", 1);\n            },\n            staticInit () {\n                FS.nameTable = new Array(4096);\n                FS.mount(MEMFS, {}, \"/\");\n                FS.createDefaultDirectories();\n                FS.createDefaultDevices();\n                FS.createSpecialDirectories();\n                FS.filesystems = {\n                    MEMFS: MEMFS,\n                    WORKERFS: WORKERFS\n                };\n            },\n            init (input, output, error) {\n                FS.initialized = true;\n                input ??= Module[\"stdin\"];\n                output ??= Module[\"stdout\"];\n                error ??= Module[\"stderr\"];\n                FS.createStandardStreams(input, output, error);\n            },\n            quit () {\n                FS.initialized = false;\n                for(var i = 0; i < FS.streams.length; i++){\n                    var stream = FS.streams[i];\n                    if (!stream) continue;\n                    FS.close(stream);\n                }\n            },\n            findObject (path, dontResolveLastLink) {\n                var ret = FS.analyzePath(path, dontResolveLastLink);\n                if (!ret.exists) return null;\n                return ret.object;\n            },\n            analyzePath (path, dontResolveLastLink) {\n                try {\n                    var lookup = FS.lookupPath(path, {\n                        follow: !dontResolveLastLink\n                    });\n                    path = lookup.path;\n                } catch (e) {}\n                var ret = {\n                    isRoot: false,\n                    exists: false,\n                    error: 0,\n                    name: null,\n                    path: null,\n                    object: null,\n                    parentExists: false,\n                    parentPath: null,\n                    parentObject: null\n                };\n                try {\n                    var lookup = FS.lookupPath(path, {\n                        parent: true\n                    });\n                    ret.parentExists = true;\n                    ret.parentPath = lookup.path;\n                    ret.parentObject = lookup.node;\n                    ret.name = PATH.basename(path);\n                    lookup = FS.lookupPath(path, {\n                        follow: !dontResolveLastLink\n                    });\n                    ret.exists = true;\n                    ret.path = lookup.path;\n                    ret.object = lookup.node;\n                    ret.name = lookup.node.name;\n                    ret.isRoot = lookup.path === \"/\";\n                } catch (e) {\n                    ret.error = e.errno;\n                }\n                return ret;\n            },\n            createPath (parent, path, canRead, canWrite) {\n                parent = typeof parent == \"string\" ? parent : FS.getPath(parent);\n                var parts = path.split(\"/\").reverse();\n                while(parts.length){\n                    var part = parts.pop();\n                    if (!part) continue;\n                    var current = PATH.join2(parent, part);\n                    try {\n                        FS.mkdir(current);\n                    } catch (e) {}\n                    parent = current;\n                }\n                return current;\n            },\n            createFile (parent, name, properties, canRead, canWrite) {\n                var path = PATH.join2(typeof parent == \"string\" ? parent : FS.getPath(parent), name);\n                var mode = FS_getMode(canRead, canWrite);\n                return FS.create(path, mode);\n            },\n            createDataFile (parent, name, data, canRead, canWrite, canOwn) {\n                var path = name;\n                if (parent) {\n                    parent = typeof parent == \"string\" ? parent : FS.getPath(parent);\n                    path = name ? PATH.join2(parent, name) : parent;\n                }\n                var mode = FS_getMode(canRead, canWrite);\n                var node = FS.create(path, mode);\n                if (data) {\n                    if (typeof data == \"string\") {\n                        var arr = new Array(data.length);\n                        for(var i = 0, len = data.length; i < len; ++i)arr[i] = data.charCodeAt(i);\n                        data = arr;\n                    }\n                    FS.chmod(node, mode | 146);\n                    var stream = FS.open(node, 577);\n                    FS.write(stream, data, 0, data.length, 0, canOwn);\n                    FS.close(stream);\n                    FS.chmod(node, mode);\n                }\n            },\n            createDevice (parent, name, input, output) {\n                var path = PATH.join2(typeof parent == \"string\" ? parent : FS.getPath(parent), name);\n                var mode = FS_getMode(!!input, !!output);\n                FS.createDevice.major ??= 64;\n                var dev = FS.makedev(FS.createDevice.major++, 0);\n                FS.registerDevice(dev, {\n                    open (stream) {\n                        stream.seekable = false;\n                    },\n                    close (stream) {\n                        if (output?.buffer?.length) output(10);\n                    },\n                    read (stream, buffer, offset, length, pos) {\n                        var bytesRead = 0;\n                        for(var i = 0; i < length; i++){\n                            var result;\n                            try {\n                                result = input();\n                            } catch (e) {\n                                throw new FS.ErrnoError(29);\n                            }\n                            if (result === undefined && bytesRead === 0) throw new FS.ErrnoError(6);\n                            if (result === null || result === undefined) break;\n                            bytesRead++;\n                            buffer[offset + i] = result;\n                        }\n                        if (bytesRead) stream.node.timestamp = Date.now();\n                        return bytesRead;\n                    },\n                    write (stream, buffer, offset, length, pos) {\n                        for(var i = 0; i < length; i++)try {\n                            output(buffer[offset + i]);\n                        } catch (e) {\n                            throw new FS.ErrnoError(29);\n                        }\n                        if (length) stream.node.timestamp = Date.now();\n                        return i;\n                    }\n                });\n                return FS.mkdev(path, mode, dev);\n            },\n            forceLoadFile (obj) {\n                if (obj.isDevice || obj.isFolder || obj.link || obj.contents) return true;\n                if (typeof XMLHttpRequest != \"undefined\") throw new Error(\"Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.\");\n                else try {\n                    obj.contents = readBinary(obj.url);\n                    obj.usedBytes = obj.contents.length;\n                } catch (e) {\n                    throw new FS.ErrnoError(29);\n                }\n            },\n            createLazyFile (parent, name, url, canRead, canWrite) {\n                class LazyUint8Array {\n                    lengthKnown = false;\n                    chunks = [];\n                    get(idx) {\n                        if (idx > this.length - 1 || idx < 0) return undefined;\n                        var chunkOffset = idx % this.chunkSize;\n                        var chunkNum = idx / this.chunkSize | 0;\n                        return this.getter(chunkNum)[chunkOffset];\n                    }\n                    setDataGetter(getter) {\n                        this.getter = getter;\n                    }\n                    cacheLength() {\n                        var xhr = new XMLHttpRequest;\n                        xhr.open(\"HEAD\", url, false);\n                        xhr.send(null);\n                        if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error(\"Couldn't load \" + url + \". Status: \" + xhr.status);\n                        var datalength = Number(xhr.getResponseHeader(\"Content-length\"));\n                        var header;\n                        var hasByteServing = (header = xhr.getResponseHeader(\"Accept-Ranges\")) && header === \"bytes\";\n                        var usesGzip = (header = xhr.getResponseHeader(\"Content-Encoding\")) && header === \"gzip\";\n                        var chunkSize = 1048576;\n                        if (!hasByteServing) chunkSize = datalength;\n                        var doXHR = (from, to)=>{\n                            if (from > to) throw new Error(\"invalid range (\" + from + \", \" + to + \") or no bytes requested!\");\n                            if (to > datalength - 1) throw new Error(\"only \" + datalength + \" bytes available! programmer error!\");\n                            var xhr = new XMLHttpRequest;\n                            xhr.open(\"GET\", url, false);\n                            if (datalength !== chunkSize) xhr.setRequestHeader(\"Range\", \"bytes=\" + from + \"-\" + to);\n                            xhr.responseType = \"arraybuffer\";\n                            if (xhr.overrideMimeType) xhr.overrideMimeType(\"text/plain; charset=x-user-defined\");\n                            xhr.send(null);\n                            if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error(\"Couldn't load \" + url + \". Status: \" + xhr.status);\n                            if (xhr.response !== undefined) return new Uint8Array(xhr.response || []);\n                            return intArrayFromString(xhr.responseText || \"\", true);\n                        };\n                        var lazyArray = this;\n                        lazyArray.setDataGetter((chunkNum)=>{\n                            var start = chunkNum * chunkSize;\n                            var end = (chunkNum + 1) * chunkSize - 1;\n                            end = Math.min(end, datalength - 1);\n                            if (typeof lazyArray.chunks[chunkNum] == \"undefined\") lazyArray.chunks[chunkNum] = doXHR(start, end);\n                            if (typeof lazyArray.chunks[chunkNum] == \"undefined\") throw new Error(\"doXHR failed!\");\n                            return lazyArray.chunks[chunkNum];\n                        });\n                        if (usesGzip || !datalength) {\n                            chunkSize = datalength = 1;\n                            datalength = this.getter(0).length;\n                            chunkSize = datalength;\n                            out(\"LazyFiles on gzip forces download of the whole file when length is accessed\");\n                        }\n                        this._length = datalength;\n                        this._chunkSize = chunkSize;\n                        this.lengthKnown = true;\n                    }\n                    get length() {\n                        if (!this.lengthKnown) this.cacheLength();\n                        return this._length;\n                    }\n                    get chunkSize() {\n                        if (!this.lengthKnown) this.cacheLength();\n                        return this._chunkSize;\n                    }\n                }\n                if (typeof XMLHttpRequest != \"undefined\") {\n                    if (!ENVIRONMENT_IS_WORKER) throw \"Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc\";\n                    var lazyArray = new LazyUint8Array;\n                    var properties = {\n                        isDevice: false,\n                        contents: lazyArray\n                    };\n                } else var properties = {\n                    isDevice: false,\n                    url: url\n                };\n                var node = FS.createFile(parent, name, properties, canRead, canWrite);\n                if (properties.contents) node.contents = properties.contents;\n                else if (properties.url) {\n                    node.contents = null;\n                    node.url = properties.url;\n                }\n                Object.defineProperties(node, {\n                    usedBytes: {\n                        get: function() {\n                            return this.contents.length;\n                        }\n                    }\n                });\n                var stream_ops = {};\n                var keys = Object.keys(node.stream_ops);\n                keys.forEach((key)=>{\n                    var fn = node.stream_ops[key];\n                    stream_ops[key] = (...args)=>{\n                        FS.forceLoadFile(node);\n                        return fn(...args);\n                    };\n                });\n                function writeChunks(stream, buffer, offset, length, position) {\n                    var contents = stream.node.contents;\n                    if (position >= contents.length) return 0;\n                    var size = Math.min(contents.length - position, length);\n                    if (contents.slice) for(var i = 0; i < size; i++)buffer[offset + i] = contents[position + i];\n                    else for(var i = 0; i < size; i++)buffer[offset + i] = contents.get(position + i);\n                    return size;\n                }\n                stream_ops.read = (stream, buffer, offset, length, position)=>{\n                    FS.forceLoadFile(node);\n                    return writeChunks(stream, buffer, offset, length, position);\n                };\n                stream_ops.mmap = (stream, length, position, prot, flags)=>{\n                    FS.forceLoadFile(node);\n                    var ptr = mmapAlloc(length);\n                    if (!ptr) throw new FS.ErrnoError(48);\n                    writeChunks(stream, GROWABLE_HEAP_I8(), ptr, length, position);\n                    return {\n                        ptr: ptr,\n                        allocated: true\n                    };\n                };\n                node.stream_ops = stream_ops;\n                return node;\n            }\n        };\n        var UTF8ToString = (ptr, maxBytesToRead)=>{\n            ptr >>>= 0;\n            return ptr ? UTF8ArrayToString(GROWABLE_HEAP_U8(), ptr, maxBytesToRead) : \"\";\n        };\n        var SYSCALLS = {\n            DEFAULT_POLLMASK: 5,\n            calculateAt (dirfd, path, allowEmpty) {\n                if (PATH.isAbs(path)) return path;\n                var dir;\n                if (dirfd === -100) dir = FS.cwd();\n                else {\n                    var dirstream = SYSCALLS.getStreamFromFD(dirfd);\n                    dir = dirstream.path;\n                }\n                if (path.length == 0) {\n                    if (!allowEmpty) throw new FS.ErrnoError(44);\n                    return dir;\n                }\n                return PATH.join2(dir, path);\n            },\n            doStat (func, path, buf) {\n                var stat = func(path);\n                GROWABLE_HEAP_I32()[buf >>> 2 >>> 0] = stat.dev;\n                GROWABLE_HEAP_I32()[buf + 4 >>> 2 >>> 0] = stat.mode;\n                GROWABLE_HEAP_U32()[buf + 8 >>> 2 >>> 0] = stat.nlink;\n                GROWABLE_HEAP_I32()[buf + 12 >>> 2 >>> 0] = stat.uid;\n                GROWABLE_HEAP_I32()[buf + 16 >>> 2 >>> 0] = stat.gid;\n                GROWABLE_HEAP_I32()[buf + 20 >>> 2 >>> 0] = stat.rdev;\n                tempI64 = [\n                    stat.size >>> 0,\n                    (tempDouble = stat.size, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)\n                ], GROWABLE_HEAP_I32()[buf + 24 >>> 2 >>> 0] = tempI64[0], GROWABLE_HEAP_I32()[buf + 28 >>> 2 >>> 0] = tempI64[1];\n                GROWABLE_HEAP_I32()[buf + 32 >>> 2 >>> 0] = 4096;\n                GROWABLE_HEAP_I32()[buf + 36 >>> 2 >>> 0] = stat.blocks;\n                var atime = stat.atime.getTime();\n                var mtime = stat.mtime.getTime();\n                var ctime = stat.ctime.getTime();\n                tempI64 = [\n                    Math.floor(atime / 1e3) >>> 0,\n                    (tempDouble = Math.floor(atime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)\n                ], GROWABLE_HEAP_I32()[buf + 40 >>> 2 >>> 0] = tempI64[0], GROWABLE_HEAP_I32()[buf + 44 >>> 2 >>> 0] = tempI64[1];\n                GROWABLE_HEAP_U32()[buf + 48 >>> 2 >>> 0] = atime % 1e3 * 1000000;\n                tempI64 = [\n                    Math.floor(mtime / 1e3) >>> 0,\n                    (tempDouble = Math.floor(mtime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)\n                ], GROWABLE_HEAP_I32()[buf + 56 >>> 2 >>> 0] = tempI64[0], GROWABLE_HEAP_I32()[buf + 60 >>> 2 >>> 0] = tempI64[1];\n                GROWABLE_HEAP_U32()[buf + 64 >>> 2 >>> 0] = mtime % 1e3 * 1000000;\n                tempI64 = [\n                    Math.floor(ctime / 1e3) >>> 0,\n                    (tempDouble = Math.floor(ctime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)\n                ], GROWABLE_HEAP_I32()[buf + 72 >>> 2 >>> 0] = tempI64[0], GROWABLE_HEAP_I32()[buf + 76 >>> 2 >>> 0] = tempI64[1];\n                GROWABLE_HEAP_U32()[buf + 80 >>> 2 >>> 0] = ctime % 1e3 * 1000000;\n                tempI64 = [\n                    stat.ino >>> 0,\n                    (tempDouble = stat.ino, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)\n                ], GROWABLE_HEAP_I32()[buf + 88 >>> 2 >>> 0] = tempI64[0], GROWABLE_HEAP_I32()[buf + 92 >>> 2 >>> 0] = tempI64[1];\n                return 0;\n            },\n            doMsync (addr, stream, len, flags, offset) {\n                if (!FS.isFile(stream.node.mode)) throw new FS.ErrnoError(43);\n                if (flags & 2) return 0;\n                var buffer = GROWABLE_HEAP_U8().slice(addr, addr + len);\n                FS.msync(stream, buffer, offset, len, flags);\n            },\n            getStreamFromFD (fd) {\n                var stream = FS.getStreamChecked(fd);\n                return stream;\n            },\n            varargs: undefined,\n            getStr (ptr) {\n                var ret = UTF8ToString(ptr);\n                return ret;\n            }\n        };\n        function ___syscall_fcntl64(fd, cmd, varargs) {\n            if (ENVIRONMENT_IS_PTHREAD) return proxyToMainThread(3, 0, 1, fd, cmd, varargs);\n            varargs >>>= 0;\n            SYSCALLS.varargs = varargs;\n            try {\n                var stream = SYSCALLS.getStreamFromFD(fd);\n                switch(cmd){\n                    case 0:\n                        var arg = syscallGetVarargI();\n                        if (arg < 0) return -28;\n                        while(FS.streams[arg])arg++;\n                        var newStream;\n                        newStream = FS.dupStream(stream, arg);\n                        return newStream.fd;\n                    case 1:\n                    case 2:\n                        return 0;\n                    case 3:\n                        return stream.flags;\n                    case 4:\n                        var arg = syscallGetVarargI();\n                        stream.flags |= arg;\n                        return 0;\n                    case 12:\n                        var arg = syscallGetVarargP();\n                        var offset = 0;\n                        GROWABLE_HEAP_I16()[arg + offset >>> 1 >>> 0] = 2;\n                        return 0;\n                    case 13:\n                    case 14:\n                        return 0;\n                }\n                return -28;\n            } catch (e) {\n                if (typeof FS == \"undefined\" || !(e.name === \"ErrnoError\")) throw e;\n                return -e.errno;\n            }\n        }\n        function ___syscall_ioctl(fd, op, varargs) {\n            if (ENVIRONMENT_IS_PTHREAD) return proxyToMainThread(4, 0, 1, fd, op, varargs);\n            varargs >>>= 0;\n            SYSCALLS.varargs = varargs;\n            try {\n                var stream = SYSCALLS.getStreamFromFD(fd);\n                switch(op){\n                    case 21509:\n                        if (!stream.tty) return -59;\n                        return 0;\n                    case 21505:\n                        if (!stream.tty) return -59;\n                        if (stream.tty.ops.ioctl_tcgets) {\n                            var termios = stream.tty.ops.ioctl_tcgets(stream);\n                            var argp = syscallGetVarargP();\n                            GROWABLE_HEAP_I32()[argp >>> 2 >>> 0] = termios.c_iflag || 0;\n                            GROWABLE_HEAP_I32()[argp + 4 >>> 2 >>> 0] = termios.c_oflag || 0;\n                            GROWABLE_HEAP_I32()[argp + 8 >>> 2 >>> 0] = termios.c_cflag || 0;\n                            GROWABLE_HEAP_I32()[argp + 12 >>> 2 >>> 0] = termios.c_lflag || 0;\n                            for(var i = 0; i < 32; i++)GROWABLE_HEAP_I8()[argp + i + 17 >>> 0] = termios.c_cc[i] || 0;\n                            return 0;\n                        }\n                        return 0;\n                    case 21510:\n                    case 21511:\n                    case 21512:\n                        if (!stream.tty) return -59;\n                        return 0;\n                    case 21506:\n                    case 21507:\n                    case 21508:\n                        if (!stream.tty) return -59;\n                        if (stream.tty.ops.ioctl_tcsets) {\n                            var argp = syscallGetVarargP();\n                            var c_iflag = GROWABLE_HEAP_I32()[argp >>> 2 >>> 0];\n                            var c_oflag = GROWABLE_HEAP_I32()[argp + 4 >>> 2 >>> 0];\n                            var c_cflag = GROWABLE_HEAP_I32()[argp + 8 >>> 2 >>> 0];\n                            var c_lflag = GROWABLE_HEAP_I32()[argp + 12 >>> 2 >>> 0];\n                            var c_cc = [];\n                            for(var i = 0; i < 32; i++)c_cc.push(GROWABLE_HEAP_I8()[argp + i + 17 >>> 0]);\n                            return stream.tty.ops.ioctl_tcsets(stream.tty, op, {\n                                c_iflag: c_iflag,\n                                c_oflag: c_oflag,\n                                c_cflag: c_cflag,\n                                c_lflag: c_lflag,\n                                c_cc: c_cc\n                            });\n                        }\n                        return 0;\n                    case 21519:\n                        if (!stream.tty) return -59;\n                        var argp = syscallGetVarargP();\n                        GROWABLE_HEAP_I32()[argp >>> 2 >>> 0] = 0;\n                        return 0;\n                    case 21520:\n                        if (!stream.tty) return -59;\n                        return -28;\n                    case 21531:\n                        var argp = syscallGetVarargP();\n                        return FS.ioctl(stream, op, argp);\n                    case 21523:\n                        if (!stream.tty) return -59;\n                        if (stream.tty.ops.ioctl_tiocgwinsz) {\n                            var winsize = stream.tty.ops.ioctl_tiocgwinsz(stream.tty);\n                            var argp = syscallGetVarargP();\n                            GROWABLE_HEAP_I16()[argp >>> 1 >>> 0] = winsize[0];\n                            GROWABLE_HEAP_I16()[argp + 2 >>> 1 >>> 0] = winsize[1];\n                        }\n                        return 0;\n                    case 21524:\n                        if (!stream.tty) return -59;\n                        return 0;\n                    case 21515:\n                        if (!stream.tty) return -59;\n                        return 0;\n                    default:\n                        return -28;\n                }\n            } catch (e) {\n                if (typeof FS == \"undefined\" || !(e.name === \"ErrnoError\")) throw e;\n                return -e.errno;\n            }\n        }\n        function ___syscall_openat(dirfd, path, flags, varargs) {\n            if (ENVIRONMENT_IS_PTHREAD) return proxyToMainThread(5, 0, 1, dirfd, path, flags, varargs);\n            path >>>= 0;\n            varargs >>>= 0;\n            SYSCALLS.varargs = varargs;\n            try {\n                path = SYSCALLS.getStr(path);\n                path = SYSCALLS.calculateAt(dirfd, path);\n                var mode = varargs ? syscallGetVarargI() : 0;\n                return FS.open(path, flags, mode).fd;\n            } catch (e) {\n                if (typeof FS == \"undefined\" || !(e.name === \"ErrnoError\")) throw e;\n                return -e.errno;\n            }\n        }\n        var __abort_js = ()=>{\n            abort(\"\");\n        };\n        var tupleRegistrations = {};\n        var runDestructors = (destructors)=>{\n            while(destructors.length){\n                var ptr = destructors.pop();\n                var del = destructors.pop();\n                del(ptr);\n            }\n        };\n        function readPointer(pointer) {\n            return this[\"fromWireType\"](GROWABLE_HEAP_U32()[pointer >>> 2 >>> 0]);\n        }\n        var awaitingDependencies = {};\n        var registeredTypes = {};\n        var typeDependencies = {};\n        var InternalError;\n        var throwInternalError = (message)=>{\n            throw new InternalError(message);\n        };\n        var whenDependentTypesAreResolved = (myTypes, dependentTypes, getTypeConverters)=>{\n            myTypes.forEach((type)=>typeDependencies[type] = dependentTypes);\n            function onComplete(typeConverters) {\n                var myTypeConverters = getTypeConverters(typeConverters);\n                if (myTypeConverters.length !== myTypes.length) throwInternalError(\"Mismatched type converter count\");\n                for(var i = 0; i < myTypes.length; ++i)registerType(myTypes[i], myTypeConverters[i]);\n            }\n            var typeConverters = new Array(dependentTypes.length);\n            var unregisteredTypes = [];\n            var registered = 0;\n            dependentTypes.forEach((dt, i)=>{\n                if (registeredTypes.hasOwnProperty(dt)) typeConverters[i] = registeredTypes[dt];\n                else {\n                    unregisteredTypes.push(dt);\n                    if (!awaitingDependencies.hasOwnProperty(dt)) awaitingDependencies[dt] = [];\n                    awaitingDependencies[dt].push(()=>{\n                        typeConverters[i] = registeredTypes[dt];\n                        ++registered;\n                        if (registered === unregisteredTypes.length) onComplete(typeConverters);\n                    });\n                }\n            });\n            if (0 === unregisteredTypes.length) onComplete(typeConverters);\n        };\n        var __embind_finalize_value_array = function(rawTupleType) {\n            rawTupleType >>>= 0;\n            var reg = tupleRegistrations[rawTupleType];\n            delete tupleRegistrations[rawTupleType];\n            var elements = reg.elements;\n            var elementsLength = elements.length;\n            var elementTypes = elements.map((elt)=>elt.getterReturnType).concat(elements.map((elt)=>elt.setterArgumentType));\n            var rawConstructor = reg.rawConstructor;\n            var rawDestructor = reg.rawDestructor;\n            whenDependentTypesAreResolved([\n                rawTupleType\n            ], elementTypes, (elementTypes)=>{\n                elements.forEach((elt, i)=>{\n                    var getterReturnType = elementTypes[i];\n                    var getter = elt.getter;\n                    var getterContext = elt.getterContext;\n                    var setterArgumentType = elementTypes[i + elementsLength];\n                    var setter = elt.setter;\n                    var setterContext = elt.setterContext;\n                    elt.read = (ptr)=>getterReturnType[\"fromWireType\"](getter(getterContext, ptr));\n                    elt.write = (ptr, o)=>{\n                        var destructors = [];\n                        setter(setterContext, ptr, setterArgumentType[\"toWireType\"](destructors, o));\n                        runDestructors(destructors);\n                    };\n                });\n                return [\n                    {\n                        name: reg.name,\n                        fromWireType: (ptr)=>{\n                            var rv = new Array(elementsLength);\n                            for(var i = 0; i < elementsLength; ++i)rv[i] = elements[i].read(ptr);\n                            rawDestructor(ptr);\n                            return rv;\n                        },\n                        toWireType: (destructors, o)=>{\n                            if (elementsLength !== o.length) throw new TypeError(`Incorrect number of tuple elements for ${reg.name}: expected=${elementsLength}, actual=${o.length}`);\n                            var ptr = rawConstructor();\n                            for(var i = 0; i < elementsLength; ++i)elements[i].write(ptr, o[i]);\n                            if (destructors !== null) destructors.push(rawDestructor, ptr);\n                            return ptr;\n                        },\n                        argPackAdvance: GenericWireTypeSize,\n                        readValueFromPointer: readPointer,\n                        destructorFunction: rawDestructor\n                    }\n                ];\n            });\n        };\n        var structRegistrations = {};\n        var __embind_finalize_value_object = function(structType) {\n            structType >>>= 0;\n            var reg = structRegistrations[structType];\n            delete structRegistrations[structType];\n            var rawConstructor = reg.rawConstructor;\n            var rawDestructor = reg.rawDestructor;\n            var fieldRecords = reg.fields;\n            var fieldTypes = fieldRecords.map((field)=>field.getterReturnType).concat(fieldRecords.map((field)=>field.setterArgumentType));\n            whenDependentTypesAreResolved([\n                structType\n            ], fieldTypes, (fieldTypes)=>{\n                var fields = {};\n                fieldRecords.forEach((field, i)=>{\n                    var fieldName = field.fieldName;\n                    var getterReturnType = fieldTypes[i];\n                    var getter = field.getter;\n                    var getterContext = field.getterContext;\n                    var setterArgumentType = fieldTypes[i + fieldRecords.length];\n                    var setter = field.setter;\n                    var setterContext = field.setterContext;\n                    fields[fieldName] = {\n                        read: (ptr)=>getterReturnType[\"fromWireType\"](getter(getterContext, ptr)),\n                        write: (ptr, o)=>{\n                            var destructors = [];\n                            setter(setterContext, ptr, setterArgumentType[\"toWireType\"](destructors, o));\n                            runDestructors(destructors);\n                        }\n                    };\n                });\n                return [\n                    {\n                        name: reg.name,\n                        fromWireType: (ptr)=>{\n                            var rv = {};\n                            for(var i in fields)rv[i] = fields[i].read(ptr);\n                            rawDestructor(ptr);\n                            return rv;\n                        },\n                        toWireType: (destructors, o)=>{\n                            for(var fieldName in fields){\n                                if (!(fieldName in o)) throw new TypeError(`Missing field: \"${fieldName}\"`);\n                            }\n                            var ptr = rawConstructor();\n                            for(fieldName in fields)fields[fieldName].write(ptr, o[fieldName]);\n                            if (destructors !== null) destructors.push(rawDestructor, ptr);\n                            return ptr;\n                        },\n                        argPackAdvance: GenericWireTypeSize,\n                        readValueFromPointer: readPointer,\n                        destructorFunction: rawDestructor\n                    }\n                ];\n            });\n        };\n        function __embind_register_bigint(primitiveType, name, size, minRange, maxRange) {\n            primitiveType >>>= 0;\n            name >>>= 0;\n            size >>>= 0;\n        }\n        var embind_init_charCodes = ()=>{\n            var codes = new Array(256);\n            for(var i = 0; i < 256; ++i)codes[i] = String.fromCharCode(i);\n            embind_charCodes = codes;\n        };\n        var embind_charCodes;\n        var readLatin1String = (ptr)=>{\n            var ret = \"\";\n            var c = ptr;\n            while(GROWABLE_HEAP_U8()[c >>> 0])ret += embind_charCodes[GROWABLE_HEAP_U8()[c++ >>> 0]];\n            return ret;\n        };\n        var BindingError;\n        var throwBindingError = (message)=>{\n            throw new BindingError(message);\n        };\n        function sharedRegisterType(rawType, registeredInstance, options = {}) {\n            var name = registeredInstance.name;\n            if (!rawType) throwBindingError(`type \"${name}\" must have a positive integer typeid pointer`);\n            if (registeredTypes.hasOwnProperty(rawType)) {\n                if (options.ignoreDuplicateRegistrations) return;\n                else throwBindingError(`Cannot register type '${name}' twice`);\n            }\n            registeredTypes[rawType] = registeredInstance;\n            delete typeDependencies[rawType];\n            if (awaitingDependencies.hasOwnProperty(rawType)) {\n                var callbacks = awaitingDependencies[rawType];\n                delete awaitingDependencies[rawType];\n                callbacks.forEach((cb)=>cb());\n            }\n        }\n        function registerType(rawType, registeredInstance, options = {}) {\n            return sharedRegisterType(rawType, registeredInstance, options);\n        }\n        var GenericWireTypeSize = 8;\n        function __embind_register_bool(rawType, name, trueValue, falseValue) {\n            rawType >>>= 0;\n            name >>>= 0;\n            name = readLatin1String(name);\n            registerType(rawType, {\n                name: name,\n                fromWireType: function(wt) {\n                    return !!wt;\n                },\n                toWireType: function(destructors, o) {\n                    return o ? trueValue : falseValue;\n                },\n                argPackAdvance: GenericWireTypeSize,\n                readValueFromPointer: function(pointer) {\n                    return this[\"fromWireType\"](GROWABLE_HEAP_U8()[pointer >>> 0]);\n                },\n                destructorFunction: null\n            });\n        }\n        var shallowCopyInternalPointer = (o)=>({\n                count: o.count,\n                deleteScheduled: o.deleteScheduled,\n                preservePointerOnDelete: o.preservePointerOnDelete,\n                ptr: o.ptr,\n                ptrType: o.ptrType,\n                smartPtr: o.smartPtr,\n                smartPtrType: o.smartPtrType\n            });\n        var throwInstanceAlreadyDeleted = (obj)=>{\n            function getInstanceTypeName(handle) {\n                return handle.$$.ptrType.registeredClass.name;\n            }\n            throwBindingError(getInstanceTypeName(obj) + \" instance already deleted\");\n        };\n        var finalizationRegistry = false;\n        var detachFinalizer = (handle)=>{};\n        var runDestructor = ($$)=>{\n            if ($$.smartPtr) $$.smartPtrType.rawDestructor($$.smartPtr);\n            else $$.ptrType.registeredClass.rawDestructor($$.ptr);\n        };\n        var releaseClassHandle = ($$)=>{\n            $$.count.value -= 1;\n            var toDelete = 0 === $$.count.value;\n            if (toDelete) runDestructor($$);\n        };\n        var downcastPointer = (ptr, ptrClass, desiredClass)=>{\n            if (ptrClass === desiredClass) return ptr;\n            if (undefined === desiredClass.baseClass) return null;\n            var rv = downcastPointer(ptr, ptrClass, desiredClass.baseClass);\n            if (rv === null) return null;\n            return desiredClass.downcast(rv);\n        };\n        var registeredPointers = {};\n        var registeredInstances = {};\n        var getBasestPointer = (class_, ptr)=>{\n            if (ptr === undefined) throwBindingError(\"ptr should not be undefined\");\n            while(class_.baseClass){\n                ptr = class_.upcast(ptr);\n                class_ = class_.baseClass;\n            }\n            return ptr;\n        };\n        var getInheritedInstance = (class_, ptr)=>{\n            ptr = getBasestPointer(class_, ptr);\n            return registeredInstances[ptr];\n        };\n        var makeClassHandle = (prototype, record)=>{\n            if (!record.ptrType || !record.ptr) throwInternalError(\"makeClassHandle requires ptr and ptrType\");\n            var hasSmartPtrType = !!record.smartPtrType;\n            var hasSmartPtr = !!record.smartPtr;\n            if (hasSmartPtrType !== hasSmartPtr) throwInternalError(\"Both smartPtrType and smartPtr must be specified\");\n            record.count = {\n                value: 1\n            };\n            return attachFinalizer(Object.create(prototype, {\n                $$: {\n                    value: record,\n                    writable: true\n                }\n            }));\n        };\n        function RegisteredPointer_fromWireType(ptr) {\n            var rawPointer = this.getPointee(ptr);\n            if (!rawPointer) {\n                this.destructor(ptr);\n                return null;\n            }\n            var registeredInstance = getInheritedInstance(this.registeredClass, rawPointer);\n            if (undefined !== registeredInstance) {\n                if (0 === registeredInstance.$$.count.value) {\n                    registeredInstance.$$.ptr = rawPointer;\n                    registeredInstance.$$.smartPtr = ptr;\n                    return registeredInstance[\"clone\"]();\n                } else {\n                    var rv = registeredInstance[\"clone\"]();\n                    this.destructor(ptr);\n                    return rv;\n                }\n            }\n            function makeDefaultHandle() {\n                if (this.isSmartPointer) return makeClassHandle(this.registeredClass.instancePrototype, {\n                    ptrType: this.pointeeType,\n                    ptr: rawPointer,\n                    smartPtrType: this,\n                    smartPtr: ptr\n                });\n                else return makeClassHandle(this.registeredClass.instancePrototype, {\n                    ptrType: this,\n                    ptr: ptr\n                });\n            }\n            var actualType = this.registeredClass.getActualType(rawPointer);\n            var registeredPointerRecord = registeredPointers[actualType];\n            if (!registeredPointerRecord) return makeDefaultHandle.call(this);\n            var toType;\n            if (this.isConst) toType = registeredPointerRecord.constPointerType;\n            else toType = registeredPointerRecord.pointerType;\n            var dp = downcastPointer(rawPointer, this.registeredClass, toType.registeredClass);\n            if (dp === null) return makeDefaultHandle.call(this);\n            if (this.isSmartPointer) return makeClassHandle(toType.registeredClass.instancePrototype, {\n                ptrType: toType,\n                ptr: dp,\n                smartPtrType: this,\n                smartPtr: ptr\n            });\n            else return makeClassHandle(toType.registeredClass.instancePrototype, {\n                ptrType: toType,\n                ptr: dp\n            });\n        }\n        var attachFinalizer = (handle)=>{\n            if (\"undefined\" === typeof FinalizationRegistry) {\n                attachFinalizer = (handle)=>handle;\n                return handle;\n            }\n            finalizationRegistry = new FinalizationRegistry((info)=>{\n                releaseClassHandle(info.$$);\n            });\n            attachFinalizer = (handle)=>{\n                var $$ = handle.$$;\n                var hasSmartPtr = !!$$.smartPtr;\n                if (hasSmartPtr) {\n                    var info = {\n                        $$: $$\n                    };\n                    finalizationRegistry.register(handle, info, handle);\n                }\n                return handle;\n            };\n            detachFinalizer = (handle)=>finalizationRegistry.unregister(handle);\n            return attachFinalizer(handle);\n        };\n        var deletionQueue = [];\n        var flushPendingDeletes = ()=>{\n            while(deletionQueue.length){\n                var obj = deletionQueue.pop();\n                obj.$$.deleteScheduled = false;\n                obj[\"delete\"]();\n            }\n        };\n        var delayFunction;\n        var init_ClassHandle = ()=>{\n            Object.assign(ClassHandle.prototype, {\n                isAliasOf (other) {\n                    if (!(this instanceof ClassHandle)) return false;\n                    if (!(other instanceof ClassHandle)) return false;\n                    var leftClass = this.$$.ptrType.registeredClass;\n                    var left = this.$$.ptr;\n                    other.$$ = other.$$;\n                    var rightClass = other.$$.ptrType.registeredClass;\n                    var right = other.$$.ptr;\n                    while(leftClass.baseClass){\n                        left = leftClass.upcast(left);\n                        leftClass = leftClass.baseClass;\n                    }\n                    while(rightClass.baseClass){\n                        right = rightClass.upcast(right);\n                        rightClass = rightClass.baseClass;\n                    }\n                    return leftClass === rightClass && left === right;\n                },\n                clone () {\n                    if (!this.$$.ptr) throwInstanceAlreadyDeleted(this);\n                    if (this.$$.preservePointerOnDelete) {\n                        this.$$.count.value += 1;\n                        return this;\n                    } else {\n                        var clone = attachFinalizer(Object.create(Object.getPrototypeOf(this), {\n                            $$: {\n                                value: shallowCopyInternalPointer(this.$$)\n                            }\n                        }));\n                        clone.$$.count.value += 1;\n                        clone.$$.deleteScheduled = false;\n                        return clone;\n                    }\n                },\n                delete () {\n                    if (!this.$$.ptr) throwInstanceAlreadyDeleted(this);\n                    if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) throwBindingError(\"Object already scheduled for deletion\");\n                    detachFinalizer(this);\n                    releaseClassHandle(this.$$);\n                    if (!this.$$.preservePointerOnDelete) {\n                        this.$$.smartPtr = undefined;\n                        this.$$.ptr = undefined;\n                    }\n                },\n                isDeleted () {\n                    return !this.$$.ptr;\n                },\n                deleteLater () {\n                    if (!this.$$.ptr) throwInstanceAlreadyDeleted(this);\n                    if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) throwBindingError(\"Object already scheduled for deletion\");\n                    deletionQueue.push(this);\n                    if (deletionQueue.length === 1 && delayFunction) delayFunction(flushPendingDeletes);\n                    this.$$.deleteScheduled = true;\n                    return this;\n                }\n            });\n        };\n        function ClassHandle() {}\n        var createNamedFunction = (name, body)=>Object.defineProperty(body, \"name\", {\n                value: name\n            });\n        var ensureOverloadTable = (proto, methodName, humanName)=>{\n            if (undefined === proto[methodName].overloadTable) {\n                var prevFunc = proto[methodName];\n                proto[methodName] = function(...args) {\n                    if (!proto[methodName].overloadTable.hasOwnProperty(args.length)) throwBindingError(`Function '${humanName}' called with an invalid number of arguments (${args.length}) - expects one of (${proto[methodName].overloadTable})!`);\n                    return proto[methodName].overloadTable[args.length].apply(this, args);\n                };\n                proto[methodName].overloadTable = [];\n                proto[methodName].overloadTable[prevFunc.argCount] = prevFunc;\n            }\n        };\n        var exposePublicSymbol = (name, value, numArguments)=>{\n            if (Module.hasOwnProperty(name)) {\n                if (undefined === numArguments || undefined !== Module[name].overloadTable && undefined !== Module[name].overloadTable[numArguments]) throwBindingError(`Cannot register public name '${name}' twice`);\n                ensureOverloadTable(Module, name, name);\n                if (Module[name].overloadTable.hasOwnProperty(numArguments)) throwBindingError(`Cannot register multiple overloads of a function with the same number of arguments (${numArguments})!`);\n                Module[name].overloadTable[numArguments] = value;\n            } else {\n                Module[name] = value;\n                Module[name].argCount = numArguments;\n            }\n        };\n        var char_0 = 48;\n        var char_9 = 57;\n        var makeLegalFunctionName = (name)=>{\n            name = name.replace(/[^a-zA-Z0-9_]/g, \"$\");\n            var f = name.charCodeAt(0);\n            if (f >= char_0 && f <= char_9) return `_${name}`;\n            return name;\n        };\n        function RegisteredClass(name, constructor, instancePrototype, rawDestructor, baseClass, getActualType, upcast, downcast) {\n            this.name = name;\n            this.constructor = constructor;\n            this.instancePrototype = instancePrototype;\n            this.rawDestructor = rawDestructor;\n            this.baseClass = baseClass;\n            this.getActualType = getActualType;\n            this.upcast = upcast;\n            this.downcast = downcast;\n            this.pureVirtualFunctions = [];\n        }\n        var upcastPointer = (ptr, ptrClass, desiredClass)=>{\n            while(ptrClass !== desiredClass){\n                if (!ptrClass.upcast) throwBindingError(`Expected null or instance of ${desiredClass.name}, got an instance of ${ptrClass.name}`);\n                ptr = ptrClass.upcast(ptr);\n                ptrClass = ptrClass.baseClass;\n            }\n            return ptr;\n        };\n        function constNoSmartPtrRawPointerToWireType(destructors, handle) {\n            if (handle === null) {\n                if (this.isReference) throwBindingError(`null is not a valid ${this.name}`);\n                return 0;\n            }\n            if (!handle.$$) throwBindingError(`Cannot pass \"${embindRepr(handle)}\" as a ${this.name}`);\n            if (!handle.$$.ptr) throwBindingError(`Cannot pass deleted object as a pointer of type ${this.name}`);\n            var handleClass = handle.$$.ptrType.registeredClass;\n            var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);\n            return ptr;\n        }\n        function genericPointerToWireType(destructors, handle) {\n            var ptr;\n            if (handle === null) {\n                if (this.isReference) throwBindingError(`null is not a valid ${this.name}`);\n                if (this.isSmartPointer) {\n                    ptr = this.rawConstructor();\n                    if (destructors !== null) destructors.push(this.rawDestructor, ptr);\n                    return ptr;\n                } else return 0;\n            }\n            if (!handle || !handle.$$) throwBindingError(`Cannot pass \"${embindRepr(handle)}\" as a ${this.name}`);\n            if (!handle.$$.ptr) throwBindingError(`Cannot pass deleted object as a pointer of type ${this.name}`);\n            if (!this.isConst && handle.$$.ptrType.isConst) throwBindingError(`Cannot convert argument of type ${handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name} to parameter type ${this.name}`);\n            var handleClass = handle.$$.ptrType.registeredClass;\n            ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);\n            if (this.isSmartPointer) {\n                if (undefined === handle.$$.smartPtr) throwBindingError(\"Passing raw pointer to smart pointer is illegal\");\n                switch(this.sharingPolicy){\n                    case 0:\n                        if (handle.$$.smartPtrType === this) ptr = handle.$$.smartPtr;\n                        else throwBindingError(`Cannot convert argument of type ${handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name} to parameter type ${this.name}`);\n                        break;\n                    case 1:\n                        ptr = handle.$$.smartPtr;\n                        break;\n                    case 2:\n                        if (handle.$$.smartPtrType === this) ptr = handle.$$.smartPtr;\n                        else {\n                            var clonedHandle = handle[\"clone\"]();\n                            ptr = this.rawShare(ptr, Emval.toHandle(()=>clonedHandle[\"delete\"]()));\n                            if (destructors !== null) destructors.push(this.rawDestructor, ptr);\n                        }\n                        break;\n                    default:\n                        throwBindingError(\"Unsupporting sharing policy\");\n                }\n            }\n            return ptr;\n        }\n        function nonConstNoSmartPtrRawPointerToWireType(destructors, handle) {\n            if (handle === null) {\n                if (this.isReference) throwBindingError(`null is not a valid ${this.name}`);\n                return 0;\n            }\n            if (!handle.$$) throwBindingError(`Cannot pass \"${embindRepr(handle)}\" as a ${this.name}`);\n            if (!handle.$$.ptr) throwBindingError(`Cannot pass deleted object as a pointer of type ${this.name}`);\n            if (handle.$$.ptrType.isConst) throwBindingError(`Cannot convert argument of type ${handle.$$.ptrType.name} to parameter type ${this.name}`);\n            var handleClass = handle.$$.ptrType.registeredClass;\n            var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);\n            return ptr;\n        }\n        var init_RegisteredPointer = ()=>{\n            Object.assign(RegisteredPointer.prototype, {\n                getPointee (ptr) {\n                    if (this.rawGetPointee) ptr = this.rawGetPointee(ptr);\n                    return ptr;\n                },\n                destructor (ptr) {\n                    this.rawDestructor?.(ptr);\n                },\n                argPackAdvance: GenericWireTypeSize,\n                readValueFromPointer: readPointer,\n                fromWireType: RegisteredPointer_fromWireType\n            });\n        };\n        function RegisteredPointer(name, registeredClass, isReference, isConst, isSmartPointer, pointeeType, sharingPolicy, rawGetPointee, rawConstructor, rawShare, rawDestructor) {\n            this.name = name;\n            this.registeredClass = registeredClass;\n            this.isReference = isReference;\n            this.isConst = isConst;\n            this.isSmartPointer = isSmartPointer;\n            this.pointeeType = pointeeType;\n            this.sharingPolicy = sharingPolicy;\n            this.rawGetPointee = rawGetPointee;\n            this.rawConstructor = rawConstructor;\n            this.rawShare = rawShare;\n            this.rawDestructor = rawDestructor;\n            if (!isSmartPointer && registeredClass.baseClass === undefined) {\n                if (isConst) {\n                    this[\"toWireType\"] = constNoSmartPtrRawPointerToWireType;\n                    this.destructorFunction = null;\n                } else {\n                    this[\"toWireType\"] = nonConstNoSmartPtrRawPointerToWireType;\n                    this.destructorFunction = null;\n                }\n            } else this[\"toWireType\"] = genericPointerToWireType;\n        }\n        var replacePublicSymbol = (name, value, numArguments)=>{\n            if (!Module.hasOwnProperty(name)) throwInternalError(\"Replacing nonexistent public symbol\");\n            if (undefined !== Module[name].overloadTable && undefined !== numArguments) Module[name].overloadTable[numArguments] = value;\n            else {\n                Module[name] = value;\n                Module[name].argCount = numArguments;\n            }\n        };\n        var dynCallLegacy = (sig, ptr, args)=>{\n            sig = sig.replace(/p/g, \"i\");\n            var f = Module[\"dynCall_\" + sig];\n            return f(ptr, ...args);\n        };\n        var dynCall = (sig, ptr, args = [])=>{\n            if (sig.includes(\"j\")) return dynCallLegacy(sig, ptr, args);\n            var rtn = getWasmTableEntry(ptr)(...args);\n            return sig[0] == \"p\" ? rtn >>> 0 : rtn;\n        };\n        var getDynCaller = (sig, ptr)=>(...args)=>dynCall(sig, ptr, args);\n        var embind__requireFunction = (signature, rawFunction)=>{\n            signature = readLatin1String(signature);\n            function makeDynCaller() {\n                if (signature.includes(\"j\")) return getDynCaller(signature, rawFunction);\n                if (signature.includes(\"p\")) return getDynCaller(signature, rawFunction);\n                return getWasmTableEntry(rawFunction);\n            }\n            var fp = makeDynCaller();\n            if (typeof fp != \"function\") throwBindingError(`unknown function pointer with signature ${signature}: ${rawFunction}`);\n            return fp;\n        };\n        var extendError = (baseErrorType, errorName)=>{\n            var errorClass = createNamedFunction(errorName, function(message) {\n                this.name = errorName;\n                this.message = message;\n                var stack = new Error(message).stack;\n                if (stack !== undefined) this.stack = this.toString() + \"\\n\" + stack.replace(/^Error(:[^\\n]*)?\\n/, \"\");\n            });\n            errorClass.prototype = Object.create(baseErrorType.prototype);\n            errorClass.prototype.constructor = errorClass;\n            errorClass.prototype.toString = function() {\n                if (this.message === undefined) return this.name;\n                else return `${this.name}: ${this.message}`;\n            };\n            return errorClass;\n        };\n        var UnboundTypeError;\n        var getTypeName = (type)=>{\n            var ptr = ___getTypeName(type);\n            var rv = readLatin1String(ptr);\n            _free(ptr);\n            return rv;\n        };\n        var throwUnboundTypeError = (message, types)=>{\n            var unboundTypes = [];\n            var seen = {};\n            function visit(type) {\n                if (seen[type]) return;\n                if (registeredTypes[type]) return;\n                if (typeDependencies[type]) {\n                    typeDependencies[type].forEach(visit);\n                    return;\n                }\n                unboundTypes.push(type);\n                seen[type] = true;\n            }\n            types.forEach(visit);\n            throw new UnboundTypeError(`${message}: ` + unboundTypes.map(getTypeName).join([\n                \", \"\n            ]));\n        };\n        function __embind_register_class(rawType, rawPointerType, rawConstPointerType, baseClassRawType, getActualTypeSignature, getActualType, upcastSignature, upcast, downcastSignature, downcast, name, destructorSignature, rawDestructor) {\n            rawType >>>= 0;\n            rawPointerType >>>= 0;\n            rawConstPointerType >>>= 0;\n            baseClassRawType >>>= 0;\n            getActualTypeSignature >>>= 0;\n            getActualType >>>= 0;\n            upcastSignature >>>= 0;\n            upcast >>>= 0;\n            downcastSignature >>>= 0;\n            downcast >>>= 0;\n            name >>>= 0;\n            destructorSignature >>>= 0;\n            rawDestructor >>>= 0;\n            name = readLatin1String(name);\n            getActualType = embind__requireFunction(getActualTypeSignature, getActualType);\n            upcast &&= embind__requireFunction(upcastSignature, upcast);\n            downcast &&= embind__requireFunction(downcastSignature, downcast);\n            rawDestructor = embind__requireFunction(destructorSignature, rawDestructor);\n            var legalFunctionName = makeLegalFunctionName(name);\n            exposePublicSymbol(legalFunctionName, function() {\n                throwUnboundTypeError(`Cannot construct ${name} due to unbound types`, [\n                    baseClassRawType\n                ]);\n            });\n            whenDependentTypesAreResolved([\n                rawType,\n                rawPointerType,\n                rawConstPointerType\n            ], baseClassRawType ? [\n                baseClassRawType\n            ] : [], (base)=>{\n                base = base[0];\n                var baseClass;\n                var basePrototype;\n                if (baseClassRawType) {\n                    baseClass = base.registeredClass;\n                    basePrototype = baseClass.instancePrototype;\n                } else basePrototype = ClassHandle.prototype;\n                var constructor = createNamedFunction(name, function(...args) {\n                    if (Object.getPrototypeOf(this) !== instancePrototype) throw new BindingError(\"Use 'new' to construct \" + name);\n                    if (undefined === registeredClass.constructor_body) throw new BindingError(name + \" has no accessible constructor\");\n                    var body = registeredClass.constructor_body[args.length];\n                    if (undefined === body) throw new BindingError(`Tried to invoke ctor of ${name} with invalid number of parameters (${args.length}) - expected (${Object.keys(registeredClass.constructor_body).toString()}) parameters instead!`);\n                    return body.apply(this, args);\n                });\n                var instancePrototype = Object.create(basePrototype, {\n                    constructor: {\n                        value: constructor\n                    }\n                });\n                constructor.prototype = instancePrototype;\n                var registeredClass = new RegisteredClass(name, constructor, instancePrototype, rawDestructor, baseClass, getActualType, upcast, downcast);\n                if (registeredClass.baseClass) {\n                    registeredClass.baseClass.__derivedClasses ??= [];\n                    registeredClass.baseClass.__derivedClasses.push(registeredClass);\n                }\n                var referenceConverter = new RegisteredPointer(name, registeredClass, true, false, false);\n                var pointerConverter = new RegisteredPointer(name + \"*\", registeredClass, false, false, false);\n                var constPointerConverter = new RegisteredPointer(name + \" const*\", registeredClass, false, true, false);\n                registeredPointers[rawType] = {\n                    pointerType: pointerConverter,\n                    constPointerType: constPointerConverter\n                };\n                replacePublicSymbol(legalFunctionName, constructor);\n                return [\n                    referenceConverter,\n                    pointerConverter,\n                    constPointerConverter\n                ];\n            });\n        }\n        var heap32VectorToArray = (count, firstElement)=>{\n            var array = [];\n            for(var i = 0; i < count; i++)array.push(GROWABLE_HEAP_U32()[firstElement + i * 4 >>> 2 >>> 0]);\n            return array;\n        };\n        function usesDestructorStack(argTypes) {\n            for(var i = 1; i < argTypes.length; ++i){\n                if (argTypes[i] !== null && argTypes[i].destructorFunction === undefined) return true;\n            }\n            return false;\n        }\n        function newFunc(constructor, argumentList) {\n            if (!(constructor instanceof Function)) throw new TypeError(`new_ called with constructor type ${typeof constructor} which is not a function`);\n            var dummy = createNamedFunction(constructor.name || \"unknownFunctionName\", function() {});\n            dummy.prototype = constructor.prototype;\n            var obj = new dummy;\n            var r = constructor.apply(obj, argumentList);\n            return r instanceof Object ? r : obj;\n        }\n        function createJsInvoker(argTypes, isClassMethodFunc, returns, isAsync) {\n            var needsDestructorStack = usesDestructorStack(argTypes);\n            var argCount = argTypes.length - 2;\n            var argsList = [];\n            var argsListWired = [\n                \"fn\"\n            ];\n            if (isClassMethodFunc) argsListWired.push(\"thisWired\");\n            for(var i = 0; i < argCount; ++i){\n                argsList.push(`arg${i}`);\n                argsListWired.push(`arg${i}Wired`);\n            }\n            argsList = argsList.join(\",\");\n            argsListWired = argsListWired.join(\",\");\n            var invokerFnBody = `return function (${argsList}) {\\n`;\n            if (needsDestructorStack) invokerFnBody += \"var destructors = [];\\n\";\n            var dtorStack = needsDestructorStack ? \"destructors\" : \"null\";\n            var args1 = [\n                \"humanName\",\n                \"throwBindingError\",\n                \"invoker\",\n                \"fn\",\n                \"runDestructors\",\n                \"retType\",\n                \"classParam\"\n            ];\n            if (isClassMethodFunc) invokerFnBody += `var thisWired = classParam['toWireType'](${dtorStack}, this);\\n`;\n            for(var i = 0; i < argCount; ++i){\n                invokerFnBody += `var arg${i}Wired = argType${i}['toWireType'](${dtorStack}, arg${i});\\n`;\n                args1.push(`argType${i}`);\n            }\n            invokerFnBody += (returns || isAsync ? \"var rv = \" : \"\") + `invoker(${argsListWired});\\n`;\n            if (needsDestructorStack) invokerFnBody += \"runDestructors(destructors);\\n\";\n            else for(var i = isClassMethodFunc ? 1 : 2; i < argTypes.length; ++i){\n                var paramName = i === 1 ? \"thisWired\" : \"arg\" + (i - 2) + \"Wired\";\n                if (argTypes[i].destructorFunction !== null) {\n                    invokerFnBody += `${paramName}_dtor(${paramName});\\n`;\n                    args1.push(`${paramName}_dtor`);\n                }\n            }\n            if (returns) invokerFnBody += \"var ret = retType['fromWireType'](rv);\\nreturn ret;\\n\";\n            invokerFnBody += \"}\\n\";\n            return [\n                args1,\n                invokerFnBody\n            ];\n        }\n        function craftInvokerFunction(humanName, argTypes, classType, cppInvokerFunc, cppTargetFunc, isAsync) {\n            var argCount = argTypes.length;\n            if (argCount < 2) throwBindingError(\"argTypes array size mismatch! Must at least get return value and 'this' types!\");\n            var isClassMethodFunc = argTypes[1] !== null && classType !== null;\n            var needsDestructorStack = usesDestructorStack(argTypes);\n            var returns = argTypes[0].name !== \"void\";\n            var closureArgs = [\n                humanName,\n                throwBindingError,\n                cppInvokerFunc,\n                cppTargetFunc,\n                runDestructors,\n                argTypes[0],\n                argTypes[1]\n            ];\n            for(var i = 0; i < argCount - 2; ++i)closureArgs.push(argTypes[i + 2]);\n            if (!needsDestructorStack) {\n                for(var i = isClassMethodFunc ? 1 : 2; i < argTypes.length; ++i)if (argTypes[i].destructorFunction !== null) closureArgs.push(argTypes[i].destructorFunction);\n            }\n            let [args, invokerFnBody] = createJsInvoker(argTypes, isClassMethodFunc, returns, isAsync);\n            args.push(invokerFnBody);\n            var invokerFn = newFunc(Function, args)(...closureArgs);\n            return createNamedFunction(humanName, invokerFn);\n        }\n        var __embind_register_class_constructor = function(rawClassType, argCount, rawArgTypesAddr, invokerSignature, invoker, rawConstructor) {\n            rawClassType >>>= 0;\n            rawArgTypesAddr >>>= 0;\n            invokerSignature >>>= 0;\n            invoker >>>= 0;\n            rawConstructor >>>= 0;\n            var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);\n            invoker = embind__requireFunction(invokerSignature, invoker);\n            whenDependentTypesAreResolved([], [\n                rawClassType\n            ], (classType)=>{\n                classType = classType[0];\n                var humanName = `constructor ${classType.name}`;\n                if (undefined === classType.registeredClass.constructor_body) classType.registeredClass.constructor_body = [];\n                if (undefined !== classType.registeredClass.constructor_body[argCount - 1]) throw new BindingError(`Cannot register multiple constructors with identical number of parameters (${argCount - 1}) for class '${classType.name}'! Overload resolution is currently only performed using the parameter count, not actual type info!`);\n                classType.registeredClass.constructor_body[argCount - 1] = ()=>{\n                    throwUnboundTypeError(`Cannot construct ${classType.name} due to unbound types`, rawArgTypes);\n                };\n                whenDependentTypesAreResolved([], rawArgTypes, (argTypes)=>{\n                    argTypes.splice(1, 0, null);\n                    classType.registeredClass.constructor_body[argCount - 1] = craftInvokerFunction(humanName, argTypes, null, invoker, rawConstructor);\n                    return [];\n                });\n                return [];\n            });\n        };\n        var getFunctionName = (signature)=>{\n            signature = signature.trim();\n            const argsIndex = signature.indexOf(\"(\");\n            if (argsIndex !== -1) return signature.substr(0, argsIndex);\n            else return signature;\n        };\n        var __embind_register_class_function = function(rawClassType, methodName, argCount, rawArgTypesAddr, invokerSignature, rawInvoker, context, isPureVirtual, isAsync, isNonnullReturn) {\n            rawClassType >>>= 0;\n            methodName >>>= 0;\n            rawArgTypesAddr >>>= 0;\n            invokerSignature >>>= 0;\n            rawInvoker >>>= 0;\n            context >>>= 0;\n            var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);\n            methodName = readLatin1String(methodName);\n            methodName = getFunctionName(methodName);\n            rawInvoker = embind__requireFunction(invokerSignature, rawInvoker);\n            whenDependentTypesAreResolved([], [\n                rawClassType\n            ], (classType)=>{\n                classType = classType[0];\n                var humanName = `${classType.name}.${methodName}`;\n                if (methodName.startsWith(\"@@\")) methodName = Symbol[methodName.substring(2)];\n                if (isPureVirtual) classType.registeredClass.pureVirtualFunctions.push(methodName);\n                function unboundTypesHandler() {\n                    throwUnboundTypeError(`Cannot call ${humanName} due to unbound types`, rawArgTypes);\n                }\n                var proto = classType.registeredClass.instancePrototype;\n                var method = proto[methodName];\n                if (undefined === method || undefined === method.overloadTable && method.className !== classType.name && method.argCount === argCount - 2) {\n                    unboundTypesHandler.argCount = argCount - 2;\n                    unboundTypesHandler.className = classType.name;\n                    proto[methodName] = unboundTypesHandler;\n                } else {\n                    ensureOverloadTable(proto, methodName, humanName);\n                    proto[methodName].overloadTable[argCount - 2] = unboundTypesHandler;\n                }\n                whenDependentTypesAreResolved([], rawArgTypes, (argTypes)=>{\n                    var memberFunction = craftInvokerFunction(humanName, argTypes, classType, rawInvoker, context, isAsync);\n                    if (undefined === proto[methodName].overloadTable) {\n                        memberFunction.argCount = argCount - 2;\n                        proto[methodName] = memberFunction;\n                    } else proto[methodName].overloadTable[argCount - 2] = memberFunction;\n                    return [];\n                });\n                return [];\n            });\n        };\n        var validateThis = (this_, classType, humanName)=>{\n            if (!(this_ instanceof Object)) throwBindingError(`${humanName} with invalid \"this\": ${this_}`);\n            if (!(this_ instanceof classType.registeredClass.constructor)) throwBindingError(`${humanName} incompatible with \"this\" of type ${this_.constructor.name}`);\n            if (!this_.$$.ptr) throwBindingError(`cannot call emscripten binding method ${humanName} on deleted object`);\n            return upcastPointer(this_.$$.ptr, this_.$$.ptrType.registeredClass, classType.registeredClass);\n        };\n        var __embind_register_class_property = function(classType, fieldName, getterReturnType, getterSignature, getter, getterContext, setterArgumentType, setterSignature, setter, setterContext) {\n            classType >>>= 0;\n            fieldName >>>= 0;\n            getterReturnType >>>= 0;\n            getterSignature >>>= 0;\n            getter >>>= 0;\n            getterContext >>>= 0;\n            setterArgumentType >>>= 0;\n            setterSignature >>>= 0;\n            setter >>>= 0;\n            setterContext >>>= 0;\n            fieldName = readLatin1String(fieldName);\n            getter = embind__requireFunction(getterSignature, getter);\n            whenDependentTypesAreResolved([], [\n                classType\n            ], (classType)=>{\n                classType = classType[0];\n                var humanName = `${classType.name}.${fieldName}`;\n                var desc = {\n                    get () {\n                        throwUnboundTypeError(`Cannot access ${humanName} due to unbound types`, [\n                            getterReturnType,\n                            setterArgumentType\n                        ]);\n                    },\n                    enumerable: true,\n                    configurable: true\n                };\n                if (setter) desc.set = ()=>throwUnboundTypeError(`Cannot access ${humanName} due to unbound types`, [\n                        getterReturnType,\n                        setterArgumentType\n                    ]);\n                else desc.set = (v)=>throwBindingError(humanName + \" is a read-only property\");\n                Object.defineProperty(classType.registeredClass.instancePrototype, fieldName, desc);\n                whenDependentTypesAreResolved([], setter ? [\n                    getterReturnType,\n                    setterArgumentType\n                ] : [\n                    getterReturnType\n                ], (types)=>{\n                    var getterReturnType = types[0];\n                    var desc = {\n                        get () {\n                            var ptr = validateThis(this, classType, humanName + \" getter\");\n                            return getterReturnType[\"fromWireType\"](getter(getterContext, ptr));\n                        },\n                        enumerable: true\n                    };\n                    if (setter) {\n                        setter = embind__requireFunction(setterSignature, setter);\n                        var setterArgumentType = types[1];\n                        desc.set = function(v) {\n                            var ptr = validateThis(this, classType, humanName + \" setter\");\n                            var destructors = [];\n                            setter(setterContext, ptr, setterArgumentType[\"toWireType\"](destructors, v));\n                            runDestructors(destructors);\n                        };\n                    }\n                    Object.defineProperty(classType.registeredClass.instancePrototype, fieldName, desc);\n                    return [];\n                });\n                return [];\n            });\n        };\n        var emval_freelist = [];\n        var emval_handles = [];\n        function __emval_decref(handle) {\n            handle >>>= 0;\n            if (handle > 9 && 0 === --emval_handles[handle + 1]) {\n                emval_handles[handle] = undefined;\n                emval_freelist.push(handle);\n            }\n        }\n        var count_emval_handles = ()=>emval_handles.length / 2 - 5 - emval_freelist.length;\n        var init_emval = ()=>{\n            emval_handles.push(0, 1, undefined, 1, null, 1, true, 1, false, 1);\n            Module[\"count_emval_handles\"] = count_emval_handles;\n        };\n        var Emval = {\n            toValue: (handle)=>{\n                if (!handle) throwBindingError(\"Cannot use deleted val. handle = \" + handle);\n                return emval_handles[handle];\n            },\n            toHandle: (value)=>{\n                switch(value){\n                    case undefined:\n                        return 2;\n                    case null:\n                        return 4;\n                    case true:\n                        return 6;\n                    case false:\n                        return 8;\n                    default:\n                        {\n                            const handle = emval_freelist.pop() || emval_handles.length;\n                            emval_handles[handle] = value;\n                            emval_handles[handle + 1] = 1;\n                            return handle;\n                        }\n                }\n            }\n        };\n        var EmValType = {\n            name: \"emscripten::val\",\n            fromWireType: (handle)=>{\n                var rv = Emval.toValue(handle);\n                __emval_decref(handle);\n                return rv;\n            },\n            toWireType: (destructors, value)=>Emval.toHandle(value),\n            argPackAdvance: GenericWireTypeSize,\n            readValueFromPointer: readPointer,\n            destructorFunction: null\n        };\n        function __embind_register_emval(rawType) {\n            rawType >>>= 0;\n            return registerType(rawType, EmValType);\n        }\n        var enumReadValueFromPointer = (name, width, signed)=>{\n            switch(width){\n                case 1:\n                    return signed ? function(pointer) {\n                        return this[\"fromWireType\"](GROWABLE_HEAP_I8()[pointer >>> 0]);\n                    } : function(pointer) {\n                        return this[\"fromWireType\"](GROWABLE_HEAP_U8()[pointer >>> 0]);\n                    };\n                case 2:\n                    return signed ? function(pointer) {\n                        return this[\"fromWireType\"](GROWABLE_HEAP_I16()[pointer >>> 1 >>> 0]);\n                    } : function(pointer) {\n                        return this[\"fromWireType\"](GROWABLE_HEAP_U16()[pointer >>> 1 >>> 0]);\n                    };\n                case 4:\n                    return signed ? function(pointer) {\n                        return this[\"fromWireType\"](GROWABLE_HEAP_I32()[pointer >>> 2 >>> 0]);\n                    } : function(pointer) {\n                        return this[\"fromWireType\"](GROWABLE_HEAP_U32()[pointer >>> 2 >>> 0]);\n                    };\n                default:\n                    throw new TypeError(`invalid integer width (${width}): ${name}`);\n            }\n        };\n        function __embind_register_enum(rawType, name, size, isSigned) {\n            rawType >>>= 0;\n            name >>>= 0;\n            size >>>= 0;\n            name = readLatin1String(name);\n            function ctor() {}\n            ctor.values = {};\n            registerType(rawType, {\n                name: name,\n                constructor: ctor,\n                fromWireType: function(c) {\n                    return this.constructor.values[c];\n                },\n                toWireType: (destructors, c)=>c.value,\n                argPackAdvance: GenericWireTypeSize,\n                readValueFromPointer: enumReadValueFromPointer(name, size, isSigned),\n                destructorFunction: null\n            });\n            exposePublicSymbol(name, ctor);\n        }\n        var requireRegisteredType = (rawType, humanName)=>{\n            var impl = registeredTypes[rawType];\n            if (undefined === impl) throwBindingError(`${humanName} has unknown type ${getTypeName(rawType)}`);\n            return impl;\n        };\n        function __embind_register_enum_value(rawEnumType, name, enumValue) {\n            rawEnumType >>>= 0;\n            name >>>= 0;\n            var enumType = requireRegisteredType(rawEnumType, \"enum\");\n            name = readLatin1String(name);\n            var Enum = enumType.constructor;\n            var Value = Object.create(enumType.constructor.prototype, {\n                value: {\n                    value: enumValue\n                },\n                constructor: {\n                    value: createNamedFunction(`${enumType.name}_${name}`, function() {})\n                }\n            });\n            Enum.values[enumValue] = Value;\n            Enum[name] = Value;\n        }\n        var embindRepr = (v)=>{\n            if (v === null) return \"null\";\n            var t = typeof v;\n            if (t === \"object\" || t === \"array\" || t === \"function\") return v.toString();\n            else return \"\" + v;\n        };\n        var floatReadValueFromPointer = (name, width)=>{\n            switch(width){\n                case 4:\n                    return function(pointer) {\n                        return this[\"fromWireType\"](GROWABLE_HEAP_F32()[pointer >>> 2 >>> 0]);\n                    };\n                case 8:\n                    return function(pointer) {\n                        return this[\"fromWireType\"](GROWABLE_HEAP_F64()[pointer >>> 3 >>> 0]);\n                    };\n                default:\n                    throw new TypeError(`invalid float width (${width}): ${name}`);\n            }\n        };\n        var __embind_register_float = function(rawType, name, size) {\n            rawType >>>= 0;\n            name >>>= 0;\n            size >>>= 0;\n            name = readLatin1String(name);\n            registerType(rawType, {\n                name: name,\n                fromWireType: (value)=>value,\n                toWireType: (destructors, value)=>value,\n                argPackAdvance: GenericWireTypeSize,\n                readValueFromPointer: floatReadValueFromPointer(name, size),\n                destructorFunction: null\n            });\n        };\n        function __embind_register_function(name, argCount, rawArgTypesAddr, signature, rawInvoker, fn, isAsync, isNonnullReturn) {\n            name >>>= 0;\n            rawArgTypesAddr >>>= 0;\n            signature >>>= 0;\n            rawInvoker >>>= 0;\n            fn >>>= 0;\n            var argTypes = heap32VectorToArray(argCount, rawArgTypesAddr);\n            name = readLatin1String(name);\n            name = getFunctionName(name);\n            rawInvoker = embind__requireFunction(signature, rawInvoker);\n            exposePublicSymbol(name, function() {\n                throwUnboundTypeError(`Cannot call ${name} due to unbound types`, argTypes);\n            }, argCount - 1);\n            whenDependentTypesAreResolved([], argTypes, (argTypes)=>{\n                var invokerArgsArray = [\n                    argTypes[0],\n                    null\n                ].concat(argTypes.slice(1));\n                replacePublicSymbol(name, craftInvokerFunction(name, invokerArgsArray, null, rawInvoker, fn, isAsync), argCount - 1);\n                return [];\n            });\n        }\n        var integerReadValueFromPointer = (name, width, signed)=>{\n            switch(width){\n                case 1:\n                    return signed ? (pointer)=>GROWABLE_HEAP_I8()[pointer >>> 0] : (pointer)=>GROWABLE_HEAP_U8()[pointer >>> 0];\n                case 2:\n                    return signed ? (pointer)=>GROWABLE_HEAP_I16()[pointer >>> 1 >>> 0] : (pointer)=>GROWABLE_HEAP_U16()[pointer >>> 1 >>> 0];\n                case 4:\n                    return signed ? (pointer)=>GROWABLE_HEAP_I32()[pointer >>> 2 >>> 0] : (pointer)=>GROWABLE_HEAP_U32()[pointer >>> 2 >>> 0];\n                default:\n                    throw new TypeError(`invalid integer width (${width}): ${name}`);\n            }\n        };\n        function __embind_register_integer(primitiveType, name, size, minRange, maxRange) {\n            primitiveType >>>= 0;\n            name >>>= 0;\n            size >>>= 0;\n            name = readLatin1String(name);\n            if (maxRange === -1) maxRange = 4294967295;\n            var fromWireType = (value)=>value;\n            if (minRange === 0) {\n                var bitshift = 32 - 8 * size;\n                fromWireType = (value)=>value << bitshift >>> bitshift;\n            }\n            var isUnsignedType = name.includes(\"unsigned\");\n            var checkAssertions = (value, toTypeName)=>{};\n            var toWireType;\n            if (isUnsignedType) toWireType = function(destructors, value) {\n                checkAssertions(value, this.name);\n                return value >>> 0;\n            };\n            else toWireType = function(destructors, value) {\n                checkAssertions(value, this.name);\n                return value;\n            };\n            registerType(primitiveType, {\n                name: name,\n                fromWireType: fromWireType,\n                toWireType: toWireType,\n                argPackAdvance: GenericWireTypeSize,\n                readValueFromPointer: integerReadValueFromPointer(name, size, minRange !== 0),\n                destructorFunction: null\n            });\n        }\n        function __embind_register_memory_view(rawType, dataTypeIndex, name) {\n            rawType >>>= 0;\n            name >>>= 0;\n            var typeMapping = [\n                Int8Array,\n                Uint8Array,\n                Int16Array,\n                Uint16Array,\n                Int32Array,\n                Uint32Array,\n                Float32Array,\n                Float64Array\n            ];\n            var TA = typeMapping[dataTypeIndex];\n            function decodeMemoryView(handle) {\n                var size = GROWABLE_HEAP_U32()[handle >>> 2 >>> 0];\n                var data = GROWABLE_HEAP_U32()[handle + 4 >>> 2 >>> 0];\n                return new TA(GROWABLE_HEAP_I8().buffer, data, size);\n            }\n            name = readLatin1String(name);\n            registerType(rawType, {\n                name: name,\n                fromWireType: decodeMemoryView,\n                argPackAdvance: GenericWireTypeSize,\n                readValueFromPointer: decodeMemoryView\n            }, {\n                ignoreDuplicateRegistrations: true\n            });\n        }\n        var EmValOptionalType = Object.assign({\n            optional: true\n        }, EmValType);\n        function __embind_register_optional(rawOptionalType, rawType) {\n            rawOptionalType >>>= 0;\n            rawType >>>= 0;\n            registerType(rawOptionalType, EmValOptionalType);\n        }\n        var stringToUTF8 = (str, outPtr, maxBytesToWrite)=>stringToUTF8Array(str, GROWABLE_HEAP_U8(), outPtr, maxBytesToWrite);\n        function __embind_register_std_string(rawType, name) {\n            rawType >>>= 0;\n            name >>>= 0;\n            name = readLatin1String(name);\n            var stdStringIsUTF8 = name === \"std::string\";\n            registerType(rawType, {\n                name: name,\n                fromWireType (value) {\n                    var length = GROWABLE_HEAP_U32()[value >>> 2 >>> 0];\n                    var payload = value + 4;\n                    var str;\n                    if (stdStringIsUTF8) {\n                        var decodeStartPtr = payload;\n                        for(var i = 0; i <= length; ++i){\n                            var currentBytePtr = payload + i;\n                            if (i == length || GROWABLE_HEAP_U8()[currentBytePtr >>> 0] == 0) {\n                                var maxRead = currentBytePtr - decodeStartPtr;\n                                var stringSegment = UTF8ToString(decodeStartPtr, maxRead);\n                                if (str === undefined) str = stringSegment;\n                                else {\n                                    str += String.fromCharCode(0);\n                                    str += stringSegment;\n                                }\n                                decodeStartPtr = currentBytePtr + 1;\n                            }\n                        }\n                    } else {\n                        var a = new Array(length);\n                        for(var i = 0; i < length; ++i)a[i] = String.fromCharCode(GROWABLE_HEAP_U8()[payload + i >>> 0]);\n                        str = a.join(\"\");\n                    }\n                    _free(value);\n                    return str;\n                },\n                toWireType (destructors, value) {\n                    if (value instanceof ArrayBuffer) value = new Uint8Array(value);\n                    var length;\n                    var valueIsOfTypeString = typeof value == \"string\";\n                    if (!(valueIsOfTypeString || value instanceof Uint8Array || value instanceof Uint8ClampedArray || value instanceof Int8Array)) throwBindingError(\"Cannot pass non-string to std::string\");\n                    if (stdStringIsUTF8 && valueIsOfTypeString) length = lengthBytesUTF8(value);\n                    else length = value.length;\n                    var base = _malloc(4 + length + 1);\n                    var ptr = base + 4;\n                    GROWABLE_HEAP_U32()[base >>> 2 >>> 0] = length;\n                    if (stdStringIsUTF8 && valueIsOfTypeString) stringToUTF8(value, ptr, length + 1);\n                    else {\n                        if (valueIsOfTypeString) for(var i = 0; i < length; ++i){\n                            var charCode = value.charCodeAt(i);\n                            if (charCode > 255) {\n                                _free(ptr);\n                                throwBindingError(\"String has UTF-16 code units that do not fit in 8 bits\");\n                            }\n                            GROWABLE_HEAP_U8()[ptr + i >>> 0] = charCode;\n                        }\n                        else for(var i = 0; i < length; ++i)GROWABLE_HEAP_U8()[ptr + i >>> 0] = value[i];\n                    }\n                    if (destructors !== null) destructors.push(_free, base);\n                    return base;\n                },\n                argPackAdvance: GenericWireTypeSize,\n                readValueFromPointer: readPointer,\n                destructorFunction (ptr) {\n                    _free(ptr);\n                }\n            });\n        }\n        var UTF16Decoder = typeof TextDecoder != \"undefined\" ? new TextDecoder(\"utf-16le\") : undefined;\n        var UTF16ToString = (ptr, maxBytesToRead)=>{\n            var endPtr = ptr;\n            var idx = endPtr >> 1;\n            var maxIdx = idx + maxBytesToRead / 2;\n            while(!(idx >= maxIdx) && GROWABLE_HEAP_U16()[idx >>> 0])++idx;\n            endPtr = idx << 1;\n            if (endPtr - ptr > 32 && UTF16Decoder) return UTF16Decoder.decode(GROWABLE_HEAP_U8().slice(ptr, endPtr));\n            var str = \"\";\n            for(var i = 0; !(i >= maxBytesToRead / 2); ++i){\n                var codeUnit = GROWABLE_HEAP_I16()[ptr + i * 2 >>> 1 >>> 0];\n                if (codeUnit == 0) break;\n                str += String.fromCharCode(codeUnit);\n            }\n            return str;\n        };\n        var stringToUTF16 = (str, outPtr, maxBytesToWrite)=>{\n            maxBytesToWrite ??= 2147483647;\n            if (maxBytesToWrite < 2) return 0;\n            maxBytesToWrite -= 2;\n            var startPtr = outPtr;\n            var numCharsToWrite = maxBytesToWrite < str.length * 2 ? maxBytesToWrite / 2 : str.length;\n            for(var i = 0; i < numCharsToWrite; ++i){\n                var codeUnit = str.charCodeAt(i);\n                GROWABLE_HEAP_I16()[outPtr >>> 1 >>> 0] = codeUnit;\n                outPtr += 2;\n            }\n            GROWABLE_HEAP_I16()[outPtr >>> 1 >>> 0] = 0;\n            return outPtr - startPtr;\n        };\n        var lengthBytesUTF16 = (str)=>str.length * 2;\n        var UTF32ToString = (ptr, maxBytesToRead)=>{\n            var i = 0;\n            var str = \"\";\n            while(!(i >= maxBytesToRead / 4)){\n                var utf32 = GROWABLE_HEAP_I32()[ptr + i * 4 >>> 2 >>> 0];\n                if (utf32 == 0) break;\n                ++i;\n                if (utf32 >= 65536) {\n                    var ch = utf32 - 65536;\n                    str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);\n                } else str += String.fromCharCode(utf32);\n            }\n            return str;\n        };\n        var stringToUTF32 = (str, outPtr, maxBytesToWrite)=>{\n            outPtr >>>= 0;\n            maxBytesToWrite ??= 2147483647;\n            if (maxBytesToWrite < 4) return 0;\n            var startPtr = outPtr;\n            var endPtr = startPtr + maxBytesToWrite - 4;\n            for(var i = 0; i < str.length; ++i){\n                var codeUnit = str.charCodeAt(i);\n                if (codeUnit >= 55296 && codeUnit <= 57343) {\n                    var trailSurrogate = str.charCodeAt(++i);\n                    codeUnit = 65536 + ((codeUnit & 1023) << 10) | trailSurrogate & 1023;\n                }\n                GROWABLE_HEAP_I32()[outPtr >>> 2 >>> 0] = codeUnit;\n                outPtr += 4;\n                if (outPtr + 4 > endPtr) break;\n            }\n            GROWABLE_HEAP_I32()[outPtr >>> 2 >>> 0] = 0;\n            return outPtr - startPtr;\n        };\n        var lengthBytesUTF32 = (str)=>{\n            var len = 0;\n            for(var i = 0; i < str.length; ++i){\n                var codeUnit = str.charCodeAt(i);\n                if (codeUnit >= 55296 && codeUnit <= 57343) ++i;\n                len += 4;\n            }\n            return len;\n        };\n        var __embind_register_std_wstring = function(rawType, charSize, name) {\n            rawType >>>= 0;\n            charSize >>>= 0;\n            name >>>= 0;\n            name = readLatin1String(name);\n            var decodeString, encodeString, readCharAt, lengthBytesUTF;\n            if (charSize === 2) {\n                decodeString = UTF16ToString;\n                encodeString = stringToUTF16;\n                lengthBytesUTF = lengthBytesUTF16;\n                readCharAt = (pointer)=>GROWABLE_HEAP_U16()[pointer >>> 1 >>> 0];\n            } else if (charSize === 4) {\n                decodeString = UTF32ToString;\n                encodeString = stringToUTF32;\n                lengthBytesUTF = lengthBytesUTF32;\n                readCharAt = (pointer)=>GROWABLE_HEAP_U32()[pointer >>> 2 >>> 0];\n            }\n            registerType(rawType, {\n                name: name,\n                fromWireType: (value)=>{\n                    var length = GROWABLE_HEAP_U32()[value >>> 2 >>> 0];\n                    var str;\n                    var decodeStartPtr = value + 4;\n                    for(var i = 0; i <= length; ++i){\n                        var currentBytePtr = value + 4 + i * charSize;\n                        if (i == length || readCharAt(currentBytePtr) == 0) {\n                            var maxReadBytes = currentBytePtr - decodeStartPtr;\n                            var stringSegment = decodeString(decodeStartPtr, maxReadBytes);\n                            if (str === undefined) str = stringSegment;\n                            else {\n                                str += String.fromCharCode(0);\n                                str += stringSegment;\n                            }\n                            decodeStartPtr = currentBytePtr + charSize;\n                        }\n                    }\n                    _free(value);\n                    return str;\n                },\n                toWireType: (destructors, value)=>{\n                    if (!(typeof value == \"string\")) throwBindingError(`Cannot pass non-string to C++ string type ${name}`);\n                    var length = lengthBytesUTF(value);\n                    var ptr = _malloc(4 + length + charSize);\n                    GROWABLE_HEAP_U32()[ptr >>> 2 >>> 0] = length / charSize;\n                    encodeString(value, ptr + 4, length + charSize);\n                    if (destructors !== null) destructors.push(_free, ptr);\n                    return ptr;\n                },\n                argPackAdvance: GenericWireTypeSize,\n                readValueFromPointer: readPointer,\n                destructorFunction (ptr) {\n                    _free(ptr);\n                }\n            });\n        };\n        function __embind_register_value_array(rawType, name, constructorSignature, rawConstructor, destructorSignature, rawDestructor) {\n            rawType >>>= 0;\n            name >>>= 0;\n            constructorSignature >>>= 0;\n            rawConstructor >>>= 0;\n            destructorSignature >>>= 0;\n            rawDestructor >>>= 0;\n            tupleRegistrations[rawType] = {\n                name: readLatin1String(name),\n                rawConstructor: embind__requireFunction(constructorSignature, rawConstructor),\n                rawDestructor: embind__requireFunction(destructorSignature, rawDestructor),\n                elements: []\n            };\n        }\n        function __embind_register_value_array_element(rawTupleType, getterReturnType, getterSignature, getter, getterContext, setterArgumentType, setterSignature, setter, setterContext) {\n            rawTupleType >>>= 0;\n            getterReturnType >>>= 0;\n            getterSignature >>>= 0;\n            getter >>>= 0;\n            getterContext >>>= 0;\n            setterArgumentType >>>= 0;\n            setterSignature >>>= 0;\n            setter >>>= 0;\n            setterContext >>>= 0;\n            tupleRegistrations[rawTupleType].elements.push({\n                getterReturnType: getterReturnType,\n                getter: embind__requireFunction(getterSignature, getter),\n                getterContext: getterContext,\n                setterArgumentType: setterArgumentType,\n                setter: embind__requireFunction(setterSignature, setter),\n                setterContext: setterContext\n            });\n        }\n        function __embind_register_value_object(rawType, name, constructorSignature, rawConstructor, destructorSignature, rawDestructor) {\n            rawType >>>= 0;\n            name >>>= 0;\n            constructorSignature >>>= 0;\n            rawConstructor >>>= 0;\n            destructorSignature >>>= 0;\n            rawDestructor >>>= 0;\n            structRegistrations[rawType] = {\n                name: readLatin1String(name),\n                rawConstructor: embind__requireFunction(constructorSignature, rawConstructor),\n                rawDestructor: embind__requireFunction(destructorSignature, rawDestructor),\n                fields: []\n            };\n        }\n        function __embind_register_value_object_field(structType, fieldName, getterReturnType, getterSignature, getter, getterContext, setterArgumentType, setterSignature, setter, setterContext) {\n            structType >>>= 0;\n            fieldName >>>= 0;\n            getterReturnType >>>= 0;\n            getterSignature >>>= 0;\n            getter >>>= 0;\n            getterContext >>>= 0;\n            setterArgumentType >>>= 0;\n            setterSignature >>>= 0;\n            setter >>>= 0;\n            setterContext >>>= 0;\n            structRegistrations[structType].fields.push({\n                fieldName: readLatin1String(fieldName),\n                getterReturnType: getterReturnType,\n                getter: embind__requireFunction(getterSignature, getter),\n                getterContext: getterContext,\n                setterArgumentType: setterArgumentType,\n                setter: embind__requireFunction(setterSignature, setter),\n                setterContext: setterContext\n            });\n        }\n        var __embind_register_void = function(rawType, name) {\n            rawType >>>= 0;\n            name >>>= 0;\n            name = readLatin1String(name);\n            registerType(rawType, {\n                isVoid: true,\n                name: name,\n                argPackAdvance: 0,\n                fromWireType: ()=>undefined,\n                toWireType: (destructors, o)=>undefined\n            });\n        };\n        function __emscripten_init_main_thread_js(tb) {\n            tb >>>= 0;\n            __emscripten_thread_init(tb, !ENVIRONMENT_IS_WORKER, 1, !ENVIRONMENT_IS_WEB, 5242880, false);\n            PThread.threadInitTLS();\n        }\n        var maybeExit = ()=>{\n            if (!keepRuntimeAlive()) try {\n                if (ENVIRONMENT_IS_PTHREAD) __emscripten_thread_exit(EXITSTATUS);\n                else _exit(EXITSTATUS);\n            } catch (e) {\n                handleException(e);\n            }\n        };\n        var callUserCallback = (func)=>{\n            if (ABORT) return;\n            try {\n                func();\n                maybeExit();\n            } catch (e) {\n                handleException(e);\n            }\n        };\n        function __emscripten_thread_mailbox_await(pthread_ptr) {\n            pthread_ptr >>>= 0;\n            if (typeof Atomics.waitAsync === \"function\") {\n                var wait = Atomics.waitAsync(GROWABLE_HEAP_I32(), pthread_ptr >>> 2, pthread_ptr);\n                wait.value.then(checkMailbox);\n                var waitingAsync = pthread_ptr + 128;\n                Atomics.store(GROWABLE_HEAP_I32(), waitingAsync >>> 2, 1);\n            }\n        }\n        var checkMailbox = ()=>{\n            var pthread_ptr = _pthread_self();\n            if (pthread_ptr) {\n                __emscripten_thread_mailbox_await(pthread_ptr);\n                callUserCallback(__emscripten_check_mailbox);\n            }\n        };\n        function __emscripten_notify_mailbox_postmessage(targetThread, currThreadId) {\n            targetThread >>>= 0;\n            currThreadId >>>= 0;\n            if (targetThread == currThreadId) setTimeout(checkMailbox);\n            else if (ENVIRONMENT_IS_PTHREAD) postMessage({\n                targetThread: targetThread,\n                cmd: \"checkMailbox\"\n            });\n            else {\n                var worker = PThread.pthreads[targetThread];\n                if (!worker) return;\n                worker.postMessage({\n                    cmd: \"checkMailbox\"\n                });\n            }\n        }\n        var proxiedJSCallArgs = [];\n        function __emscripten_receive_on_main_thread_js(funcIndex, emAsmAddr, callingThread, numCallArgs, args) {\n            emAsmAddr >>>= 0;\n            callingThread >>>= 0;\n            args >>>= 0;\n            proxiedJSCallArgs.length = numCallArgs;\n            var b = args >>> 3;\n            for(var i = 0; i < numCallArgs; i++)proxiedJSCallArgs[i] = GROWABLE_HEAP_F64()[b + i >>> 0];\n            var func = emAsmAddr ? ASM_CONSTS[emAsmAddr] : proxiedFunctionTable[funcIndex];\n            PThread.currentProxiedOperationCallerThread = callingThread;\n            var rtn = func(...proxiedJSCallArgs);\n            PThread.currentProxiedOperationCallerThread = 0;\n            return rtn;\n        }\n        var __emscripten_runtime_keepalive_clear = ()=>{\n            noExitRuntime = false;\n            runtimeKeepaliveCounter = 0;\n        };\n        function __emscripten_thread_cleanup(thread) {\n            thread >>>= 0;\n            if (!ENVIRONMENT_IS_PTHREAD) cleanupThread(thread);\n            else postMessage({\n                cmd: \"cleanupThread\",\n                thread: thread\n            });\n        }\n        function __emscripten_thread_set_strongref(thread) {\n            thread >>>= 0;\n        }\n        var emval_returnValue = (returnType, destructorsRef, handle)=>{\n            var destructors = [];\n            var result = returnType[\"toWireType\"](destructors, handle);\n            if (destructors.length) GROWABLE_HEAP_U32()[destructorsRef >>> 2 >>> 0] = Emval.toHandle(destructors);\n            return result;\n        };\n        function __emval_as(handle, returnType, destructorsRef) {\n            handle >>>= 0;\n            returnType >>>= 0;\n            destructorsRef >>>= 0;\n            handle = Emval.toValue(handle);\n            returnType = requireRegisteredType(returnType, \"emval::as\");\n            return emval_returnValue(returnType, destructorsRef, handle);\n        }\n        function __emval_get_property(handle, key) {\n            handle >>>= 0;\n            key >>>= 0;\n            handle = Emval.toValue(handle);\n            key = Emval.toValue(key);\n            return Emval.toHandle(handle[key]);\n        }\n        function __emval_new_array() {\n            return Emval.toHandle([]);\n        }\n        function __emval_run_destructors(handle) {\n            handle >>>= 0;\n            var destructors = Emval.toValue(handle);\n            runDestructors(destructors);\n            __emval_decref(handle);\n        }\n        function __emval_set_property(handle, key, value) {\n            handle >>>= 0;\n            key >>>= 0;\n            value >>>= 0;\n            handle = Emval.toValue(handle);\n            key = Emval.toValue(key);\n            value = Emval.toValue(value);\n            handle[key] = value;\n        }\n        function __emval_take_value(type, arg) {\n            type >>>= 0;\n            arg >>>= 0;\n            type = requireRegisteredType(type, \"_emval_take_value\");\n            var v = type[\"readValueFromPointer\"](arg);\n            return Emval.toHandle(v);\n        }\n        var timers = {};\n        var _emscripten_get_now = ()=>performance.timeOrigin + performance.now();\n        function __setitimer_js(which, timeout_ms) {\n            if (ENVIRONMENT_IS_PTHREAD) return proxyToMainThread(6, 0, 1, which, timeout_ms);\n            if (timers[which]) {\n                clearTimeout(timers[which].id);\n                delete timers[which];\n            }\n            if (!timeout_ms) return 0;\n            var id = setTimeout(()=>{\n                delete timers[which];\n                callUserCallback(()=>__emscripten_timeout(which, _emscripten_get_now()));\n            }, timeout_ms);\n            timers[which] = {\n                id: id,\n                timeout_ms: timeout_ms\n            };\n            return 0;\n        }\n        var __tzset_js = function(timezone, daylight, std_name, dst_name) {\n            timezone >>>= 0;\n            daylight >>>= 0;\n            std_name >>>= 0;\n            dst_name >>>= 0;\n            var currentYear = (new Date).getFullYear();\n            var winter = new Date(currentYear, 0, 1);\n            var summer = new Date(currentYear, 6, 1);\n            var winterOffset = winter.getTimezoneOffset();\n            var summerOffset = summer.getTimezoneOffset();\n            var stdTimezoneOffset = Math.max(winterOffset, summerOffset);\n            GROWABLE_HEAP_U32()[timezone >>> 2 >>> 0] = stdTimezoneOffset * 60;\n            GROWABLE_HEAP_I32()[daylight >>> 2 >>> 0] = Number(winterOffset != summerOffset);\n            var extractZone = (timezoneOffset)=>{\n                var sign = timezoneOffset >= 0 ? \"-\" : \"+\";\n                var absOffset = Math.abs(timezoneOffset);\n                var hours = String(Math.floor(absOffset / 60)).padStart(2, \"0\");\n                var minutes = String(absOffset % 60).padStart(2, \"0\");\n                return `UTC${sign}${hours}${minutes}`;\n            };\n            var winterName = extractZone(winterOffset);\n            var summerName = extractZone(summerOffset);\n            if (summerOffset < winterOffset) {\n                stringToUTF8(winterName, std_name, 17);\n                stringToUTF8(summerName, dst_name, 17);\n            } else {\n                stringToUTF8(winterName, dst_name, 17);\n                stringToUTF8(summerName, std_name, 17);\n            }\n        };\n        var readEmAsmArgsArray = [];\n        var readEmAsmArgs = (sigPtr, buf)=>{\n            readEmAsmArgsArray.length = 0;\n            var ch;\n            while(ch = GROWABLE_HEAP_U8()[sigPtr++ >>> 0]){\n                var wide = ch != 105;\n                wide &= ch != 112;\n                buf += wide && buf % 8 ? 4 : 0;\n                readEmAsmArgsArray.push(ch == 112 ? GROWABLE_HEAP_U32()[buf >>> 2 >>> 0] : ch == 105 ? GROWABLE_HEAP_I32()[buf >>> 2 >>> 0] : GROWABLE_HEAP_F64()[buf >>> 3 >>> 0]);\n                buf += wide ? 8 : 4;\n            }\n            return readEmAsmArgsArray;\n        };\n        var runEmAsmFunction = (code, sigPtr, argbuf)=>{\n            var args = readEmAsmArgs(sigPtr, argbuf);\n            return ASM_CONSTS[code](...args);\n        };\n        function _emscripten_asm_const_int(code, sigPtr, argbuf) {\n            code >>>= 0;\n            sigPtr >>>= 0;\n            argbuf >>>= 0;\n            return runEmAsmFunction(code, sigPtr, argbuf);\n        }\n        var warnOnce = (text)=>{\n            warnOnce.shown ||= {};\n            if (!warnOnce.shown[text]) {\n                warnOnce.shown[text] = 1;\n                err(text);\n            }\n        };\n        var _emscripten_check_blocking_allowed = ()=>{};\n        var _emscripten_date_now = ()=>Date.now();\n        var runtimeKeepalivePush = ()=>{\n            runtimeKeepaliveCounter += 1;\n        };\n        var _emscripten_exit_with_live_runtime = ()=>{\n            runtimeKeepalivePush();\n            throw \"unwind\";\n        };\n        var _emscripten_num_logical_cores = ()=>navigator[\"hardwareConcurrency\"];\n        var getHeapMax = ()=>4294901760;\n        var growMemory = (size)=>{\n            var b = wasmMemory.buffer;\n            var pages = (size - b.byteLength + 65535) / 65536 | 0;\n            try {\n                wasmMemory.grow(pages);\n                updateMemoryViews();\n                return 1;\n            } catch (e) {}\n        };\n        function _emscripten_resize_heap(requestedSize) {\n            requestedSize >>>= 0;\n            var oldSize = GROWABLE_HEAP_U8().length;\n            if (requestedSize <= oldSize) return false;\n            var maxHeapSize = getHeapMax();\n            if (requestedSize > maxHeapSize) return false;\n            for(var cutDown = 1; cutDown <= 4; cutDown *= 2){\n                var overGrownHeapSize = oldSize * (1 + .2 / cutDown);\n                overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);\n                var newSize = Math.min(maxHeapSize, alignMemory(Math.max(requestedSize, overGrownHeapSize), 65536));\n                var replacement = growMemory(newSize);\n                if (replacement) return true;\n            }\n            return false;\n        }\n        var ENV = {};\n        var getExecutableName = ()=>thisProgram || \"./this.program\";\n        var getEnvStrings = ()=>{\n            if (!getEnvStrings.strings) {\n                var lang = (typeof navigator == \"object\" && navigator.languages && navigator.languages[0] || \"C\").replace(\"-\", \"_\") + \".UTF-8\";\n                var env = {\n                    USER: \"web_user\",\n                    LOGNAME: \"web_user\",\n                    PATH: \"/\",\n                    PWD: \"/\",\n                    HOME: \"/home/web_user\",\n                    LANG: lang,\n                    _: getExecutableName()\n                };\n                for(var x in ENV)if (ENV[x] === undefined) delete env[x];\n                else env[x] = ENV[x];\n                var strings = [];\n                for(var x in env)strings.push(`${x}=${env[x]}`);\n                getEnvStrings.strings = strings;\n            }\n            return getEnvStrings.strings;\n        };\n        var stringToAscii = (str, buffer)=>{\n            for(var i = 0; i < str.length; ++i)GROWABLE_HEAP_I8()[buffer++ >>> 0] = str.charCodeAt(i);\n            GROWABLE_HEAP_I8()[buffer >>> 0] = 0;\n        };\n        var _environ_get = function(__environ, environ_buf) {\n            if (ENVIRONMENT_IS_PTHREAD) return proxyToMainThread(7, 0, 1, __environ, environ_buf);\n            __environ >>>= 0;\n            environ_buf >>>= 0;\n            var bufSize = 0;\n            getEnvStrings().forEach((string, i)=>{\n                var ptr = environ_buf + bufSize;\n                GROWABLE_HEAP_U32()[__environ + i * 4 >>> 2 >>> 0] = ptr;\n                stringToAscii(string, ptr);\n                bufSize += string.length + 1;\n            });\n            return 0;\n        };\n        var _environ_sizes_get = function(penviron_count, penviron_buf_size) {\n            if (ENVIRONMENT_IS_PTHREAD) return proxyToMainThread(8, 0, 1, penviron_count, penviron_buf_size);\n            penviron_count >>>= 0;\n            penviron_buf_size >>>= 0;\n            var strings = getEnvStrings();\n            GROWABLE_HEAP_U32()[penviron_count >>> 2 >>> 0] = strings.length;\n            var bufSize = 0;\n            strings.forEach((string)=>bufSize += string.length + 1);\n            GROWABLE_HEAP_U32()[penviron_buf_size >>> 2 >>> 0] = bufSize;\n            return 0;\n        };\n        function _fd_close(fd) {\n            if (ENVIRONMENT_IS_PTHREAD) return proxyToMainThread(9, 0, 1, fd);\n            try {\n                var stream = SYSCALLS.getStreamFromFD(fd);\n                FS.close(stream);\n                return 0;\n            } catch (e) {\n                if (typeof FS == \"undefined\" || !(e.name === \"ErrnoError\")) throw e;\n                return e.errno;\n            }\n        }\n        var doReadv = (stream, iov, iovcnt, offset)=>{\n            var ret = 0;\n            for(var i = 0; i < iovcnt; i++){\n                var ptr = GROWABLE_HEAP_U32()[iov >>> 2 >>> 0];\n                var len = GROWABLE_HEAP_U32()[iov + 4 >>> 2 >>> 0];\n                iov += 8;\n                var curr = FS.read(stream, GROWABLE_HEAP_I8(), ptr, len, offset);\n                if (curr < 0) return -1;\n                ret += curr;\n                if (curr < len) break;\n                if (typeof offset != \"undefined\") offset += curr;\n            }\n            return ret;\n        };\n        function _fd_read(fd, iov, iovcnt, pnum) {\n            if (ENVIRONMENT_IS_PTHREAD) return proxyToMainThread(10, 0, 1, fd, iov, iovcnt, pnum);\n            iov >>>= 0;\n            iovcnt >>>= 0;\n            pnum >>>= 0;\n            try {\n                var stream = SYSCALLS.getStreamFromFD(fd);\n                var num = doReadv(stream, iov, iovcnt);\n                GROWABLE_HEAP_U32()[pnum >>> 2 >>> 0] = num;\n                return 0;\n            } catch (e) {\n                if (typeof FS == \"undefined\" || !(e.name === \"ErrnoError\")) throw e;\n                return e.errno;\n            }\n        }\n        function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {\n            if (ENVIRONMENT_IS_PTHREAD) return proxyToMainThread(11, 0, 1, fd, offset_low, offset_high, whence, newOffset);\n            var offset = convertI32PairToI53Checked(offset_low, offset_high);\n            newOffset >>>= 0;\n            try {\n                if (isNaN(offset)) return 61;\n                var stream = SYSCALLS.getStreamFromFD(fd);\n                FS.llseek(stream, offset, whence);\n                tempI64 = [\n                    stream.position >>> 0,\n                    (tempDouble = stream.position, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)\n                ], GROWABLE_HEAP_I32()[newOffset >>> 2 >>> 0] = tempI64[0], GROWABLE_HEAP_I32()[newOffset + 4 >>> 2 >>> 0] = tempI64[1];\n                if (stream.getdents && offset === 0 && whence === 0) stream.getdents = null;\n                return 0;\n            } catch (e) {\n                if (typeof FS == \"undefined\" || !(e.name === \"ErrnoError\")) throw e;\n                return e.errno;\n            }\n        }\n        var doWritev = (stream, iov, iovcnt, offset)=>{\n            var ret = 0;\n            for(var i = 0; i < iovcnt; i++){\n                var ptr = GROWABLE_HEAP_U32()[iov >>> 2 >>> 0];\n                var len = GROWABLE_HEAP_U32()[iov + 4 >>> 2 >>> 0];\n                iov += 8;\n                var curr = FS.write(stream, GROWABLE_HEAP_I8(), ptr, len, offset);\n                if (curr < 0) return -1;\n                ret += curr;\n                if (curr < len) break;\n                if (typeof offset != \"undefined\") offset += curr;\n            }\n            return ret;\n        };\n        function _fd_write(fd, iov, iovcnt, pnum) {\n            if (ENVIRONMENT_IS_PTHREAD) return proxyToMainThread(12, 0, 1, fd, iov, iovcnt, pnum);\n            iov >>>= 0;\n            iovcnt >>>= 0;\n            pnum >>>= 0;\n            try {\n                var stream = SYSCALLS.getStreamFromFD(fd);\n                var num = doWritev(stream, iov, iovcnt);\n                GROWABLE_HEAP_U32()[pnum >>> 2 >>> 0] = num;\n                return 0;\n            } catch (e) {\n                if (typeof FS == \"undefined\" || !(e.name === \"ErrnoError\")) throw e;\n                return e.errno;\n            }\n        }\n        function _llvm_eh_typeid_for(type) {\n            type >>>= 0;\n            return type;\n        }\n        var FS_createPath = FS.createPath;\n        var FS_unlink = (path)=>FS.unlink(path);\n        var FS_createLazyFile = FS.createLazyFile;\n        var FS_createDevice = FS.createDevice;\n        PThread.init();\n        FS.createPreloadedFile = FS_createPreloadedFile;\n        FS.staticInit();\n        Module[\"FS_createPath\"] = FS.createPath;\n        Module[\"FS_createDataFile\"] = FS.createDataFile;\n        Module[\"FS_createPreloadedFile\"] = FS.createPreloadedFile;\n        Module[\"FS_unlink\"] = FS.unlink;\n        Module[\"FS_createLazyFile\"] = FS.createLazyFile;\n        Module[\"FS_createDevice\"] = FS.createDevice;\n        MEMFS.doesNotExistError = new FS.ErrnoError(44);\n        MEMFS.doesNotExistError.stack = \"<generic error, no stack>\";\n        InternalError = Module[\"InternalError\"] = class InternalError extends Error {\n            constructor(message){\n                super(message);\n                this.name = \"InternalError\";\n            }\n        };\n        embind_init_charCodes();\n        BindingError = Module[\"BindingError\"] = class BindingError extends Error {\n            constructor(message){\n                super(message);\n                this.name = \"BindingError\";\n            }\n        };\n        init_ClassHandle();\n        init_RegisteredPointer();\n        UnboundTypeError = Module[\"UnboundTypeError\"] = extendError(Error, \"UnboundTypeError\");\n        init_emval();\n        var proxiedFunctionTable = [\n            _proc_exit,\n            exitOnMainThread,\n            pthreadCreateProxied,\n            ___syscall_fcntl64,\n            ___syscall_ioctl,\n            ___syscall_openat,\n            __setitimer_js,\n            _environ_get,\n            _environ_sizes_get,\n            _fd_close,\n            _fd_read,\n            _fd_seek,\n            _fd_write\n        ];\n        var wasmImports;\n        function assignWasmImports() {\n            wasmImports = {\n                x: ___cxa_begin_catch,\n                H: ___cxa_end_catch,\n                b: ___cxa_find_matching_catch_2,\n                l: ___cxa_find_matching_catch_3,\n                ha: ___cxa_find_matching_catch_4,\n                W: ___cxa_rethrow,\n                D: ___cxa_throw,\n                oa: ___cxa_uncaught_exceptions,\n                va: ___pthread_create_js,\n                d: ___resumeException,\n                Z: ___syscall_fcntl64,\n                ma: ___syscall_ioctl,\n                na: ___syscall_openat,\n                pa: __abort_js,\n                Oa: __embind_finalize_value_array,\n                Sa: __embind_finalize_value_object,\n                cb: __embind_register_bigint,\n                Da: __embind_register_bool,\n                v: __embind_register_class,\n                u: __embind_register_class_constructor,\n                o: __embind_register_class_function,\n                y: __embind_register_class_property,\n                Ca: __embind_register_emval,\n                Ra: __embind_register_enum,\n                X: __embind_register_enum_value,\n                ca: __embind_register_float,\n                p: __embind_register_function,\n                I: __embind_register_integer,\n                B: __embind_register_memory_view,\n                A: __embind_register_optional,\n                da: __embind_register_std_string,\n                R: __embind_register_std_wstring,\n                Qa: __embind_register_value_array,\n                Pa: __embind_register_value_array_element,\n                s: __embind_register_value_object,\n                Ta: __embind_register_value_object_field,\n                Ea: __embind_register_void,\n                xa: __emscripten_init_main_thread_js,\n                ra: __emscripten_notify_mailbox_postmessage,\n                ya: __emscripten_receive_on_main_thread_js,\n                hb: __emscripten_runtime_keepalive_clear,\n                _: __emscripten_thread_cleanup,\n                wa: __emscripten_thread_mailbox_await,\n                Aa: __emscripten_thread_set_strongref,\n                Va: __emval_as,\n                mb: __emval_decref,\n                Wa: __emval_get_property,\n                ea: __emval_new_array,\n                Ua: __emval_run_destructors,\n                sa: __emval_set_property,\n                w: __emval_take_value,\n                ib: __setitimer_js,\n                kb: __tzset_js,\n                S: _emscripten_asm_const_int,\n                $: _emscripten_check_blocking_allowed,\n                Ba: _emscripten_date_now,\n                za: _emscripten_exit_with_live_runtime,\n                K: _emscripten_get_now,\n                jb: _emscripten_num_logical_cores,\n                qa: _emscripten_resize_heap,\n                lb: _environ_get,\n                ka: _environ_sizes_get,\n                ua: _exit,\n                Y: _fd_close,\n                la: _fd_read,\n                Ya: _fd_seek,\n                ta: _fd_write,\n                Ja: invoke_diiddddiiid,\n                E: invoke_diii,\n                ba: invoke_fiiif,\n                Fa: invoke_i,\n                c: invoke_ii,\n                z: invoke_iid,\n                e: invoke_iii,\n                m: invoke_iiii,\n                ga: invoke_iiiid,\n                n: invoke_iiiii,\n                fb: invoke_iiiiid,\n                aa: invoke_iiiiif,\n                t: invoke_iiiiii,\n                F: invoke_iiiiiii,\n                fa: invoke_iiiiiiii,\n                Q: invoke_iiiiiiiiiiii,\n                Xa: invoke_iij,\n                $a: invoke_iiji,\n                _a: invoke_iji,\n                db: invoke_ji,\n                Za: invoke_jii,\n                bb: invoke_jiiii,\n                i: invoke_v,\n                f: invoke_vi,\n                Ma: invoke_vidddddddi,\n                La: invoke_viddddddi,\n                ja: invoke_viddddidi,\n                ia: invoke_vidddidddi,\n                O: invoke_viddi,\n                L: invoke_viddiiddii,\n                Ia: invoke_vidiidiii,\n                J: invoke_vidiiii,\n                g: invoke_vii,\n                T: invoke_viidd,\n                h: invoke_viii,\n                U: invoke_viiid,\n                Ka: invoke_viiidddi,\n                M: invoke_viiidii,\n                j: invoke_viiii,\n                Ga: invoke_viiiid,\n                q: invoke_viiiii,\n                V: invoke_viiiiid,\n                r: invoke_viiiiii,\n                Ha: invoke_viiiiiidd,\n                G: invoke_viiiiiii,\n                Na: invoke_viiiiiiii,\n                C: invoke_viiiiiiiii,\n                k: invoke_viiiiiiiiii,\n                P: invoke_viiiiiiiiiiiiiii,\n                eb: invoke_viiiiiijj,\n                ab: invoke_vij,\n                N: _llvm_eh_typeid_for,\n                a: wasmMemory,\n                gb: _proc_exit\n            };\n        }\n        var wasmExports = createWasm();\n        var ___wasm_call_ctors = ()=>(___wasm_call_ctors = wasmExports[\"nb\"])();\n        var _pthread_self = ()=>(_pthread_self = wasmExports[\"ob\"])();\n        var _malloc = Module[\"_malloc\"] = (a0)=>(_malloc = Module[\"_malloc\"] = wasmExports[\"qb\"])(a0);\n        var ___getTypeName = (a0)=>(___getTypeName = wasmExports[\"rb\"])(a0);\n        var __embind_initialize_bindings = ()=>(__embind_initialize_bindings = wasmExports[\"sb\"])();\n        var _free = Module[\"_free\"] = (a0)=>(_free = Module[\"_free\"] = wasmExports[\"tb\"])(a0);\n        var __emscripten_tls_init = ()=>(__emscripten_tls_init = wasmExports[\"ub\"])();\n        var __emscripten_thread_init = (a0, a1, a2, a3, a4, a5)=>(__emscripten_thread_init = wasmExports[\"vb\"])(a0, a1, a2, a3, a4, a5);\n        var __emscripten_thread_crashed = ()=>(__emscripten_thread_crashed = wasmExports[\"wb\"])();\n        var __emscripten_run_on_main_thread_js = (a0, a1, a2, a3, a4)=>(__emscripten_run_on_main_thread_js = wasmExports[\"xb\"])(a0, a1, a2, a3, a4);\n        var __emscripten_thread_free_data = (a0)=>(__emscripten_thread_free_data = wasmExports[\"yb\"])(a0);\n        var __emscripten_thread_exit = (a0)=>(__emscripten_thread_exit = wasmExports[\"zb\"])(a0);\n        var __emscripten_timeout = (a0, a1)=>(__emscripten_timeout = wasmExports[\"Ab\"])(a0, a1);\n        var __emscripten_check_mailbox = ()=>(__emscripten_check_mailbox = wasmExports[\"Bb\"])();\n        var _setThrew = (a0, a1)=>(_setThrew = wasmExports[\"Cb\"])(a0, a1);\n        var __emscripten_tempret_set = (a0)=>(__emscripten_tempret_set = wasmExports[\"Db\"])(a0);\n        var _emscripten_stack_set_limits = (a0, a1)=>(_emscripten_stack_set_limits = wasmExports[\"Eb\"])(a0, a1);\n        var __emscripten_stack_restore = (a0)=>(__emscripten_stack_restore = wasmExports[\"Fb\"])(a0);\n        var __emscripten_stack_alloc = (a0)=>(__emscripten_stack_alloc = wasmExports[\"Gb\"])(a0);\n        var _emscripten_stack_get_current = ()=>(_emscripten_stack_get_current = wasmExports[\"Hb\"])();\n        var ___cxa_decrement_exception_refcount = (a0)=>(___cxa_decrement_exception_refcount = wasmExports[\"Ib\"])(a0);\n        var ___cxa_increment_exception_refcount = (a0)=>(___cxa_increment_exception_refcount = wasmExports[\"Jb\"])(a0);\n        var ___cxa_can_catch = (a0, a1, a2)=>(___cxa_can_catch = wasmExports[\"Kb\"])(a0, a1, a2);\n        var ___cxa_get_exception_ptr = (a0)=>(___cxa_get_exception_ptr = wasmExports[\"Lb\"])(a0);\n        var dynCall_viiiiiijj = Module[\"dynCall_viiiiiijj\"] = (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10)=>(dynCall_viiiiiijj = Module[\"dynCall_viiiiiijj\"] = wasmExports[\"Mb\"])(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);\n        var dynCall_ji = Module[\"dynCall_ji\"] = (a0, a1)=>(dynCall_ji = Module[\"dynCall_ji\"] = wasmExports[\"Nb\"])(a0, a1);\n        var dynCall_jiiii = Module[\"dynCall_jiiii\"] = (a0, a1, a2, a3, a4)=>(dynCall_jiiii = Module[\"dynCall_jiiii\"] = wasmExports[\"Ob\"])(a0, a1, a2, a3, a4);\n        var dynCall_vij = Module[\"dynCall_vij\"] = (a0, a1, a2, a3)=>(dynCall_vij = Module[\"dynCall_vij\"] = wasmExports[\"Pb\"])(a0, a1, a2, a3);\n        var dynCall_iiji = Module[\"dynCall_iiji\"] = (a0, a1, a2, a3, a4)=>(dynCall_iiji = Module[\"dynCall_iiji\"] = wasmExports[\"Qb\"])(a0, a1, a2, a3, a4);\n        var dynCall_iji = Module[\"dynCall_iji\"] = (a0, a1, a2, a3)=>(dynCall_iji = Module[\"dynCall_iji\"] = wasmExports[\"Rb\"])(a0, a1, a2, a3);\n        var dynCall_jii = Module[\"dynCall_jii\"] = (a0, a1, a2)=>(dynCall_jii = Module[\"dynCall_jii\"] = wasmExports[\"Sb\"])(a0, a1, a2);\n        var dynCall_viij = Module[\"dynCall_viij\"] = (a0, a1, a2, a3, a4)=>(dynCall_viij = Module[\"dynCall_viij\"] = wasmExports[\"Tb\"])(a0, a1, a2, a3, a4);\n        var dynCall_jiji = Module[\"dynCall_jiji\"] = (a0, a1, a2, a3, a4)=>(dynCall_jiji = Module[\"dynCall_jiji\"] = wasmExports[\"Ub\"])(a0, a1, a2, a3, a4);\n        var dynCall_iij = Module[\"dynCall_iij\"] = (a0, a1, a2, a3)=>(dynCall_iij = Module[\"dynCall_iij\"] = wasmExports[\"Vb\"])(a0, a1, a2, a3);\n        var dynCall_viijii = Module[\"dynCall_viijii\"] = (a0, a1, a2, a3, a4, a5, a6)=>(dynCall_viijii = Module[\"dynCall_viijii\"] = wasmExports[\"Wb\"])(a0, a1, a2, a3, a4, a5, a6);\n        var dynCall_iiiiij = Module[\"dynCall_iiiiij\"] = (a0, a1, a2, a3, a4, a5, a6)=>(dynCall_iiiiij = Module[\"dynCall_iiiiij\"] = wasmExports[\"Xb\"])(a0, a1, a2, a3, a4, a5, a6);\n        var dynCall_iiiiijj = Module[\"dynCall_iiiiijj\"] = (a0, a1, a2, a3, a4, a5, a6, a7, a8)=>(dynCall_iiiiijj = Module[\"dynCall_iiiiijj\"] = wasmExports[\"Yb\"])(a0, a1, a2, a3, a4, a5, a6, a7, a8);\n        var dynCall_iiiiiijj = Module[\"dynCall_iiiiiijj\"] = (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9)=>(dynCall_iiiiiijj = Module[\"dynCall_iiiiiijj\"] = wasmExports[\"Zb\"])(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);\n        function invoke_viii(index, a1, a2, a3) {\n            var sp = stackSave();\n            try {\n                getWasmTableEntry(index)(a1, a2, a3);\n            } catch (e) {\n                stackRestore(sp);\n                if (e !== e + 0) throw e;\n                _setThrew(1, 0);\n            }\n        }\n        function invoke_viiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {\n            var sp = stackSave();\n            try {\n                getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6, a7, a8, a9);\n            } catch (e) {\n                stackRestore(sp);\n                if (e !== e + 0) throw e;\n                _setThrew(1, 0);\n            }\n        }\n        function invoke_vii(index, a1, a2) {\n            var sp = stackSave();\n            try {\n                getWasmTableEntry(index)(a1, a2);\n            } catch (e) {\n                stackRestore(sp);\n                if (e !== e + 0) throw e;\n                _setThrew(1, 0);\n            }\n        }\n        function invoke_viiii(index, a1, a2, a3, a4) {\n            var sp = stackSave();\n            try {\n                getWasmTableEntry(index)(a1, a2, a3, a4);\n            } catch (e) {\n                stackRestore(sp);\n                if (e !== e + 0) throw e;\n                _setThrew(1, 0);\n            }\n        }\n        function invoke_iii(index, a1, a2) {\n            var sp = stackSave();\n            try {\n                return getWasmTableEntry(index)(a1, a2);\n            } catch (e) {\n                stackRestore(sp);\n                if (e !== e + 0) throw e;\n                _setThrew(1, 0);\n            }\n        }\n        function invoke_vi(index, a1) {\n            var sp = stackSave();\n            try {\n                getWasmTableEntry(index)(a1);\n            } catch (e) {\n                stackRestore(sp);\n                if (e !== e + 0) throw e;\n                _setThrew(1, 0);\n            }\n        }\n        function invoke_diii(index, a1, a2, a3) {\n            var sp = stackSave();\n            try {\n                return getWasmTableEntry(index)(a1, a2, a3);\n            } catch (e) {\n                stackRestore(sp);\n                if (e !== e + 0) throw e;\n                _setThrew(1, 0);\n            }\n        }\n        function invoke_v(index) {\n            var sp = stackSave();\n            try {\n                getWasmTableEntry(index)();\n            } catch (e) {\n                stackRestore(sp);\n                if (e !== e + 0) throw e;\n                _setThrew(1, 0);\n            }\n        }\n        function invoke_ii(index, a1) {\n            var sp = stackSave();\n            try {\n                return getWasmTableEntry(index)(a1);\n            } catch (e) {\n                stackRestore(sp);\n                if (e !== e + 0) throw e;\n                _setThrew(1, 0);\n            }\n        }\n        function invoke_viiiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) {\n            var sp = stackSave();\n            try {\n                getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);\n            } catch (e) {\n                stackRestore(sp);\n                if (e !== e + 0) throw e;\n                _setThrew(1, 0);\n            }\n        }\n        function invoke_iiiii(index, a1, a2, a3, a4) {\n            var sp = stackSave();\n            try {\n                return getWasmTableEntry(index)(a1, a2, a3, a4);\n            } catch (e) {\n                stackRestore(sp);\n                if (e !== e + 0) throw e;\n                _setThrew(1, 0);\n            }\n        }\n        function invoke_iiii(index, a1, a2, a3) {\n            var sp = stackSave();\n            try {\n                return getWasmTableEntry(index)(a1, a2, a3);\n            } catch (e) {\n                stackRestore(sp);\n                if (e !== e + 0) throw e;\n                _setThrew(1, 0);\n            }\n        }\n        function invoke_viiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8) {\n            var sp = stackSave();\n            try {\n                getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6, a7, a8);\n            } catch (e) {\n                stackRestore(sp);\n                if (e !== e + 0) throw e;\n                _setThrew(1, 0);\n            }\n        }\n        function invoke_viddddidi(index, a1, a2, a3, a4, a5, a6, a7, a8) {\n            var sp = stackSave();\n            try {\n                getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6, a7, a8);\n            } catch (e) {\n                stackRestore(sp);\n                if (e !== e + 0) throw e;\n                _setThrew(1, 0);\n            }\n        }\n        function invoke_vidddidddi(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {\n            var sp = stackSave();\n            try {\n                getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6, a7, a8, a9);\n            } catch (e) {\n                stackRestore(sp);\n                if (e !== e + 0) throw e;\n                _setThrew(1, 0);\n            }\n        }\n        function invoke_vidddddddi(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {\n            var sp = stackSave();\n            try {\n                getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6, a7, a8, a9);\n            } catch (e) {\n                stackRestore(sp);\n                if (e !== e + 0) throw e;\n                _setThrew(1, 0);\n            }\n        }\n        function invoke_viddddddi(index, a1, a2, a3, a4, a5, a6, a7, a8) {\n            var sp = stackSave();\n            try {\n                getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6, a7, a8);\n            } catch (e) {\n                stackRestore(sp);\n                if (e !== e + 0) throw e;\n                _setThrew(1, 0);\n            }\n        }\n        function invoke_viddi(index, a1, a2, a3, a4) {\n            var sp = stackSave();\n            try {\n                getWasmTableEntry(index)(a1, a2, a3, a4);\n            } catch (e) {\n                stackRestore(sp);\n                if (e !== e + 0) throw e;\n                _setThrew(1, 0);\n            }\n        }\n        function invoke_viiiiid(index, a1, a2, a3, a4, a5, a6) {\n            var sp = stackSave();\n            try {\n                getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6);\n            } catch (e) {\n                stackRestore(sp);\n                if (e !== e + 0) throw e;\n                _setThrew(1, 0);\n            }\n        }\n        function invoke_viiidddi(index, a1, a2, a3, a4, a5, a6, a7) {\n            var sp = stackSave();\n            try {\n                getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6, a7);\n            } catch (e) {\n                stackRestore(sp);\n                if (e !== e + 0) throw e;\n                _setThrew(1, 0);\n            }\n        }\n        function invoke_viiiii(index, a1, a2, a3, a4, a5) {\n            var sp = stackSave();\n            try {\n                getWasmTableEntry(index)(a1, a2, a3, a4, a5);\n            } catch (e) {\n                stackRestore(sp);\n                if (e !== e + 0) throw e;\n                _setThrew(1, 0);\n            }\n        }\n        function invoke_viiidii(index, a1, a2, a3, a4, a5, a6) {\n            var sp = stackSave();\n            try {\n                getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6);\n            } catch (e) {\n                stackRestore(sp);\n                if (e !== e + 0) throw e;\n                _setThrew(1, 0);\n            }\n        }\n        function invoke_viiid(index, a1, a2, a3, a4) {\n            var sp = stackSave();\n            try {\n                getWasmTableEntry(index)(a1, a2, a3, a4);\n            } catch (e) {\n                stackRestore(sp);\n                if (e !== e + 0) throw e;\n                _setThrew(1, 0);\n            }\n        }\n        function invoke_viidd(index, a1, a2, a3, a4) {\n            var sp = stackSave();\n            try {\n                getWasmTableEntry(index)(a1, a2, a3, a4);\n            } catch (e) {\n                stackRestore(sp);\n                if (e !== e + 0) throw e;\n                _setThrew(1, 0);\n            }\n        }\n        function invoke_diiddddiiid(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) {\n            var sp = stackSave();\n            try {\n                return getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);\n            } catch (e) {\n                stackRestore(sp);\n                if (e !== e + 0) throw e;\n                _setThrew(1, 0);\n            }\n        }\n        function invoke_iiiiii(index, a1, a2, a3, a4, a5) {\n            var sp = stackSave();\n            try {\n                return getWasmTableEntry(index)(a1, a2, a3, a4, a5);\n            } catch (e) {\n                stackRestore(sp);\n                if (e !== e + 0) throw e;\n                _setThrew(1, 0);\n            }\n        }\n        function invoke_viiiiii(index, a1, a2, a3, a4, a5, a6) {\n            var sp = stackSave();\n            try {\n                getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6);\n            } catch (e) {\n                stackRestore(sp);\n                if (e !== e + 0) throw e;\n                _setThrew(1, 0);\n            }\n        }\n        function invoke_viddiiddii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {\n            var sp = stackSave();\n            try {\n                getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6, a7, a8, a9);\n            } catch (e) {\n                stackRestore(sp);\n                if (e !== e + 0) throw e;\n                _setThrew(1, 0);\n            }\n        }\n        function invoke_vidiidiii(index, a1, a2, a3, a4, a5, a6, a7, a8) {\n            var sp = stackSave();\n            try {\n                getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6, a7, a8);\n            } catch (e) {\n                stackRestore(sp);\n                if (e !== e + 0) throw e;\n                _setThrew(1, 0);\n            }\n        }\n        function invoke_vidiiii(index, a1, a2, a3, a4, a5, a6) {\n            var sp = stackSave();\n            try {\n                getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6);\n            } catch (e) {\n                stackRestore(sp);\n                if (e !== e + 0) throw e;\n                _setThrew(1, 0);\n            }\n        }\n        function invoke_viiiiiidd(index, a1, a2, a3, a4, a5, a6, a7, a8) {\n            var sp = stackSave();\n            try {\n                getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6, a7, a8);\n            } catch (e) {\n                stackRestore(sp);\n                if (e !== e + 0) throw e;\n                _setThrew(1, 0);\n            }\n        }\n        function invoke_viiiid(index, a1, a2, a3, a4, a5) {\n            var sp = stackSave();\n            try {\n                getWasmTableEntry(index)(a1, a2, a3, a4, a5);\n            } catch (e) {\n                stackRestore(sp);\n                if (e !== e + 0) throw e;\n                _setThrew(1, 0);\n            }\n        }\n        function invoke_iiiiiii(index, a1, a2, a3, a4, a5, a6) {\n            var sp = stackSave();\n            try {\n                return getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6);\n            } catch (e) {\n                stackRestore(sp);\n                if (e !== e + 0) throw e;\n                _setThrew(1, 0);\n            }\n        }\n        function invoke_i(index) {\n            var sp = stackSave();\n            try {\n                return getWasmTableEntry(index)();\n            } catch (e) {\n                stackRestore(sp);\n                if (e !== e + 0) throw e;\n                _setThrew(1, 0);\n            }\n        }\n        function invoke_iiiid(index, a1, a2, a3, a4) {\n            var sp = stackSave();\n            try {\n                return getWasmTableEntry(index)(a1, a2, a3, a4);\n            } catch (e) {\n                stackRestore(sp);\n                if (e !== e + 0) throw e;\n                _setThrew(1, 0);\n            }\n        }\n        function invoke_iid(index, a1, a2) {\n            var sp = stackSave();\n            try {\n                return getWasmTableEntry(index)(a1, a2);\n            } catch (e) {\n                stackRestore(sp);\n                if (e !== e + 0) throw e;\n                _setThrew(1, 0);\n            }\n        }\n        function invoke_iiiiiiii(index, a1, a2, a3, a4, a5, a6, a7) {\n            var sp = stackSave();\n            try {\n                return getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6, a7);\n            } catch (e) {\n                stackRestore(sp);\n                if (e !== e + 0) throw e;\n                _setThrew(1, 0);\n            }\n        }\n        function invoke_fiiif(index, a1, a2, a3, a4) {\n            var sp = stackSave();\n            try {\n                return getWasmTableEntry(index)(a1, a2, a3, a4);\n            } catch (e) {\n                stackRestore(sp);\n                if (e !== e + 0) throw e;\n                _setThrew(1, 0);\n            }\n        }\n        function invoke_iiiiif(index, a1, a2, a3, a4, a5) {\n            var sp = stackSave();\n            try {\n                return getWasmTableEntry(index)(a1, a2, a3, a4, a5);\n            } catch (e) {\n                stackRestore(sp);\n                if (e !== e + 0) throw e;\n                _setThrew(1, 0);\n            }\n        }\n        function invoke_iiiiid(index, a1, a2, a3, a4, a5) {\n            var sp = stackSave();\n            try {\n                return getWasmTableEntry(index)(a1, a2, a3, a4, a5);\n            } catch (e) {\n                stackRestore(sp);\n                if (e !== e + 0) throw e;\n                _setThrew(1, 0);\n            }\n        }\n        function invoke_viiiiiii(index, a1, a2, a3, a4, a5, a6, a7) {\n            var sp = stackSave();\n            try {\n                getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6, a7);\n            } catch (e) {\n                stackRestore(sp);\n                if (e !== e + 0) throw e;\n                _setThrew(1, 0);\n            }\n        }\n        function invoke_iiiiiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11) {\n            var sp = stackSave();\n            try {\n                return getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);\n            } catch (e) {\n                stackRestore(sp);\n                if (e !== e + 0) throw e;\n                _setThrew(1, 0);\n            }\n        }\n        function invoke_viiiiiiiiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15) {\n            var sp = stackSave();\n            try {\n                getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15);\n            } catch (e) {\n                stackRestore(sp);\n                if (e !== e + 0) throw e;\n                _setThrew(1, 0);\n            }\n        }\n        function invoke_viiiiiijj(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) {\n            var sp = stackSave();\n            try {\n                dynCall_viiiiiijj(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);\n            } catch (e) {\n                stackRestore(sp);\n                if (e !== e + 0) throw e;\n                _setThrew(1, 0);\n            }\n        }\n        function invoke_ji(index, a1) {\n            var sp = stackSave();\n            try {\n                return dynCall_ji(index, a1);\n            } catch (e) {\n                stackRestore(sp);\n                if (e !== e + 0) throw e;\n                _setThrew(1, 0);\n            }\n        }\n        function invoke_jiiii(index, a1, a2, a3, a4) {\n            var sp = stackSave();\n            try {\n                return dynCall_jiiii(index, a1, a2, a3, a4);\n            } catch (e) {\n                stackRestore(sp);\n                if (e !== e + 0) throw e;\n                _setThrew(1, 0);\n            }\n        }\n        function invoke_vij(index, a1, a2, a3) {\n            var sp = stackSave();\n            try {\n                dynCall_vij(index, a1, a2, a3);\n            } catch (e) {\n                stackRestore(sp);\n                if (e !== e + 0) throw e;\n                _setThrew(1, 0);\n            }\n        }\n        function invoke_iiji(index, a1, a2, a3, a4) {\n            var sp = stackSave();\n            try {\n                return dynCall_iiji(index, a1, a2, a3, a4);\n            } catch (e) {\n                stackRestore(sp);\n                if (e !== e + 0) throw e;\n                _setThrew(1, 0);\n            }\n        }\n        function invoke_iji(index, a1, a2, a3) {\n            var sp = stackSave();\n            try {\n                return dynCall_iji(index, a1, a2, a3);\n            } catch (e) {\n                stackRestore(sp);\n                if (e !== e + 0) throw e;\n                _setThrew(1, 0);\n            }\n        }\n        function invoke_jii(index, a1, a2) {\n            var sp = stackSave();\n            try {\n                return dynCall_jii(index, a1, a2);\n            } catch (e) {\n                stackRestore(sp);\n                if (e !== e + 0) throw e;\n                _setThrew(1, 0);\n            }\n        }\n        function invoke_iij(index, a1, a2, a3) {\n            var sp = stackSave();\n            try {\n                return dynCall_iij(index, a1, a2, a3);\n            } catch (e) {\n                stackRestore(sp);\n                if (e !== e + 0) throw e;\n                _setThrew(1, 0);\n            }\n        }\n        function applySignatureConversions(wasmExports) {\n            wasmExports = Object.assign({}, wasmExports);\n            var makeWrapper_p = (f)=>()=>f() >>> 0;\n            var makeWrapper_pp = (f)=>(a0)=>f(a0) >>> 0;\n            wasmExports[\"ob\"] = makeWrapper_p(wasmExports[\"ob\"]);\n            wasmExports[\"qb\"] = makeWrapper_pp(wasmExports[\"qb\"]);\n            wasmExports[\"rb\"] = makeWrapper_pp(wasmExports[\"rb\"]);\n            wasmExports[\"emscripten_main_runtime_thread_id\"] = makeWrapper_p(wasmExports[\"emscripten_main_runtime_thread_id\"]);\n            wasmExports[\"Gb\"] = makeWrapper_pp(wasmExports[\"Gb\"]);\n            wasmExports[\"Hb\"] = makeWrapper_p(wasmExports[\"Hb\"]);\n            wasmExports[\"Lb\"] = makeWrapper_pp(wasmExports[\"Lb\"]);\n            return wasmExports;\n        }\n        Module[\"addRunDependency\"] = addRunDependency;\n        Module[\"removeRunDependency\"] = removeRunDependency;\n        Module[\"FS_createPreloadedFile\"] = FS_createPreloadedFile;\n        Module[\"FS_unlink\"] = FS_unlink;\n        Module[\"FS_createPath\"] = FS_createPath;\n        Module[\"FS_createDevice\"] = FS_createDevice;\n        Module[\"FS\"] = FS;\n        Module[\"FS_createDataFile\"] = FS_createDataFile;\n        Module[\"FS_createLazyFile\"] = FS_createLazyFile;\n        Module[\"WORKERFS\"] = WORKERFS;\n        var calledRun;\n        dependenciesFulfilled = function runCaller() {\n            if (!calledRun) run();\n            if (!calledRun) dependenciesFulfilled = runCaller;\n        };\n        function run() {\n            if (runDependencies > 0) return;\n            if (ENVIRONMENT_IS_PTHREAD) {\n                readyPromiseResolve(Module);\n                initRuntime();\n                startWorker(Module);\n                return;\n            }\n            preRun();\n            if (runDependencies > 0) return;\n            function doRun() {\n                if (calledRun) return;\n                calledRun = true;\n                Module[\"calledRun\"] = true;\n                if (ABORT) return;\n                initRuntime();\n                readyPromiseResolve(Module);\n                Module[\"onRuntimeInitialized\"]?.();\n                postRun();\n            }\n            if (Module[\"setStatus\"]) {\n                Module[\"setStatus\"](\"Running...\");\n                setTimeout(()=>{\n                    setTimeout(()=>Module[\"setStatus\"](\"\"), 1);\n                    doRun();\n                }, 1);\n            } else doRun();\n        }\n        if (Module[\"preInit\"]) {\n            if (typeof Module[\"preInit\"] == \"function\") Module[\"preInit\"] = [\n                Module[\"preInit\"]\n            ];\n            while(Module[\"preInit\"].length > 0)Module[\"preInit\"].pop()();\n        }\n        run();\n        moduleRtn = readyPromise;\n        return moduleRtn;\n    };\n})();\nvar $a023ed70d02b2fd9$export$2e2bcd8739ae039 = $a023ed70d02b2fd9$var$ConwayGeomWasm;\nvar $a023ed70d02b2fd9$var$isPthread = globalThis.self?.name?.startsWith('em-pthread');\n// When running as a pthread, construct a new instance on startup\n$a023ed70d02b2fd9$var$isPthread && $a023ed70d02b2fd9$var$ConwayGeomWasm();\n\n});\n\n\n//# sourceMappingURL=ConwayGeomWasmWebMT.fe679e06.js.map\n","\nvar ConwayGeomWasm = (() => {\n  var _scriptName = typeof document != 'undefined' ? document.currentScript?.src : undefined;\n  \n  return (\nfunction(moduleArg = {}) {\n  var moduleRtn;\n\nfunction GROWABLE_HEAP_I8(){if(wasmMemory.buffer!=HEAP8.buffer){updateMemoryViews()}return HEAP8}function GROWABLE_HEAP_U8(){if(wasmMemory.buffer!=HEAP8.buffer){updateMemoryViews()}return HEAPU8}function GROWABLE_HEAP_I16(){if(wasmMemory.buffer!=HEAP8.buffer){updateMemoryViews()}return HEAP16}function GROWABLE_HEAP_U16(){if(wasmMemory.buffer!=HEAP8.buffer){updateMemoryViews()}return HEAPU16}function GROWABLE_HEAP_I32(){if(wasmMemory.buffer!=HEAP8.buffer){updateMemoryViews()}return HEAP32}function GROWABLE_HEAP_U32(){if(wasmMemory.buffer!=HEAP8.buffer){updateMemoryViews()}return HEAPU32}function GROWABLE_HEAP_F32(){if(wasmMemory.buffer!=HEAP8.buffer){updateMemoryViews()}return HEAPF32}function GROWABLE_HEAP_F64(){if(wasmMemory.buffer!=HEAP8.buffer){updateMemoryViews()}return HEAPF64}var Module=moduleArg;var readyPromiseResolve,readyPromiseReject;var readyPromise=new Promise((resolve,reject)=>{readyPromiseResolve=resolve;readyPromiseReject=reject});var ENVIRONMENT_IS_WEB=typeof window==\"object\";var ENVIRONMENT_IS_WORKER=typeof WorkerGlobalScope!=\"undefined\";var ENVIRONMENT_IS_NODE=typeof process==\"object\"&&typeof process.versions==\"object\"&&typeof process.versions.node==\"string\"&&process.type!=\"renderer\";var ENVIRONMENT_IS_PTHREAD=ENVIRONMENT_IS_WORKER&&self.name?.startsWith(\"em-pthread\");var moduleOverrides=Object.assign({},Module);var arguments_=[];var thisProgram=\"./this.program\";var quit_=(status,toThrow)=>{throw toThrow};var scriptDirectory=\"\";function locateFile(path){if(Module[\"locateFile\"]){return Module[\"locateFile\"](path,scriptDirectory)}return scriptDirectory+path}var readAsync,readBinary;if(ENVIRONMENT_IS_WEB||ENVIRONMENT_IS_WORKER){if(ENVIRONMENT_IS_WORKER){scriptDirectory=self.location.href}else if(typeof document!=\"undefined\"&&document.currentScript){scriptDirectory=document.currentScript.src}if(_scriptName){scriptDirectory=_scriptName}if(scriptDirectory.startsWith(\"blob:\")){scriptDirectory=\"\"}else{scriptDirectory=scriptDirectory.substr(0,scriptDirectory.replace(/[?#].*/,\"\").lastIndexOf(\"/\")+1)}{if(ENVIRONMENT_IS_WORKER){readBinary=url=>{var xhr=new XMLHttpRequest;xhr.open(\"GET\",url,false);xhr.responseType=\"arraybuffer\";xhr.send(null);return new Uint8Array(xhr.response)}}readAsync=url=>fetch(url,{credentials:\"same-origin\"}).then(response=>{if(response.ok){return response.arrayBuffer()}return Promise.reject(new Error(response.status+\" : \"+response.url))})}}else{}var out=Module[\"print\"]||console.log.bind(console);var err=Module[\"printErr\"]||console.error.bind(console);Object.assign(Module,moduleOverrides);moduleOverrides=null;if(Module[\"arguments\"])arguments_=Module[\"arguments\"];if(Module[\"thisProgram\"])thisProgram=Module[\"thisProgram\"];var wasmBinary=Module[\"wasmBinary\"];var wasmMemory;var wasmModule;var ABORT=false;var EXITSTATUS;function assert(condition,text){if(!condition){abort(text)}}var HEAP8,HEAPU8,HEAP16,HEAPU16,HEAP32,HEAPU32,HEAPF32,HEAPF64;function updateMemoryViews(){var b=wasmMemory.buffer;Module[\"HEAP8\"]=HEAP8=new Int8Array(b);Module[\"HEAP16\"]=HEAP16=new Int16Array(b);Module[\"HEAPU8\"]=HEAPU8=new Uint8Array(b);Module[\"HEAPU16\"]=HEAPU16=new Uint16Array(b);Module[\"HEAP32\"]=HEAP32=new Int32Array(b);Module[\"HEAPU32\"]=HEAPU32=new Uint32Array(b);Module[\"HEAPF32\"]=HEAPF32=new Float32Array(b);Module[\"HEAPF64\"]=HEAPF64=new Float64Array(b)}if(ENVIRONMENT_IS_PTHREAD){var wasmModuleReceived;var initializedJS=false;function threadPrintErr(...args){var text=args.join(\" \");console.error(text)}if(!Module[\"printErr\"])err=threadPrintErr;function threadAlert(...args){var text=args.join(\" \");postMessage({cmd:\"alert\",text,threadId:_pthread_self()})}self.alert=threadAlert;self.onunhandledrejection=e=>{throw e.reason||e};function handleMessage(e){try{var msgData=e[\"data\"];var cmd=msgData.cmd;if(cmd===\"load\"){let messageQueue=[];self.onmessage=e=>messageQueue.push(e);self.startWorker=instance=>{postMessage({cmd:\"loaded\"});for(let msg of messageQueue){handleMessage(msg)}self.onmessage=handleMessage};for(const handler of msgData.handlers){if(!Module[handler]||Module[handler].proxy){Module[handler]=(...args)=>{postMessage({cmd:\"callHandler\",handler,args})};if(handler==\"print\")out=Module[handler];if(handler==\"printErr\")err=Module[handler]}}wasmMemory=msgData.wasmMemory;updateMemoryViews();wasmModuleReceived(msgData.wasmModule)}else if(cmd===\"run\"){establishStackSpace(msgData.pthread_ptr);__emscripten_thread_init(msgData.pthread_ptr,0,0,1,0,0);PThread.receiveObjectTransfer(msgData);PThread.threadInitTLS();__emscripten_thread_mailbox_await(msgData.pthread_ptr);if(!initializedJS){__embind_initialize_bindings();initializedJS=true}try{invokeEntryPoint(msgData.start_routine,msgData.arg)}catch(ex){if(ex!=\"unwind\"){throw ex}}}else if(msgData.target===\"setimmediate\"){}else if(cmd===\"checkMailbox\"){if(initializedJS){checkMailbox()}}else if(cmd){err(`worker: received unknown command ${cmd}`);err(msgData)}}catch(ex){__emscripten_thread_crashed();throw ex}}self.onmessage=handleMessage}if(!ENVIRONMENT_IS_PTHREAD){if(Module[\"wasmMemory\"]){wasmMemory=Module[\"wasmMemory\"]}else{var INITIAL_MEMORY=Module[\"INITIAL_MEMORY\"]||16777216;wasmMemory=new WebAssembly.Memory({initial:INITIAL_MEMORY/65536,maximum:65536,shared:true})}updateMemoryViews()}var __ATPRERUN__=[];var __ATINIT__=[];var __ATPOSTRUN__=[];var runtimeInitialized=false;function preRun(){if(Module[\"preRun\"]){if(typeof Module[\"preRun\"]==\"function\")Module[\"preRun\"]=[Module[\"preRun\"]];while(Module[\"preRun\"].length){addOnPreRun(Module[\"preRun\"].shift())}}callRuntimeCallbacks(__ATPRERUN__)}function initRuntime(){runtimeInitialized=true;if(ENVIRONMENT_IS_PTHREAD)return;if(!Module[\"noFSInit\"]&&!FS.initialized)FS.init();FS.ignorePermissions=false;TTY.init();callRuntimeCallbacks(__ATINIT__)}function postRun(){if(ENVIRONMENT_IS_PTHREAD)return;if(Module[\"postRun\"]){if(typeof Module[\"postRun\"]==\"function\")Module[\"postRun\"]=[Module[\"postRun\"]];while(Module[\"postRun\"].length){addOnPostRun(Module[\"postRun\"].shift())}}callRuntimeCallbacks(__ATPOSTRUN__)}function addOnPreRun(cb){__ATPRERUN__.unshift(cb)}function addOnInit(cb){__ATINIT__.unshift(cb)}function addOnPostRun(cb){__ATPOSTRUN__.unshift(cb)}var runDependencies=0;var runDependencyWatcher=null;var dependenciesFulfilled=null;function getUniqueRunDependency(id){return id}function addRunDependency(id){runDependencies++;Module[\"monitorRunDependencies\"]?.(runDependencies)}function removeRunDependency(id){runDependencies--;Module[\"monitorRunDependencies\"]?.(runDependencies);if(runDependencies==0){if(runDependencyWatcher!==null){clearInterval(runDependencyWatcher);runDependencyWatcher=null}if(dependenciesFulfilled){var callback=dependenciesFulfilled;dependenciesFulfilled=null;callback()}}}function abort(what){Module[\"onAbort\"]?.(what);what=\"Aborted(\"+what+\")\";err(what);ABORT=true;what+=\". Build with -sASSERTIONS for more info.\";var e=new WebAssembly.RuntimeError(what);readyPromiseReject(e);throw e}var dataURIPrefix=\"data:application/octet-stream;base64,\";var isDataURI=filename=>filename.startsWith(dataURIPrefix);function findWasmBinary(){var f=\"ConwayGeomWasmWebMT.wasm\";if(!isDataURI(f)){return locateFile(f)}return f}var wasmBinaryFile;function getBinarySync(file){if(file==wasmBinaryFile&&wasmBinary){return new Uint8Array(wasmBinary)}if(readBinary){return readBinary(file)}throw\"both async and sync fetching of the wasm failed\"}function getBinaryPromise(binaryFile){if(!wasmBinary){return readAsync(binaryFile).then(response=>new Uint8Array(response),()=>getBinarySync(binaryFile))}return Promise.resolve().then(()=>getBinarySync(binaryFile))}function instantiateArrayBuffer(binaryFile,imports,receiver){return getBinaryPromise(binaryFile).then(binary=>WebAssembly.instantiate(binary,imports)).then(receiver,reason=>{err(`failed to asynchronously prepare wasm: ${reason}`);abort(reason)})}function instantiateAsync(binary,binaryFile,imports,callback){if(!binary&&typeof WebAssembly.instantiateStreaming==\"function\"&&!isDataURI(binaryFile)&&typeof fetch==\"function\"){return fetch(binaryFile,{credentials:\"same-origin\"}).then(response=>{var result=WebAssembly.instantiateStreaming(response,imports);return result.then(callback,function(reason){err(`wasm streaming compile failed: ${reason}`);err(\"falling back to ArrayBuffer instantiation\");return instantiateArrayBuffer(binaryFile,imports,callback)})})}return instantiateArrayBuffer(binaryFile,imports,callback)}function getWasmImports(){assignWasmImports();return{a:wasmImports}}function createWasm(){function receiveInstance(instance,module){wasmExports=instance.exports;wasmExports=applySignatureConversions(wasmExports);registerTLSInit(wasmExports[\"ub\"]);wasmTable=wasmExports[\"pb\"];addOnInit(wasmExports[\"nb\"]);wasmModule=module;removeRunDependency(\"wasm-instantiate\");return wasmExports}addRunDependency(\"wasm-instantiate\");function receiveInstantiationResult(result){receiveInstance(result[\"instance\"],result[\"module\"])}var info=getWasmImports();if(Module[\"instantiateWasm\"]){try{return Module[\"instantiateWasm\"](info,receiveInstance)}catch(e){err(`Module.instantiateWasm callback failed with error: ${e}`);readyPromiseReject(e)}}if(ENVIRONMENT_IS_PTHREAD){return new Promise(resolve=>{wasmModuleReceived=module=>{var instance=new WebAssembly.Instance(module,getWasmImports());receiveInstance(instance,module);resolve()}})}wasmBinaryFile??=findWasmBinary();instantiateAsync(wasmBinary,wasmBinaryFile,info,receiveInstantiationResult).catch(readyPromiseReject);return{}}var tempDouble;var tempI64;var ASM_CONSTS={106532:$0=>{let globalScope=typeof window!==\"undefined\"?window:global;if(typeof globalScope[\"logInfo\"]===\"function\"){globalScope[\"logInfo\"](UTF8ToString($0))}},106701:$0=>{let globalScope=typeof window!==\"undefined\"?window:global;if(typeof globalScope[\"logWarning\"]===\"function\"){globalScope[\"logWarning\"](UTF8ToString($0))}},106876:$0=>{let globalScope=typeof window!==\"undefined\"?window:global;if(typeof globalScope[\"logError\"]===\"function\"){globalScope[\"logError\"](UTF8ToString($0))}}};class ExitStatus{name=\"ExitStatus\";constructor(status){this.message=`Program terminated with exit(${status})`;this.status=status}}var terminateWorker=worker=>{worker.terminate();worker.onmessage=e=>{}};var cleanupThread=pthread_ptr=>{var worker=PThread.pthreads[pthread_ptr];PThread.returnWorkerToPool(worker)};var spawnThread=threadParams=>{var worker=PThread.getNewWorker();if(!worker){return 6}PThread.runningWorkers.push(worker);PThread.pthreads[threadParams.pthread_ptr]=worker;worker.pthread_ptr=threadParams.pthread_ptr;var msg={cmd:\"run\",start_routine:threadParams.startRoutine,arg:threadParams.arg,pthread_ptr:threadParams.pthread_ptr};worker.postMessage(msg,threadParams.transferList);return 0};var runtimeKeepaliveCounter=0;var keepRuntimeAlive=()=>noExitRuntime||runtimeKeepaliveCounter>0;var stackSave=()=>_emscripten_stack_get_current();var stackRestore=val=>__emscripten_stack_restore(val);var stackAlloc=sz=>__emscripten_stack_alloc(sz);var convertI32PairToI53Checked=(lo,hi)=>hi+2097152>>>0<4194305-!!lo?(lo>>>0)+hi*4294967296:NaN;var proxyToMainThread=(funcIndex,emAsmAddr,sync,...callArgs)=>{var serializedNumCallArgs=callArgs.length;var sp=stackSave();var args=stackAlloc(serializedNumCallArgs*8);var b=args>>>3;for(var i=0;i<callArgs.length;i++){var arg=callArgs[i];GROWABLE_HEAP_F64()[b+i>>>0]=arg}var rtn=__emscripten_run_on_main_thread_js(funcIndex,emAsmAddr,serializedNumCallArgs,args,sync);stackRestore(sp);return rtn};function _proc_exit(code){if(ENVIRONMENT_IS_PTHREAD)return proxyToMainThread(0,0,1,code);EXITSTATUS=code;if(!keepRuntimeAlive()){PThread.terminateAllThreads();Module[\"onExit\"]?.(code);ABORT=true}quit_(code,new ExitStatus(code))}var handleException=e=>{if(e instanceof ExitStatus||e==\"unwind\"){return EXITSTATUS}quit_(1,e)};function exitOnMainThread(returnCode){if(ENVIRONMENT_IS_PTHREAD)return proxyToMainThread(1,0,0,returnCode);_exit(returnCode)}var exitJS=(status,implicit)=>{EXITSTATUS=status;if(ENVIRONMENT_IS_PTHREAD){exitOnMainThread(status);throw\"unwind\"}_proc_exit(status)};var _exit=exitJS;var PThread={unusedWorkers:[],runningWorkers:[],tlsInitFunctions:[],pthreads:{},init(){if(!ENVIRONMENT_IS_PTHREAD){PThread.initMainThread()}},initMainThread(){var pthreadPoolSize=Math.max(navigator.hardwareConcurrency-1,1);while(pthreadPoolSize--){PThread.allocateUnusedWorker()}addOnPreRun(()=>{addRunDependency(\"loading-workers\");PThread.loadWasmModuleToAllWorkers(()=>removeRunDependency(\"loading-workers\"))})},terminateAllThreads:()=>{for(var worker of PThread.runningWorkers){terminateWorker(worker)}for(var worker of PThread.unusedWorkers){terminateWorker(worker)}PThread.unusedWorkers=[];PThread.runningWorkers=[];PThread.pthreads={}},returnWorkerToPool:worker=>{var pthread_ptr=worker.pthread_ptr;delete PThread.pthreads[pthread_ptr];PThread.unusedWorkers.push(worker);PThread.runningWorkers.splice(PThread.runningWorkers.indexOf(worker),1);worker.pthread_ptr=0;__emscripten_thread_free_data(pthread_ptr)},receiveObjectTransfer(data){},threadInitTLS(){PThread.tlsInitFunctions.forEach(f=>f())},loadWasmModuleToWorker:worker=>new Promise(onFinishedLoading=>{worker.onmessage=e=>{var d=e[\"data\"];var cmd=d.cmd;if(d.targetThread&&d.targetThread!=_pthread_self()){var targetWorker=PThread.pthreads[d.targetThread];if(targetWorker){targetWorker.postMessage(d,d.transferList)}else{err(`Internal error! Worker sent a message \"${cmd}\" to target pthread ${d.targetThread}, but that thread no longer exists!`)}return}if(cmd===\"checkMailbox\"){checkMailbox()}else if(cmd===\"spawnThread\"){spawnThread(d)}else if(cmd===\"cleanupThread\"){cleanupThread(d.thread)}else if(cmd===\"loaded\"){worker.loaded=true;onFinishedLoading(worker)}else if(cmd===\"alert\"){alert(`Thread ${d.threadId}: ${d.text}`)}else if(d.target===\"setimmediate\"){worker.postMessage(d)}else if(cmd===\"callHandler\"){Module[d.handler](...d.args)}else if(cmd){err(`worker sent an unknown command ${cmd}`)}};worker.onerror=e=>{var message=\"worker sent an error!\";err(`${message} ${e.filename}:${e.lineno}: ${e.message}`);throw e};var handlers=[];var knownHandlers=[\"onExit\",\"onAbort\",\"print\",\"printErr\"];for(var handler of knownHandlers){if(Module.propertyIsEnumerable(handler)){handlers.push(handler)}}worker.postMessage({cmd:\"load\",handlers,wasmMemory,wasmModule})}),loadWasmModuleToAllWorkers(onMaybeReady){if(ENVIRONMENT_IS_PTHREAD){return onMaybeReady()}let pthreadPoolReady=Promise.all(PThread.unusedWorkers.map(PThread.loadWasmModuleToWorker));pthreadPoolReady.then(onMaybeReady)},allocateUnusedWorker(){var worker;var workerOptions={type:\"module\",name:\"em-pthread\"};var pthreadMainJs=_scriptName;if(Module[\"mainScriptUrlOrBlob\"]){pthreadMainJs=Module[\"mainScriptUrlOrBlob\"];if(typeof pthreadMainJs!=\"string\"){pthreadMainJs=URL.createObjectURL(pthreadMainJs)}}worker=new Worker(pthreadMainJs,workerOptions);PThread.unusedWorkers.push(worker)},getNewWorker(){if(PThread.unusedWorkers.length==0){PThread.allocateUnusedWorker();PThread.loadWasmModuleToWorker(PThread.unusedWorkers[0])}return PThread.unusedWorkers.pop()}};var callRuntimeCallbacks=callbacks=>{while(callbacks.length>0){callbacks.shift()(Module)}};var establishStackSpace=pthread_ptr=>{updateMemoryViews();var stackHigh=GROWABLE_HEAP_U32()[pthread_ptr+52>>>2>>>0];var stackSize=GROWABLE_HEAP_U32()[pthread_ptr+56>>>2>>>0];var stackLow=stackHigh-stackSize;_emscripten_stack_set_limits(stackHigh,stackLow);stackRestore(stackHigh)};var wasmTableMirror=[];var wasmTable;var getWasmTableEntry=funcPtr=>{var func=wasmTableMirror[funcPtr];if(!func){if(funcPtr>=wasmTableMirror.length)wasmTableMirror.length=funcPtr+1;wasmTableMirror[funcPtr]=func=wasmTable.get(funcPtr)}return func};var invokeEntryPoint=(ptr,arg)=>{runtimeKeepaliveCounter=0;noExitRuntime=0;var result=getWasmTableEntry(ptr)(arg);function finish(result){if(keepRuntimeAlive()){EXITSTATUS=result}else{__emscripten_thread_exit(result)}}finish(result)};var noExitRuntime=Module[\"noExitRuntime\"]||true;var registerTLSInit=tlsInitFunc=>PThread.tlsInitFunctions.push(tlsInitFunc);var exceptionCaught=[];var uncaughtExceptionCount=0;function ___cxa_begin_catch(ptr){ptr>>>=0;var info=new ExceptionInfo(ptr);if(!info.get_caught()){info.set_caught(true);uncaughtExceptionCount--}info.set_rethrown(false);exceptionCaught.push(info);___cxa_increment_exception_refcount(ptr);return ___cxa_get_exception_ptr(ptr)}var exceptionLast=0;var ___cxa_end_catch=()=>{_setThrew(0,0);var info=exceptionCaught.pop();___cxa_decrement_exception_refcount(info.excPtr);exceptionLast=0};class ExceptionInfo{constructor(excPtr){this.excPtr=excPtr;this.ptr=excPtr-24}set_type(type){GROWABLE_HEAP_U32()[this.ptr+4>>>2>>>0]=type}get_type(){return GROWABLE_HEAP_U32()[this.ptr+4>>>2>>>0]}set_destructor(destructor){GROWABLE_HEAP_U32()[this.ptr+8>>>2>>>0]=destructor}get_destructor(){return GROWABLE_HEAP_U32()[this.ptr+8>>>2>>>0]}set_caught(caught){caught=caught?1:0;GROWABLE_HEAP_I8()[this.ptr+12>>>0]=caught}get_caught(){return GROWABLE_HEAP_I8()[this.ptr+12>>>0]!=0}set_rethrown(rethrown){rethrown=rethrown?1:0;GROWABLE_HEAP_I8()[this.ptr+13>>>0]=rethrown}get_rethrown(){return GROWABLE_HEAP_I8()[this.ptr+13>>>0]!=0}init(type,destructor){this.set_adjusted_ptr(0);this.set_type(type);this.set_destructor(destructor)}set_adjusted_ptr(adjustedPtr){GROWABLE_HEAP_U32()[this.ptr+16>>>2>>>0]=adjustedPtr}get_adjusted_ptr(){return GROWABLE_HEAP_U32()[this.ptr+16>>>2>>>0]}}function ___resumeException(ptr){ptr>>>=0;if(!exceptionLast){exceptionLast=ptr}throw exceptionLast}var setTempRet0=val=>__emscripten_tempret_set(val);var findMatchingCatch=args=>{var thrown=exceptionLast;if(!thrown){setTempRet0(0);return 0}var info=new ExceptionInfo(thrown);info.set_adjusted_ptr(thrown);var thrownType=info.get_type();if(!thrownType){setTempRet0(0);return thrown}for(var caughtType of args){if(caughtType===0||caughtType===thrownType){break}var adjusted_ptr_addr=info.ptr+16;if(___cxa_can_catch(caughtType,thrownType,adjusted_ptr_addr)){setTempRet0(caughtType);return thrown}}setTempRet0(thrownType);return thrown};function ___cxa_find_matching_catch_2(){return findMatchingCatch([])}function ___cxa_find_matching_catch_3(arg0){arg0>>>=0;return findMatchingCatch([arg0])}function ___cxa_find_matching_catch_4(arg0,arg1){arg0>>>=0;arg1>>>=0;return findMatchingCatch([arg0,arg1])}var ___cxa_rethrow=()=>{var info=exceptionCaught.pop();if(!info){abort(\"no exception to throw\")}var ptr=info.excPtr;if(!info.get_rethrown()){exceptionCaught.push(info);info.set_rethrown(true);info.set_caught(false);uncaughtExceptionCount++}exceptionLast=ptr;throw exceptionLast};function ___cxa_throw(ptr,type,destructor){ptr>>>=0;type>>>=0;destructor>>>=0;var info=new ExceptionInfo(ptr);info.init(type,destructor);exceptionLast=ptr;uncaughtExceptionCount++;throw exceptionLast}var ___cxa_uncaught_exceptions=()=>uncaughtExceptionCount;function pthreadCreateProxied(pthread_ptr,attr,startRoutine,arg){if(ENVIRONMENT_IS_PTHREAD)return proxyToMainThread(2,0,1,pthread_ptr,attr,startRoutine,arg);return ___pthread_create_js(pthread_ptr,attr,startRoutine,arg)}var _emscripten_has_threading_support=()=>typeof SharedArrayBuffer!=\"undefined\";function ___pthread_create_js(pthread_ptr,attr,startRoutine,arg){pthread_ptr>>>=0;attr>>>=0;startRoutine>>>=0;arg>>>=0;if(!_emscripten_has_threading_support()){return 6}var transferList=[];var error=0;if(ENVIRONMENT_IS_PTHREAD&&(transferList.length===0||error)){return pthreadCreateProxied(pthread_ptr,attr,startRoutine,arg)}if(error)return error;var threadParams={startRoutine,pthread_ptr,arg,transferList};if(ENVIRONMENT_IS_PTHREAD){threadParams.cmd=\"spawnThread\";postMessage(threadParams,transferList);return 0}return spawnThread(threadParams)}var syscallGetVarargI=()=>{var ret=GROWABLE_HEAP_I32()[+SYSCALLS.varargs>>>2>>>0];SYSCALLS.varargs+=4;return ret};var syscallGetVarargP=syscallGetVarargI;var PATH={isAbs:path=>path.charAt(0)===\"/\",splitPath:filename=>{var splitPathRe=/^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;return splitPathRe.exec(filename).slice(1)},normalizeArray:(parts,allowAboveRoot)=>{var up=0;for(var i=parts.length-1;i>=0;i--){var last=parts[i];if(last===\".\"){parts.splice(i,1)}else if(last===\"..\"){parts.splice(i,1);up++}else if(up){parts.splice(i,1);up--}}if(allowAboveRoot){for(;up;up--){parts.unshift(\"..\")}}return parts},normalize:path=>{var isAbsolute=PATH.isAbs(path),trailingSlash=path.substr(-1)===\"/\";path=PATH.normalizeArray(path.split(\"/\").filter(p=>!!p),!isAbsolute).join(\"/\");if(!path&&!isAbsolute){path=\".\"}if(path&&trailingSlash){path+=\"/\"}return(isAbsolute?\"/\":\"\")+path},dirname:path=>{var result=PATH.splitPath(path),root=result[0],dir=result[1];if(!root&&!dir){return\".\"}if(dir){dir=dir.substr(0,dir.length-1)}return root+dir},basename:path=>{if(path===\"/\")return\"/\";path=PATH.normalize(path);path=path.replace(/\\/$/,\"\");var lastSlash=path.lastIndexOf(\"/\");if(lastSlash===-1)return path;return path.substr(lastSlash+1)},join:(...paths)=>PATH.normalize(paths.join(\"/\")),join2:(l,r)=>PATH.normalize(l+\"/\"+r)};var initRandomFill=()=>{if(typeof crypto==\"object\"&&typeof crypto[\"getRandomValues\"]==\"function\"){return view=>(view.set(crypto.getRandomValues(new Uint8Array(view.byteLength))),view)}else abort(\"initRandomDevice\")};var randomFill=view=>(randomFill=initRandomFill())(view);var PATH_FS={resolve:(...args)=>{var resolvedPath=\"\",resolvedAbsolute=false;for(var i=args.length-1;i>=-1&&!resolvedAbsolute;i--){var path=i>=0?args[i]:FS.cwd();if(typeof path!=\"string\"){throw new TypeError(\"Arguments to path.resolve must be strings\")}else if(!path){return\"\"}resolvedPath=path+\"/\"+resolvedPath;resolvedAbsolute=PATH.isAbs(path)}resolvedPath=PATH.normalizeArray(resolvedPath.split(\"/\").filter(p=>!!p),!resolvedAbsolute).join(\"/\");return(resolvedAbsolute?\"/\":\"\")+resolvedPath||\".\"},relative:(from,to)=>{from=PATH_FS.resolve(from).substr(1);to=PATH_FS.resolve(to).substr(1);function trim(arr){var start=0;for(;start<arr.length;start++){if(arr[start]!==\"\")break}var end=arr.length-1;for(;end>=0;end--){if(arr[end]!==\"\")break}if(start>end)return[];return arr.slice(start,end-start+1)}var fromParts=trim(from.split(\"/\"));var toParts=trim(to.split(\"/\"));var length=Math.min(fromParts.length,toParts.length);var samePartsLength=length;for(var i=0;i<length;i++){if(fromParts[i]!==toParts[i]){samePartsLength=i;break}}var outputParts=[];for(var i=samePartsLength;i<fromParts.length;i++){outputParts.push(\"..\")}outputParts=outputParts.concat(toParts.slice(samePartsLength));return outputParts.join(\"/\")}};var UTF8Decoder=typeof TextDecoder!=\"undefined\"?new TextDecoder:undefined;var UTF8ArrayToString=(heapOrArray,idx=0,maxBytesToRead=NaN)=>{idx>>>=0;var endIdx=idx+maxBytesToRead;var endPtr=idx;while(heapOrArray[endPtr]&&!(endPtr>=endIdx))++endPtr;if(endPtr-idx>16&&heapOrArray.buffer&&UTF8Decoder){return UTF8Decoder.decode(heapOrArray.buffer instanceof ArrayBuffer?heapOrArray.subarray(idx,endPtr):heapOrArray.slice(idx,endPtr))}var str=\"\";while(idx<endPtr){var u0=heapOrArray[idx++];if(!(u0&128)){str+=String.fromCharCode(u0);continue}var u1=heapOrArray[idx++]&63;if((u0&224)==192){str+=String.fromCharCode((u0&31)<<6|u1);continue}var u2=heapOrArray[idx++]&63;if((u0&240)==224){u0=(u0&15)<<12|u1<<6|u2}else{u0=(u0&7)<<18|u1<<12|u2<<6|heapOrArray[idx++]&63}if(u0<65536){str+=String.fromCharCode(u0)}else{var ch=u0-65536;str+=String.fromCharCode(55296|ch>>10,56320|ch&1023)}}return str};var FS_stdin_getChar_buffer=[];var lengthBytesUTF8=str=>{var len=0;for(var i=0;i<str.length;++i){var c=str.charCodeAt(i);if(c<=127){len++}else if(c<=2047){len+=2}else if(c>=55296&&c<=57343){len+=4;++i}else{len+=3}}return len};var stringToUTF8Array=(str,heap,outIdx,maxBytesToWrite)=>{outIdx>>>=0;if(!(maxBytesToWrite>0))return 0;var startIdx=outIdx;var endIdx=outIdx+maxBytesToWrite-1;for(var i=0;i<str.length;++i){var u=str.charCodeAt(i);if(u>=55296&&u<=57343){var u1=str.charCodeAt(++i);u=65536+((u&1023)<<10)|u1&1023}if(u<=127){if(outIdx>=endIdx)break;heap[outIdx++>>>0]=u}else if(u<=2047){if(outIdx+1>=endIdx)break;heap[outIdx++>>>0]=192|u>>6;heap[outIdx++>>>0]=128|u&63}else if(u<=65535){if(outIdx+2>=endIdx)break;heap[outIdx++>>>0]=224|u>>12;heap[outIdx++>>>0]=128|u>>6&63;heap[outIdx++>>>0]=128|u&63}else{if(outIdx+3>=endIdx)break;heap[outIdx++>>>0]=240|u>>18;heap[outIdx++>>>0]=128|u>>12&63;heap[outIdx++>>>0]=128|u>>6&63;heap[outIdx++>>>0]=128|u&63}}heap[outIdx>>>0]=0;return outIdx-startIdx};function intArrayFromString(stringy,dontAddNull,length){var len=length>0?length:lengthBytesUTF8(stringy)+1;var u8array=new Array(len);var numBytesWritten=stringToUTF8Array(stringy,u8array,0,u8array.length);if(dontAddNull)u8array.length=numBytesWritten;return u8array}var FS_stdin_getChar=()=>{if(!FS_stdin_getChar_buffer.length){var result=null;if(typeof window!=\"undefined\"&&typeof window.prompt==\"function\"){result=window.prompt(\"Input: \");if(result!==null){result+=\"\\n\"}}else{}if(!result){return null}FS_stdin_getChar_buffer=intArrayFromString(result,true)}return FS_stdin_getChar_buffer.shift()};var TTY={ttys:[],init(){},shutdown(){},register(dev,ops){TTY.ttys[dev]={input:[],output:[],ops};FS.registerDevice(dev,TTY.stream_ops)},stream_ops:{open(stream){var tty=TTY.ttys[stream.node.rdev];if(!tty){throw new FS.ErrnoError(43)}stream.tty=tty;stream.seekable=false},close(stream){stream.tty.ops.fsync(stream.tty)},fsync(stream){stream.tty.ops.fsync(stream.tty)},read(stream,buffer,offset,length,pos){if(!stream.tty||!stream.tty.ops.get_char){throw new FS.ErrnoError(60)}var bytesRead=0;for(var i=0;i<length;i++){var result;try{result=stream.tty.ops.get_char(stream.tty)}catch(e){throw new FS.ErrnoError(29)}if(result===undefined&&bytesRead===0){throw new FS.ErrnoError(6)}if(result===null||result===undefined)break;bytesRead++;buffer[offset+i]=result}if(bytesRead){stream.node.timestamp=Date.now()}return bytesRead},write(stream,buffer,offset,length,pos){if(!stream.tty||!stream.tty.ops.put_char){throw new FS.ErrnoError(60)}try{for(var i=0;i<length;i++){stream.tty.ops.put_char(stream.tty,buffer[offset+i])}}catch(e){throw new FS.ErrnoError(29)}if(length){stream.node.timestamp=Date.now()}return i}},default_tty_ops:{get_char(tty){return FS_stdin_getChar()},put_char(tty,val){if(val===null||val===10){out(UTF8ArrayToString(tty.output));tty.output=[]}else{if(val!=0)tty.output.push(val)}},fsync(tty){if(tty.output&&tty.output.length>0){out(UTF8ArrayToString(tty.output));tty.output=[]}},ioctl_tcgets(tty){return{c_iflag:25856,c_oflag:5,c_cflag:191,c_lflag:35387,c_cc:[3,28,127,21,4,0,1,0,17,19,26,0,18,15,23,22,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]}},ioctl_tcsets(tty,optional_actions,data){return 0},ioctl_tiocgwinsz(tty){return[24,80]}},default_tty1_ops:{put_char(tty,val){if(val===null||val===10){err(UTF8ArrayToString(tty.output));tty.output=[]}else{if(val!=0)tty.output.push(val)}},fsync(tty){if(tty.output&&tty.output.length>0){err(UTF8ArrayToString(tty.output));tty.output=[]}}}};var alignMemory=(size,alignment)=>Math.ceil(size/alignment)*alignment;var mmapAlloc=size=>{abort()};var MEMFS={ops_table:null,mount(mount){return MEMFS.createNode(null,\"/\",16384|511,0)},createNode(parent,name,mode,dev){if(FS.isBlkdev(mode)||FS.isFIFO(mode)){throw new FS.ErrnoError(63)}MEMFS.ops_table||={dir:{node:{getattr:MEMFS.node_ops.getattr,setattr:MEMFS.node_ops.setattr,lookup:MEMFS.node_ops.lookup,mknod:MEMFS.node_ops.mknod,rename:MEMFS.node_ops.rename,unlink:MEMFS.node_ops.unlink,rmdir:MEMFS.node_ops.rmdir,readdir:MEMFS.node_ops.readdir,symlink:MEMFS.node_ops.symlink},stream:{llseek:MEMFS.stream_ops.llseek}},file:{node:{getattr:MEMFS.node_ops.getattr,setattr:MEMFS.node_ops.setattr},stream:{llseek:MEMFS.stream_ops.llseek,read:MEMFS.stream_ops.read,write:MEMFS.stream_ops.write,allocate:MEMFS.stream_ops.allocate,mmap:MEMFS.stream_ops.mmap,msync:MEMFS.stream_ops.msync}},link:{node:{getattr:MEMFS.node_ops.getattr,setattr:MEMFS.node_ops.setattr,readlink:MEMFS.node_ops.readlink},stream:{}},chrdev:{node:{getattr:MEMFS.node_ops.getattr,setattr:MEMFS.node_ops.setattr},stream:FS.chrdev_stream_ops}};var node=FS.createNode(parent,name,mode,dev);if(FS.isDir(node.mode)){node.node_ops=MEMFS.ops_table.dir.node;node.stream_ops=MEMFS.ops_table.dir.stream;node.contents={}}else if(FS.isFile(node.mode)){node.node_ops=MEMFS.ops_table.file.node;node.stream_ops=MEMFS.ops_table.file.stream;node.usedBytes=0;node.contents=null}else if(FS.isLink(node.mode)){node.node_ops=MEMFS.ops_table.link.node;node.stream_ops=MEMFS.ops_table.link.stream}else if(FS.isChrdev(node.mode)){node.node_ops=MEMFS.ops_table.chrdev.node;node.stream_ops=MEMFS.ops_table.chrdev.stream}node.timestamp=Date.now();if(parent){parent.contents[name]=node;parent.timestamp=node.timestamp}return node},getFileDataAsTypedArray(node){if(!node.contents)return new Uint8Array(0);if(node.contents.subarray)return node.contents.subarray(0,node.usedBytes);return new Uint8Array(node.contents)},expandFileStorage(node,newCapacity){var prevCapacity=node.contents?node.contents.length:0;if(prevCapacity>=newCapacity)return;var CAPACITY_DOUBLING_MAX=1024*1024;newCapacity=Math.max(newCapacity,prevCapacity*(prevCapacity<CAPACITY_DOUBLING_MAX?2:1.125)>>>0);if(prevCapacity!=0)newCapacity=Math.max(newCapacity,256);var oldContents=node.contents;node.contents=new Uint8Array(newCapacity);if(node.usedBytes>0)node.contents.set(oldContents.subarray(0,node.usedBytes),0)},resizeFileStorage(node,newSize){if(node.usedBytes==newSize)return;if(newSize==0){node.contents=null;node.usedBytes=0}else{var oldContents=node.contents;node.contents=new Uint8Array(newSize);if(oldContents){node.contents.set(oldContents.subarray(0,Math.min(newSize,node.usedBytes)))}node.usedBytes=newSize}},node_ops:{getattr(node){var attr={};attr.dev=FS.isChrdev(node.mode)?node.id:1;attr.ino=node.id;attr.mode=node.mode;attr.nlink=1;attr.uid=0;attr.gid=0;attr.rdev=node.rdev;if(FS.isDir(node.mode)){attr.size=4096}else if(FS.isFile(node.mode)){attr.size=node.usedBytes}else if(FS.isLink(node.mode)){attr.size=node.link.length}else{attr.size=0}attr.atime=new Date(node.timestamp);attr.mtime=new Date(node.timestamp);attr.ctime=new Date(node.timestamp);attr.blksize=4096;attr.blocks=Math.ceil(attr.size/attr.blksize);return attr},setattr(node,attr){if(attr.mode!==undefined){node.mode=attr.mode}if(attr.timestamp!==undefined){node.timestamp=attr.timestamp}if(attr.size!==undefined){MEMFS.resizeFileStorage(node,attr.size)}},lookup(parent,name){throw MEMFS.doesNotExistError},mknod(parent,name,mode,dev){return MEMFS.createNode(parent,name,mode,dev)},rename(old_node,new_dir,new_name){if(FS.isDir(old_node.mode)){var new_node;try{new_node=FS.lookupNode(new_dir,new_name)}catch(e){}if(new_node){for(var i in new_node.contents){throw new FS.ErrnoError(55)}}}delete old_node.parent.contents[old_node.name];old_node.parent.timestamp=Date.now();old_node.name=new_name;new_dir.contents[new_name]=old_node;new_dir.timestamp=old_node.parent.timestamp},unlink(parent,name){delete parent.contents[name];parent.timestamp=Date.now()},rmdir(parent,name){var node=FS.lookupNode(parent,name);for(var i in node.contents){throw new FS.ErrnoError(55)}delete parent.contents[name];parent.timestamp=Date.now()},readdir(node){var entries=[\".\",\"..\"];for(var key of Object.keys(node.contents)){entries.push(key)}return entries},symlink(parent,newname,oldpath){var node=MEMFS.createNode(parent,newname,511|40960,0);node.link=oldpath;return node},readlink(node){if(!FS.isLink(node.mode)){throw new FS.ErrnoError(28)}return node.link}},stream_ops:{read(stream,buffer,offset,length,position){var contents=stream.node.contents;if(position>=stream.node.usedBytes)return 0;var size=Math.min(stream.node.usedBytes-position,length);if(size>8&&contents.subarray){buffer.set(contents.subarray(position,position+size),offset)}else{for(var i=0;i<size;i++)buffer[offset+i]=contents[position+i]}return size},write(stream,buffer,offset,length,position,canOwn){if(buffer.buffer===GROWABLE_HEAP_I8().buffer){canOwn=false}if(!length)return 0;var node=stream.node;node.timestamp=Date.now();if(buffer.subarray&&(!node.contents||node.contents.subarray)){if(canOwn){node.contents=buffer.subarray(offset,offset+length);node.usedBytes=length;return length}else if(node.usedBytes===0&&position===0){node.contents=buffer.slice(offset,offset+length);node.usedBytes=length;return length}else if(position+length<=node.usedBytes){node.contents.set(buffer.subarray(offset,offset+length),position);return length}}MEMFS.expandFileStorage(node,position+length);if(node.contents.subarray&&buffer.subarray){node.contents.set(buffer.subarray(offset,offset+length),position)}else{for(var i=0;i<length;i++){node.contents[position+i]=buffer[offset+i]}}node.usedBytes=Math.max(node.usedBytes,position+length);return length},llseek(stream,offset,whence){var position=offset;if(whence===1){position+=stream.position}else if(whence===2){if(FS.isFile(stream.node.mode)){position+=stream.node.usedBytes}}if(position<0){throw new FS.ErrnoError(28)}return position},allocate(stream,offset,length){MEMFS.expandFileStorage(stream.node,offset+length);stream.node.usedBytes=Math.max(stream.node.usedBytes,offset+length)},mmap(stream,length,position,prot,flags){if(!FS.isFile(stream.node.mode)){throw new FS.ErrnoError(43)}var ptr;var allocated;var contents=stream.node.contents;if(!(flags&2)&&contents&&contents.buffer===GROWABLE_HEAP_I8().buffer){allocated=false;ptr=contents.byteOffset}else{allocated=true;ptr=mmapAlloc(length);if(!ptr){throw new FS.ErrnoError(48)}if(contents){if(position>0||position+length<contents.length){if(contents.subarray){contents=contents.subarray(position,position+length)}else{contents=Array.prototype.slice.call(contents,position,position+length)}}GROWABLE_HEAP_I8().set(contents,ptr>>>0)}}return{ptr,allocated}},msync(stream,buffer,offset,length,mmapFlags){MEMFS.stream_ops.write(stream,buffer,0,length,offset,false);return 0}}};var asyncLoad=(url,onload,onerror,noRunDep)=>{var dep=!noRunDep?getUniqueRunDependency(`al ${url}`):\"\";readAsync(url).then(arrayBuffer=>{onload(new Uint8Array(arrayBuffer));if(dep)removeRunDependency(dep)},err=>{if(onerror){onerror()}else{throw`Loading data file \"${url}\" failed.`}});if(dep)addRunDependency(dep)};var FS_createDataFile=(parent,name,fileData,canRead,canWrite,canOwn)=>{FS.createDataFile(parent,name,fileData,canRead,canWrite,canOwn)};var preloadPlugins=Module[\"preloadPlugins\"]||[];var FS_handledByPreloadPlugin=(byteArray,fullname,finish,onerror)=>{if(typeof Browser!=\"undefined\")Browser.init();var handled=false;preloadPlugins.forEach(plugin=>{if(handled)return;if(plugin[\"canHandle\"](fullname)){plugin[\"handle\"](byteArray,fullname,finish,onerror);handled=true}});return handled};var FS_createPreloadedFile=(parent,name,url,canRead,canWrite,onload,onerror,dontCreateFile,canOwn,preFinish)=>{var fullname=name?PATH_FS.resolve(PATH.join2(parent,name)):parent;var dep=getUniqueRunDependency(`cp ${fullname}`);function processData(byteArray){function finish(byteArray){preFinish?.();if(!dontCreateFile){FS_createDataFile(parent,name,byteArray,canRead,canWrite,canOwn)}onload?.();removeRunDependency(dep)}if(FS_handledByPreloadPlugin(byteArray,fullname,finish,()=>{onerror?.();removeRunDependency(dep)})){return}finish(byteArray)}addRunDependency(dep);if(typeof url==\"string\"){asyncLoad(url,processData,onerror)}else{processData(url)}};var FS_modeStringToFlags=str=>{var flagModes={r:0,\"r+\":2,w:512|64|1,\"w+\":512|64|2,a:1024|64|1,\"a+\":1024|64|2};var flags=flagModes[str];if(typeof flags==\"undefined\"){throw new Error(`Unknown file open mode: ${str}`)}return flags};var FS_getMode=(canRead,canWrite)=>{var mode=0;if(canRead)mode|=292|73;if(canWrite)mode|=146;return mode};var WORKERFS={DIR_MODE:16895,FILE_MODE:33279,reader:null,mount(mount){assert(ENVIRONMENT_IS_WORKER);WORKERFS.reader??=new FileReaderSync;var root=WORKERFS.createNode(null,\"/\",WORKERFS.DIR_MODE,0);var createdParents={};function ensureParent(path){var parts=path.split(\"/\");var parent=root;for(var i=0;i<parts.length-1;i++){var curr=parts.slice(0,i+1).join(\"/\");createdParents[curr]||=WORKERFS.createNode(parent,parts[i],WORKERFS.DIR_MODE,0);parent=createdParents[curr]}return parent}function base(path){var parts=path.split(\"/\");return parts[parts.length-1]}Array.prototype.forEach.call(mount.opts[\"files\"]||[],function(file){WORKERFS.createNode(ensureParent(file.name),base(file.name),WORKERFS.FILE_MODE,0,file,file.lastModifiedDate)});(mount.opts[\"blobs\"]||[]).forEach(obj=>{WORKERFS.createNode(ensureParent(obj[\"name\"]),base(obj[\"name\"]),WORKERFS.FILE_MODE,0,obj[\"data\"])});(mount.opts[\"packages\"]||[]).forEach(pack=>{pack[\"metadata\"].files.forEach(file=>{var name=file.filename.substr(1);WORKERFS.createNode(ensureParent(name),base(name),WORKERFS.FILE_MODE,0,pack[\"blob\"].slice(file.start,file.end))})});return root},createNode(parent,name,mode,dev,contents,mtime){var node=FS.createNode(parent,name,mode);node.mode=mode;node.node_ops=WORKERFS.node_ops;node.stream_ops=WORKERFS.stream_ops;node.timestamp=(mtime||new Date).getTime();assert(WORKERFS.FILE_MODE!==WORKERFS.DIR_MODE);if(mode===WORKERFS.FILE_MODE){node.size=contents.size;node.contents=contents}else{node.size=4096;node.contents={}}if(parent){parent.contents[name]=node}return node},node_ops:{getattr(node){return{dev:1,ino:node.id,mode:node.mode,nlink:1,uid:0,gid:0,rdev:0,size:node.size,atime:new Date(node.timestamp),mtime:new Date(node.timestamp),ctime:new Date(node.timestamp),blksize:4096,blocks:Math.ceil(node.size/4096)}},setattr(node,attr){if(attr.mode!==undefined){node.mode=attr.mode}if(attr.timestamp!==undefined){node.timestamp=attr.timestamp}},lookup(parent,name){throw new FS.ErrnoError(44)},mknod(parent,name,mode,dev){throw new FS.ErrnoError(63)},rename(oldNode,newDir,newName){throw new FS.ErrnoError(63)},unlink(parent,name){throw new FS.ErrnoError(63)},rmdir(parent,name){throw new FS.ErrnoError(63)},readdir(node){var entries=[\".\",\"..\"];for(var key of Object.keys(node.contents)){entries.push(key)}return entries},symlink(parent,newName,oldPath){throw new FS.ErrnoError(63)}},stream_ops:{read(stream,buffer,offset,length,position){if(position>=stream.node.size)return 0;var chunk=stream.node.contents.slice(position,position+length);var ab=WORKERFS.reader.readAsArrayBuffer(chunk);buffer.set(new Uint8Array(ab),offset);return chunk.size},write(stream,buffer,offset,length,position){throw new FS.ErrnoError(29)},llseek(stream,offset,whence){var position=offset;if(whence===1){position+=stream.position}else if(whence===2){if(FS.isFile(stream.node.mode)){position+=stream.node.size}}if(position<0){throw new FS.ErrnoError(28)}return position}}};var FS={root:null,mounts:[],devices:{},streams:[],nextInode:1,nameTable:null,currentPath:\"/\",initialized:false,ignorePermissions:true,ErrnoError:class{name=\"ErrnoError\";constructor(errno){this.errno=errno}},filesystems:null,syncFSRequests:0,readFiles:{},FSStream:class{shared={};get object(){return this.node}set object(val){this.node=val}get isRead(){return(this.flags&2097155)!==1}get isWrite(){return(this.flags&2097155)!==0}get isAppend(){return this.flags&1024}get flags(){return this.shared.flags}set flags(val){this.shared.flags=val}get position(){return this.shared.position}set position(val){this.shared.position=val}},FSNode:class{node_ops={};stream_ops={};readMode=292|73;writeMode=146;mounted=null;constructor(parent,name,mode,rdev){if(!parent){parent=this}this.parent=parent;this.mount=parent.mount;this.id=FS.nextInode++;this.name=name;this.mode=mode;this.rdev=rdev}get read(){return(this.mode&this.readMode)===this.readMode}set read(val){val?this.mode|=this.readMode:this.mode&=~this.readMode}get write(){return(this.mode&this.writeMode)===this.writeMode}set write(val){val?this.mode|=this.writeMode:this.mode&=~this.writeMode}get isFolder(){return FS.isDir(this.mode)}get isDevice(){return FS.isChrdev(this.mode)}},lookupPath(path,opts={}){path=PATH_FS.resolve(path);if(!path)return{path:\"\",node:null};var defaults={follow_mount:true,recurse_count:0};opts=Object.assign(defaults,opts);if(opts.recurse_count>8){throw new FS.ErrnoError(32)}var parts=path.split(\"/\").filter(p=>!!p);var current=FS.root;var current_path=\"/\";for(var i=0;i<parts.length;i++){var islast=i===parts.length-1;if(islast&&opts.parent){break}current=FS.lookupNode(current,parts[i]);current_path=PATH.join2(current_path,parts[i]);if(FS.isMountpoint(current)){if(!islast||islast&&opts.follow_mount){current=current.mounted.root}}if(!islast||opts.follow){var count=0;while(FS.isLink(current.mode)){var link=FS.readlink(current_path);current_path=PATH_FS.resolve(PATH.dirname(current_path),link);var lookup=FS.lookupPath(current_path,{recurse_count:opts.recurse_count+1});current=lookup.node;if(count++>40){throw new FS.ErrnoError(32)}}}}return{path:current_path,node:current}},getPath(node){var path;while(true){if(FS.isRoot(node)){var mount=node.mount.mountpoint;if(!path)return mount;return mount[mount.length-1]!==\"/\"?`${mount}/${path}`:mount+path}path=path?`${node.name}/${path}`:node.name;node=node.parent}},hashName(parentid,name){var hash=0;for(var i=0;i<name.length;i++){hash=(hash<<5)-hash+name.charCodeAt(i)|0}return(parentid+hash>>>0)%FS.nameTable.length},hashAddNode(node){var hash=FS.hashName(node.parent.id,node.name);node.name_next=FS.nameTable[hash];FS.nameTable[hash]=node},hashRemoveNode(node){var hash=FS.hashName(node.parent.id,node.name);if(FS.nameTable[hash]===node){FS.nameTable[hash]=node.name_next}else{var current=FS.nameTable[hash];while(current){if(current.name_next===node){current.name_next=node.name_next;break}current=current.name_next}}},lookupNode(parent,name){var errCode=FS.mayLookup(parent);if(errCode){throw new FS.ErrnoError(errCode)}var hash=FS.hashName(parent.id,name);for(var node=FS.nameTable[hash];node;node=node.name_next){var nodeName=node.name;if(node.parent.id===parent.id&&nodeName===name){return node}}return FS.lookup(parent,name)},createNode(parent,name,mode,rdev){var node=new FS.FSNode(parent,name,mode,rdev);FS.hashAddNode(node);return node},destroyNode(node){FS.hashRemoveNode(node)},isRoot(node){return node===node.parent},isMountpoint(node){return!!node.mounted},isFile(mode){return(mode&61440)===32768},isDir(mode){return(mode&61440)===16384},isLink(mode){return(mode&61440)===40960},isChrdev(mode){return(mode&61440)===8192},isBlkdev(mode){return(mode&61440)===24576},isFIFO(mode){return(mode&61440)===4096},isSocket(mode){return(mode&49152)===49152},flagsToPermissionString(flag){var perms=[\"r\",\"w\",\"rw\"][flag&3];if(flag&512){perms+=\"w\"}return perms},nodePermissions(node,perms){if(FS.ignorePermissions){return 0}if(perms.includes(\"r\")&&!(node.mode&292)){return 2}else if(perms.includes(\"w\")&&!(node.mode&146)){return 2}else if(perms.includes(\"x\")&&!(node.mode&73)){return 2}return 0},mayLookup(dir){if(!FS.isDir(dir.mode))return 54;var errCode=FS.nodePermissions(dir,\"x\");if(errCode)return errCode;if(!dir.node_ops.lookup)return 2;return 0},mayCreate(dir,name){try{var node=FS.lookupNode(dir,name);return 20}catch(e){}return FS.nodePermissions(dir,\"wx\")},mayDelete(dir,name,isdir){var node;try{node=FS.lookupNode(dir,name)}catch(e){return e.errno}var errCode=FS.nodePermissions(dir,\"wx\");if(errCode){return errCode}if(isdir){if(!FS.isDir(node.mode)){return 54}if(FS.isRoot(node)||FS.getPath(node)===FS.cwd()){return 10}}else{if(FS.isDir(node.mode)){return 31}}return 0},mayOpen(node,flags){if(!node){return 44}if(FS.isLink(node.mode)){return 32}else if(FS.isDir(node.mode)){if(FS.flagsToPermissionString(flags)!==\"r\"||flags&512){return 31}}return FS.nodePermissions(node,FS.flagsToPermissionString(flags))},MAX_OPEN_FDS:4096,nextfd(){for(var fd=0;fd<=FS.MAX_OPEN_FDS;fd++){if(!FS.streams[fd]){return fd}}throw new FS.ErrnoError(33)},getStreamChecked(fd){var stream=FS.getStream(fd);if(!stream){throw new FS.ErrnoError(8)}return stream},getStream:fd=>FS.streams[fd],createStream(stream,fd=-1){stream=Object.assign(new FS.FSStream,stream);if(fd==-1){fd=FS.nextfd()}stream.fd=fd;FS.streams[fd]=stream;return stream},closeStream(fd){FS.streams[fd]=null},dupStream(origStream,fd=-1){var stream=FS.createStream(origStream,fd);stream.stream_ops?.dup?.(stream);return stream},chrdev_stream_ops:{open(stream){var device=FS.getDevice(stream.node.rdev);stream.stream_ops=device.stream_ops;stream.stream_ops.open?.(stream)},llseek(){throw new FS.ErrnoError(70)}},major:dev=>dev>>8,minor:dev=>dev&255,makedev:(ma,mi)=>ma<<8|mi,registerDevice(dev,ops){FS.devices[dev]={stream_ops:ops}},getDevice:dev=>FS.devices[dev],getMounts(mount){var mounts=[];var check=[mount];while(check.length){var m=check.pop();mounts.push(m);check.push(...m.mounts)}return mounts},syncfs(populate,callback){if(typeof populate==\"function\"){callback=populate;populate=false}FS.syncFSRequests++;if(FS.syncFSRequests>1){err(`warning: ${FS.syncFSRequests} FS.syncfs operations in flight at once, probably just doing extra work`)}var mounts=FS.getMounts(FS.root.mount);var completed=0;function doCallback(errCode){FS.syncFSRequests--;return callback(errCode)}function done(errCode){if(errCode){if(!done.errored){done.errored=true;return doCallback(errCode)}return}if(++completed>=mounts.length){doCallback(null)}}mounts.forEach(mount=>{if(!mount.type.syncfs){return done(null)}mount.type.syncfs(mount,populate,done)})},mount(type,opts,mountpoint){var root=mountpoint===\"/\";var pseudo=!mountpoint;var node;if(root&&FS.root){throw new FS.ErrnoError(10)}else if(!root&&!pseudo){var lookup=FS.lookupPath(mountpoint,{follow_mount:false});mountpoint=lookup.path;node=lookup.node;if(FS.isMountpoint(node)){throw new FS.ErrnoError(10)}if(!FS.isDir(node.mode)){throw new FS.ErrnoError(54)}}var mount={type,opts,mountpoint,mounts:[]};var mountRoot=type.mount(mount);mountRoot.mount=mount;mount.root=mountRoot;if(root){FS.root=mountRoot}else if(node){node.mounted=mount;if(node.mount){node.mount.mounts.push(mount)}}return mountRoot},unmount(mountpoint){var lookup=FS.lookupPath(mountpoint,{follow_mount:false});if(!FS.isMountpoint(lookup.node)){throw new FS.ErrnoError(28)}var node=lookup.node;var mount=node.mounted;var mounts=FS.getMounts(mount);Object.keys(FS.nameTable).forEach(hash=>{var current=FS.nameTable[hash];while(current){var next=current.name_next;if(mounts.includes(current.mount)){FS.destroyNode(current)}current=next}});node.mounted=null;var idx=node.mount.mounts.indexOf(mount);node.mount.mounts.splice(idx,1)},lookup(parent,name){return parent.node_ops.lookup(parent,name)},mknod(path,mode,dev){var lookup=FS.lookupPath(path,{parent:true});var parent=lookup.node;var name=PATH.basename(path);if(!name||name===\".\"||name===\"..\"){throw new FS.ErrnoError(28)}var errCode=FS.mayCreate(parent,name);if(errCode){throw new FS.ErrnoError(errCode)}if(!parent.node_ops.mknod){throw new FS.ErrnoError(63)}return parent.node_ops.mknod(parent,name,mode,dev)},create(path,mode){mode=mode!==undefined?mode:438;mode&=4095;mode|=32768;return FS.mknod(path,mode,0)},mkdir(path,mode){mode=mode!==undefined?mode:511;mode&=511|512;mode|=16384;return FS.mknod(path,mode,0)},mkdirTree(path,mode){var dirs=path.split(\"/\");var d=\"\";for(var i=0;i<dirs.length;++i){if(!dirs[i])continue;d+=\"/\"+dirs[i];try{FS.mkdir(d,mode)}catch(e){if(e.errno!=20)throw e}}},mkdev(path,mode,dev){if(typeof dev==\"undefined\"){dev=mode;mode=438}mode|=8192;return FS.mknod(path,mode,dev)},symlink(oldpath,newpath){if(!PATH_FS.resolve(oldpath)){throw new FS.ErrnoError(44)}var lookup=FS.lookupPath(newpath,{parent:true});var parent=lookup.node;if(!parent){throw new FS.ErrnoError(44)}var newname=PATH.basename(newpath);var errCode=FS.mayCreate(parent,newname);if(errCode){throw new FS.ErrnoError(errCode)}if(!parent.node_ops.symlink){throw new FS.ErrnoError(63)}return parent.node_ops.symlink(parent,newname,oldpath)},rename(old_path,new_path){var old_dirname=PATH.dirname(old_path);var new_dirname=PATH.dirname(new_path);var old_name=PATH.basename(old_path);var new_name=PATH.basename(new_path);var lookup,old_dir,new_dir;lookup=FS.lookupPath(old_path,{parent:true});old_dir=lookup.node;lookup=FS.lookupPath(new_path,{parent:true});new_dir=lookup.node;if(!old_dir||!new_dir)throw new FS.ErrnoError(44);if(old_dir.mount!==new_dir.mount){throw new FS.ErrnoError(75)}var old_node=FS.lookupNode(old_dir,old_name);var relative=PATH_FS.relative(old_path,new_dirname);if(relative.charAt(0)!==\".\"){throw new FS.ErrnoError(28)}relative=PATH_FS.relative(new_path,old_dirname);if(relative.charAt(0)!==\".\"){throw new FS.ErrnoError(55)}var new_node;try{new_node=FS.lookupNode(new_dir,new_name)}catch(e){}if(old_node===new_node){return}var isdir=FS.isDir(old_node.mode);var errCode=FS.mayDelete(old_dir,old_name,isdir);if(errCode){throw new FS.ErrnoError(errCode)}errCode=new_node?FS.mayDelete(new_dir,new_name,isdir):FS.mayCreate(new_dir,new_name);if(errCode){throw new FS.ErrnoError(errCode)}if(!old_dir.node_ops.rename){throw new FS.ErrnoError(63)}if(FS.isMountpoint(old_node)||new_node&&FS.isMountpoint(new_node)){throw new FS.ErrnoError(10)}if(new_dir!==old_dir){errCode=FS.nodePermissions(old_dir,\"w\");if(errCode){throw new FS.ErrnoError(errCode)}}FS.hashRemoveNode(old_node);try{old_dir.node_ops.rename(old_node,new_dir,new_name);old_node.parent=new_dir}catch(e){throw e}finally{FS.hashAddNode(old_node)}},rmdir(path){var lookup=FS.lookupPath(path,{parent:true});var parent=lookup.node;var name=PATH.basename(path);var node=FS.lookupNode(parent,name);var errCode=FS.mayDelete(parent,name,true);if(errCode){throw new FS.ErrnoError(errCode)}if(!parent.node_ops.rmdir){throw new FS.ErrnoError(63)}if(FS.isMountpoint(node)){throw new FS.ErrnoError(10)}parent.node_ops.rmdir(parent,name);FS.destroyNode(node)},readdir(path){var lookup=FS.lookupPath(path,{follow:true});var node=lookup.node;if(!node.node_ops.readdir){throw new FS.ErrnoError(54)}return node.node_ops.readdir(node)},unlink(path){var lookup=FS.lookupPath(path,{parent:true});var parent=lookup.node;if(!parent){throw new FS.ErrnoError(44)}var name=PATH.basename(path);var node=FS.lookupNode(parent,name);var errCode=FS.mayDelete(parent,name,false);if(errCode){throw new FS.ErrnoError(errCode)}if(!parent.node_ops.unlink){throw new FS.ErrnoError(63)}if(FS.isMountpoint(node)){throw new FS.ErrnoError(10)}parent.node_ops.unlink(parent,name);FS.destroyNode(node)},readlink(path){var lookup=FS.lookupPath(path);var link=lookup.node;if(!link){throw new FS.ErrnoError(44)}if(!link.node_ops.readlink){throw new FS.ErrnoError(28)}return PATH_FS.resolve(FS.getPath(link.parent),link.node_ops.readlink(link))},stat(path,dontFollow){var lookup=FS.lookupPath(path,{follow:!dontFollow});var node=lookup.node;if(!node){throw new FS.ErrnoError(44)}if(!node.node_ops.getattr){throw new FS.ErrnoError(63)}return node.node_ops.getattr(node)},lstat(path){return FS.stat(path,true)},chmod(path,mode,dontFollow){var node;if(typeof path==\"string\"){var lookup=FS.lookupPath(path,{follow:!dontFollow});node=lookup.node}else{node=path}if(!node.node_ops.setattr){throw new FS.ErrnoError(63)}node.node_ops.setattr(node,{mode:mode&4095|node.mode&~4095,timestamp:Date.now()})},lchmod(path,mode){FS.chmod(path,mode,true)},fchmod(fd,mode){var stream=FS.getStreamChecked(fd);FS.chmod(stream.node,mode)},chown(path,uid,gid,dontFollow){var node;if(typeof path==\"string\"){var lookup=FS.lookupPath(path,{follow:!dontFollow});node=lookup.node}else{node=path}if(!node.node_ops.setattr){throw new FS.ErrnoError(63)}node.node_ops.setattr(node,{timestamp:Date.now()})},lchown(path,uid,gid){FS.chown(path,uid,gid,true)},fchown(fd,uid,gid){var stream=FS.getStreamChecked(fd);FS.chown(stream.node,uid,gid)},truncate(path,len){if(len<0){throw new FS.ErrnoError(28)}var node;if(typeof path==\"string\"){var lookup=FS.lookupPath(path,{follow:true});node=lookup.node}else{node=path}if(!node.node_ops.setattr){throw new FS.ErrnoError(63)}if(FS.isDir(node.mode)){throw new FS.ErrnoError(31)}if(!FS.isFile(node.mode)){throw new FS.ErrnoError(28)}var errCode=FS.nodePermissions(node,\"w\");if(errCode){throw new FS.ErrnoError(errCode)}node.node_ops.setattr(node,{size:len,timestamp:Date.now()})},ftruncate(fd,len){var stream=FS.getStreamChecked(fd);if((stream.flags&2097155)===0){throw new FS.ErrnoError(28)}FS.truncate(stream.node,len)},utime(path,atime,mtime){var lookup=FS.lookupPath(path,{follow:true});var node=lookup.node;node.node_ops.setattr(node,{timestamp:Math.max(atime,mtime)})},open(path,flags,mode){if(path===\"\"){throw new FS.ErrnoError(44)}flags=typeof flags==\"string\"?FS_modeStringToFlags(flags):flags;if(flags&64){mode=typeof mode==\"undefined\"?438:mode;mode=mode&4095|32768}else{mode=0}var node;if(typeof path==\"object\"){node=path}else{path=PATH.normalize(path);try{var lookup=FS.lookupPath(path,{follow:!(flags&131072)});node=lookup.node}catch(e){}}var created=false;if(flags&64){if(node){if(flags&128){throw new FS.ErrnoError(20)}}else{node=FS.mknod(path,mode,0);created=true}}if(!node){throw new FS.ErrnoError(44)}if(FS.isChrdev(node.mode)){flags&=~512}if(flags&65536&&!FS.isDir(node.mode)){throw new FS.ErrnoError(54)}if(!created){var errCode=FS.mayOpen(node,flags);if(errCode){throw new FS.ErrnoError(errCode)}}if(flags&512&&!created){FS.truncate(node,0)}flags&=~(128|512|131072);var stream=FS.createStream({node,path:FS.getPath(node),flags,seekable:true,position:0,stream_ops:node.stream_ops,ungotten:[],error:false});if(stream.stream_ops.open){stream.stream_ops.open(stream)}if(Module[\"logReadFiles\"]&&!(flags&1)){if(!(path in FS.readFiles)){FS.readFiles[path]=1}}return stream},close(stream){if(FS.isClosed(stream)){throw new FS.ErrnoError(8)}if(stream.getdents)stream.getdents=null;try{if(stream.stream_ops.close){stream.stream_ops.close(stream)}}catch(e){throw e}finally{FS.closeStream(stream.fd)}stream.fd=null},isClosed(stream){return stream.fd===null},llseek(stream,offset,whence){if(FS.isClosed(stream)){throw new FS.ErrnoError(8)}if(!stream.seekable||!stream.stream_ops.llseek){throw new FS.ErrnoError(70)}if(whence!=0&&whence!=1&&whence!=2){throw new FS.ErrnoError(28)}stream.position=stream.stream_ops.llseek(stream,offset,whence);stream.ungotten=[];return stream.position},read(stream,buffer,offset,length,position){if(length<0||position<0){throw new FS.ErrnoError(28)}if(FS.isClosed(stream)){throw new FS.ErrnoError(8)}if((stream.flags&2097155)===1){throw new FS.ErrnoError(8)}if(FS.isDir(stream.node.mode)){throw new FS.ErrnoError(31)}if(!stream.stream_ops.read){throw new FS.ErrnoError(28)}var seeking=typeof position!=\"undefined\";if(!seeking){position=stream.position}else if(!stream.seekable){throw new FS.ErrnoError(70)}var bytesRead=stream.stream_ops.read(stream,buffer,offset,length,position);if(!seeking)stream.position+=bytesRead;return bytesRead},write(stream,buffer,offset,length,position,canOwn){if(length<0||position<0){throw new FS.ErrnoError(28)}if(FS.isClosed(stream)){throw new FS.ErrnoError(8)}if((stream.flags&2097155)===0){throw new FS.ErrnoError(8)}if(FS.isDir(stream.node.mode)){throw new FS.ErrnoError(31)}if(!stream.stream_ops.write){throw new FS.ErrnoError(28)}if(stream.seekable&&stream.flags&1024){FS.llseek(stream,0,2)}var seeking=typeof position!=\"undefined\";if(!seeking){position=stream.position}else if(!stream.seekable){throw new FS.ErrnoError(70)}var bytesWritten=stream.stream_ops.write(stream,buffer,offset,length,position,canOwn);if(!seeking)stream.position+=bytesWritten;return bytesWritten},allocate(stream,offset,length){if(FS.isClosed(stream)){throw new FS.ErrnoError(8)}if(offset<0||length<=0){throw new FS.ErrnoError(28)}if((stream.flags&2097155)===0){throw new FS.ErrnoError(8)}if(!FS.isFile(stream.node.mode)&&!FS.isDir(stream.node.mode)){throw new FS.ErrnoError(43)}if(!stream.stream_ops.allocate){throw new FS.ErrnoError(138)}stream.stream_ops.allocate(stream,offset,length)},mmap(stream,length,position,prot,flags){if((prot&2)!==0&&(flags&2)===0&&(stream.flags&2097155)!==2){throw new FS.ErrnoError(2)}if((stream.flags&2097155)===1){throw new FS.ErrnoError(2)}if(!stream.stream_ops.mmap){throw new FS.ErrnoError(43)}if(!length){throw new FS.ErrnoError(28)}return stream.stream_ops.mmap(stream,length,position,prot,flags)},msync(stream,buffer,offset,length,mmapFlags){if(!stream.stream_ops.msync){return 0}return stream.stream_ops.msync(stream,buffer,offset,length,mmapFlags)},ioctl(stream,cmd,arg){if(!stream.stream_ops.ioctl){throw new FS.ErrnoError(59)}return stream.stream_ops.ioctl(stream,cmd,arg)},readFile(path,opts={}){opts.flags=opts.flags||0;opts.encoding=opts.encoding||\"binary\";if(opts.encoding!==\"utf8\"&&opts.encoding!==\"binary\"){throw new Error(`Invalid encoding type \"${opts.encoding}\"`)}var ret;var stream=FS.open(path,opts.flags);var stat=FS.stat(path);var length=stat.size;var buf=new Uint8Array(length);FS.read(stream,buf,0,length,0);if(opts.encoding===\"utf8\"){ret=UTF8ArrayToString(buf)}else if(opts.encoding===\"binary\"){ret=buf}FS.close(stream);return ret},writeFile(path,data,opts={}){opts.flags=opts.flags||577;var stream=FS.open(path,opts.flags,opts.mode);if(typeof data==\"string\"){var buf=new Uint8Array(lengthBytesUTF8(data)+1);var actualNumBytes=stringToUTF8Array(data,buf,0,buf.length);FS.write(stream,buf,0,actualNumBytes,undefined,opts.canOwn)}else if(ArrayBuffer.isView(data)){FS.write(stream,data,0,data.byteLength,undefined,opts.canOwn)}else{throw new Error(\"Unsupported data type\")}FS.close(stream)},cwd:()=>FS.currentPath,chdir(path){var lookup=FS.lookupPath(path,{follow:true});if(lookup.node===null){throw new FS.ErrnoError(44)}if(!FS.isDir(lookup.node.mode)){throw new FS.ErrnoError(54)}var errCode=FS.nodePermissions(lookup.node,\"x\");if(errCode){throw new FS.ErrnoError(errCode)}FS.currentPath=lookup.path},createDefaultDirectories(){FS.mkdir(\"/tmp\");FS.mkdir(\"/home\");FS.mkdir(\"/home/web_user\")},createDefaultDevices(){FS.mkdir(\"/dev\");FS.registerDevice(FS.makedev(1,3),{read:()=>0,write:(stream,buffer,offset,length,pos)=>length,llseek:()=>0});FS.mkdev(\"/dev/null\",FS.makedev(1,3));TTY.register(FS.makedev(5,0),TTY.default_tty_ops);TTY.register(FS.makedev(6,0),TTY.default_tty1_ops);FS.mkdev(\"/dev/tty\",FS.makedev(5,0));FS.mkdev(\"/dev/tty1\",FS.makedev(6,0));var randomBuffer=new Uint8Array(1024),randomLeft=0;var randomByte=()=>{if(randomLeft===0){randomLeft=randomFill(randomBuffer).byteLength}return randomBuffer[--randomLeft]};FS.createDevice(\"/dev\",\"random\",randomByte);FS.createDevice(\"/dev\",\"urandom\",randomByte);FS.mkdir(\"/dev/shm\");FS.mkdir(\"/dev/shm/tmp\")},createSpecialDirectories(){FS.mkdir(\"/proc\");var proc_self=FS.mkdir(\"/proc/self\");FS.mkdir(\"/proc/self/fd\");FS.mount({mount(){var node=FS.createNode(proc_self,\"fd\",16384|511,73);node.node_ops={lookup(parent,name){var fd=+name;var stream=FS.getStreamChecked(fd);var ret={parent:null,mount:{mountpoint:\"fake\"},node_ops:{readlink:()=>stream.path}};ret.parent=ret;return ret}};return node}},{},\"/proc/self/fd\")},createStandardStreams(input,output,error){if(input){FS.createDevice(\"/dev\",\"stdin\",input)}else{FS.symlink(\"/dev/tty\",\"/dev/stdin\")}if(output){FS.createDevice(\"/dev\",\"stdout\",null,output)}else{FS.symlink(\"/dev/tty\",\"/dev/stdout\")}if(error){FS.createDevice(\"/dev\",\"stderr\",null,error)}else{FS.symlink(\"/dev/tty1\",\"/dev/stderr\")}var stdin=FS.open(\"/dev/stdin\",0);var stdout=FS.open(\"/dev/stdout\",1);var stderr=FS.open(\"/dev/stderr\",1)},staticInit(){FS.nameTable=new Array(4096);FS.mount(MEMFS,{},\"/\");FS.createDefaultDirectories();FS.createDefaultDevices();FS.createSpecialDirectories();FS.filesystems={MEMFS,WORKERFS}},init(input,output,error){FS.initialized=true;input??=Module[\"stdin\"];output??=Module[\"stdout\"];error??=Module[\"stderr\"];FS.createStandardStreams(input,output,error)},quit(){FS.initialized=false;for(var i=0;i<FS.streams.length;i++){var stream=FS.streams[i];if(!stream){continue}FS.close(stream)}},findObject(path,dontResolveLastLink){var ret=FS.analyzePath(path,dontResolveLastLink);if(!ret.exists){return null}return ret.object},analyzePath(path,dontResolveLastLink){try{var lookup=FS.lookupPath(path,{follow:!dontResolveLastLink});path=lookup.path}catch(e){}var ret={isRoot:false,exists:false,error:0,name:null,path:null,object:null,parentExists:false,parentPath:null,parentObject:null};try{var lookup=FS.lookupPath(path,{parent:true});ret.parentExists=true;ret.parentPath=lookup.path;ret.parentObject=lookup.node;ret.name=PATH.basename(path);lookup=FS.lookupPath(path,{follow:!dontResolveLastLink});ret.exists=true;ret.path=lookup.path;ret.object=lookup.node;ret.name=lookup.node.name;ret.isRoot=lookup.path===\"/\"}catch(e){ret.error=e.errno}return ret},createPath(parent,path,canRead,canWrite){parent=typeof parent==\"string\"?parent:FS.getPath(parent);var parts=path.split(\"/\").reverse();while(parts.length){var part=parts.pop();if(!part)continue;var current=PATH.join2(parent,part);try{FS.mkdir(current)}catch(e){}parent=current}return current},createFile(parent,name,properties,canRead,canWrite){var path=PATH.join2(typeof parent==\"string\"?parent:FS.getPath(parent),name);var mode=FS_getMode(canRead,canWrite);return FS.create(path,mode)},createDataFile(parent,name,data,canRead,canWrite,canOwn){var path=name;if(parent){parent=typeof parent==\"string\"?parent:FS.getPath(parent);path=name?PATH.join2(parent,name):parent}var mode=FS_getMode(canRead,canWrite);var node=FS.create(path,mode);if(data){if(typeof data==\"string\"){var arr=new Array(data.length);for(var i=0,len=data.length;i<len;++i)arr[i]=data.charCodeAt(i);data=arr}FS.chmod(node,mode|146);var stream=FS.open(node,577);FS.write(stream,data,0,data.length,0,canOwn);FS.close(stream);FS.chmod(node,mode)}},createDevice(parent,name,input,output){var path=PATH.join2(typeof parent==\"string\"?parent:FS.getPath(parent),name);var mode=FS_getMode(!!input,!!output);FS.createDevice.major??=64;var dev=FS.makedev(FS.createDevice.major++,0);FS.registerDevice(dev,{open(stream){stream.seekable=false},close(stream){if(output?.buffer?.length){output(10)}},read(stream,buffer,offset,length,pos){var bytesRead=0;for(var i=0;i<length;i++){var result;try{result=input()}catch(e){throw new FS.ErrnoError(29)}if(result===undefined&&bytesRead===0){throw new FS.ErrnoError(6)}if(result===null||result===undefined)break;bytesRead++;buffer[offset+i]=result}if(bytesRead){stream.node.timestamp=Date.now()}return bytesRead},write(stream,buffer,offset,length,pos){for(var i=0;i<length;i++){try{output(buffer[offset+i])}catch(e){throw new FS.ErrnoError(29)}}if(length){stream.node.timestamp=Date.now()}return i}});return FS.mkdev(path,mode,dev)},forceLoadFile(obj){if(obj.isDevice||obj.isFolder||obj.link||obj.contents)return true;if(typeof XMLHttpRequest!=\"undefined\"){throw new Error(\"Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.\")}else{try{obj.contents=readBinary(obj.url);obj.usedBytes=obj.contents.length}catch(e){throw new FS.ErrnoError(29)}}},createLazyFile(parent,name,url,canRead,canWrite){class LazyUint8Array{lengthKnown=false;chunks=[];get(idx){if(idx>this.length-1||idx<0){return undefined}var chunkOffset=idx%this.chunkSize;var chunkNum=idx/this.chunkSize|0;return this.getter(chunkNum)[chunkOffset]}setDataGetter(getter){this.getter=getter}cacheLength(){var xhr=new XMLHttpRequest;xhr.open(\"HEAD\",url,false);xhr.send(null);if(!(xhr.status>=200&&xhr.status<300||xhr.status===304))throw new Error(\"Couldn't load \"+url+\". Status: \"+xhr.status);var datalength=Number(xhr.getResponseHeader(\"Content-length\"));var header;var hasByteServing=(header=xhr.getResponseHeader(\"Accept-Ranges\"))&&header===\"bytes\";var usesGzip=(header=xhr.getResponseHeader(\"Content-Encoding\"))&&header===\"gzip\";var chunkSize=1024*1024;if(!hasByteServing)chunkSize=datalength;var doXHR=(from,to)=>{if(from>to)throw new Error(\"invalid range (\"+from+\", \"+to+\") or no bytes requested!\");if(to>datalength-1)throw new Error(\"only \"+datalength+\" bytes available! programmer error!\");var xhr=new XMLHttpRequest;xhr.open(\"GET\",url,false);if(datalength!==chunkSize)xhr.setRequestHeader(\"Range\",\"bytes=\"+from+\"-\"+to);xhr.responseType=\"arraybuffer\";if(xhr.overrideMimeType){xhr.overrideMimeType(\"text/plain; charset=x-user-defined\")}xhr.send(null);if(!(xhr.status>=200&&xhr.status<300||xhr.status===304))throw new Error(\"Couldn't load \"+url+\". Status: \"+xhr.status);if(xhr.response!==undefined){return new Uint8Array(xhr.response||[])}return intArrayFromString(xhr.responseText||\"\",true)};var lazyArray=this;lazyArray.setDataGetter(chunkNum=>{var start=chunkNum*chunkSize;var end=(chunkNum+1)*chunkSize-1;end=Math.min(end,datalength-1);if(typeof lazyArray.chunks[chunkNum]==\"undefined\"){lazyArray.chunks[chunkNum]=doXHR(start,end)}if(typeof lazyArray.chunks[chunkNum]==\"undefined\")throw new Error(\"doXHR failed!\");return lazyArray.chunks[chunkNum]});if(usesGzip||!datalength){chunkSize=datalength=1;datalength=this.getter(0).length;chunkSize=datalength;out(\"LazyFiles on gzip forces download of the whole file when length is accessed\")}this._length=datalength;this._chunkSize=chunkSize;this.lengthKnown=true}get length(){if(!this.lengthKnown){this.cacheLength()}return this._length}get chunkSize(){if(!this.lengthKnown){this.cacheLength()}return this._chunkSize}}if(typeof XMLHttpRequest!=\"undefined\"){if(!ENVIRONMENT_IS_WORKER)throw\"Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc\";var lazyArray=new LazyUint8Array;var properties={isDevice:false,contents:lazyArray}}else{var properties={isDevice:false,url}}var node=FS.createFile(parent,name,properties,canRead,canWrite);if(properties.contents){node.contents=properties.contents}else if(properties.url){node.contents=null;node.url=properties.url}Object.defineProperties(node,{usedBytes:{get:function(){return this.contents.length}}});var stream_ops={};var keys=Object.keys(node.stream_ops);keys.forEach(key=>{var fn=node.stream_ops[key];stream_ops[key]=(...args)=>{FS.forceLoadFile(node);return fn(...args)}});function writeChunks(stream,buffer,offset,length,position){var contents=stream.node.contents;if(position>=contents.length)return 0;var size=Math.min(contents.length-position,length);if(contents.slice){for(var i=0;i<size;i++){buffer[offset+i]=contents[position+i]}}else{for(var i=0;i<size;i++){buffer[offset+i]=contents.get(position+i)}}return size}stream_ops.read=(stream,buffer,offset,length,position)=>{FS.forceLoadFile(node);return writeChunks(stream,buffer,offset,length,position)};stream_ops.mmap=(stream,length,position,prot,flags)=>{FS.forceLoadFile(node);var ptr=mmapAlloc(length);if(!ptr){throw new FS.ErrnoError(48)}writeChunks(stream,GROWABLE_HEAP_I8(),ptr,length,position);return{ptr,allocated:true}};node.stream_ops=stream_ops;return node}};var UTF8ToString=(ptr,maxBytesToRead)=>{ptr>>>=0;return ptr?UTF8ArrayToString(GROWABLE_HEAP_U8(),ptr,maxBytesToRead):\"\"};var SYSCALLS={DEFAULT_POLLMASK:5,calculateAt(dirfd,path,allowEmpty){if(PATH.isAbs(path)){return path}var dir;if(dirfd===-100){dir=FS.cwd()}else{var dirstream=SYSCALLS.getStreamFromFD(dirfd);dir=dirstream.path}if(path.length==0){if(!allowEmpty){throw new FS.ErrnoError(44)}return dir}return PATH.join2(dir,path)},doStat(func,path,buf){var stat=func(path);GROWABLE_HEAP_I32()[buf>>>2>>>0]=stat.dev;GROWABLE_HEAP_I32()[buf+4>>>2>>>0]=stat.mode;GROWABLE_HEAP_U32()[buf+8>>>2>>>0]=stat.nlink;GROWABLE_HEAP_I32()[buf+12>>>2>>>0]=stat.uid;GROWABLE_HEAP_I32()[buf+16>>>2>>>0]=stat.gid;GROWABLE_HEAP_I32()[buf+20>>>2>>>0]=stat.rdev;tempI64=[stat.size>>>0,(tempDouble=stat.size,+Math.abs(tempDouble)>=1?tempDouble>0?+Math.floor(tempDouble/4294967296)>>>0:~~+Math.ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],GROWABLE_HEAP_I32()[buf+24>>>2>>>0]=tempI64[0],GROWABLE_HEAP_I32()[buf+28>>>2>>>0]=tempI64[1];GROWABLE_HEAP_I32()[buf+32>>>2>>>0]=4096;GROWABLE_HEAP_I32()[buf+36>>>2>>>0]=stat.blocks;var atime=stat.atime.getTime();var mtime=stat.mtime.getTime();var ctime=stat.ctime.getTime();tempI64=[Math.floor(atime/1e3)>>>0,(tempDouble=Math.floor(atime/1e3),+Math.abs(tempDouble)>=1?tempDouble>0?+Math.floor(tempDouble/4294967296)>>>0:~~+Math.ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],GROWABLE_HEAP_I32()[buf+40>>>2>>>0]=tempI64[0],GROWABLE_HEAP_I32()[buf+44>>>2>>>0]=tempI64[1];GROWABLE_HEAP_U32()[buf+48>>>2>>>0]=atime%1e3*1e3*1e3;tempI64=[Math.floor(mtime/1e3)>>>0,(tempDouble=Math.floor(mtime/1e3),+Math.abs(tempDouble)>=1?tempDouble>0?+Math.floor(tempDouble/4294967296)>>>0:~~+Math.ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],GROWABLE_HEAP_I32()[buf+56>>>2>>>0]=tempI64[0],GROWABLE_HEAP_I32()[buf+60>>>2>>>0]=tempI64[1];GROWABLE_HEAP_U32()[buf+64>>>2>>>0]=mtime%1e3*1e3*1e3;tempI64=[Math.floor(ctime/1e3)>>>0,(tempDouble=Math.floor(ctime/1e3),+Math.abs(tempDouble)>=1?tempDouble>0?+Math.floor(tempDouble/4294967296)>>>0:~~+Math.ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],GROWABLE_HEAP_I32()[buf+72>>>2>>>0]=tempI64[0],GROWABLE_HEAP_I32()[buf+76>>>2>>>0]=tempI64[1];GROWABLE_HEAP_U32()[buf+80>>>2>>>0]=ctime%1e3*1e3*1e3;tempI64=[stat.ino>>>0,(tempDouble=stat.ino,+Math.abs(tempDouble)>=1?tempDouble>0?+Math.floor(tempDouble/4294967296)>>>0:~~+Math.ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],GROWABLE_HEAP_I32()[buf+88>>>2>>>0]=tempI64[0],GROWABLE_HEAP_I32()[buf+92>>>2>>>0]=tempI64[1];return 0},doMsync(addr,stream,len,flags,offset){if(!FS.isFile(stream.node.mode)){throw new FS.ErrnoError(43)}if(flags&2){return 0}var buffer=GROWABLE_HEAP_U8().slice(addr,addr+len);FS.msync(stream,buffer,offset,len,flags)},getStreamFromFD(fd){var stream=FS.getStreamChecked(fd);return stream},varargs:undefined,getStr(ptr){var ret=UTF8ToString(ptr);return ret}};function ___syscall_fcntl64(fd,cmd,varargs){if(ENVIRONMENT_IS_PTHREAD)return proxyToMainThread(3,0,1,fd,cmd,varargs);varargs>>>=0;SYSCALLS.varargs=varargs;try{var stream=SYSCALLS.getStreamFromFD(fd);switch(cmd){case 0:{var arg=syscallGetVarargI();if(arg<0){return-28}while(FS.streams[arg]){arg++}var newStream;newStream=FS.dupStream(stream,arg);return newStream.fd}case 1:case 2:return 0;case 3:return stream.flags;case 4:{var arg=syscallGetVarargI();stream.flags|=arg;return 0}case 12:{var arg=syscallGetVarargP();var offset=0;GROWABLE_HEAP_I16()[arg+offset>>>1>>>0]=2;return 0}case 13:case 14:return 0}return-28}catch(e){if(typeof FS==\"undefined\"||!(e.name===\"ErrnoError\"))throw e;return-e.errno}}function ___syscall_ioctl(fd,op,varargs){if(ENVIRONMENT_IS_PTHREAD)return proxyToMainThread(4,0,1,fd,op,varargs);varargs>>>=0;SYSCALLS.varargs=varargs;try{var stream=SYSCALLS.getStreamFromFD(fd);switch(op){case 21509:{if(!stream.tty)return-59;return 0}case 21505:{if(!stream.tty)return-59;if(stream.tty.ops.ioctl_tcgets){var termios=stream.tty.ops.ioctl_tcgets(stream);var argp=syscallGetVarargP();GROWABLE_HEAP_I32()[argp>>>2>>>0]=termios.c_iflag||0;GROWABLE_HEAP_I32()[argp+4>>>2>>>0]=termios.c_oflag||0;GROWABLE_HEAP_I32()[argp+8>>>2>>>0]=termios.c_cflag||0;GROWABLE_HEAP_I32()[argp+12>>>2>>>0]=termios.c_lflag||0;for(var i=0;i<32;i++){GROWABLE_HEAP_I8()[argp+i+17>>>0]=termios.c_cc[i]||0}return 0}return 0}case 21510:case 21511:case 21512:{if(!stream.tty)return-59;return 0}case 21506:case 21507:case 21508:{if(!stream.tty)return-59;if(stream.tty.ops.ioctl_tcsets){var argp=syscallGetVarargP();var c_iflag=GROWABLE_HEAP_I32()[argp>>>2>>>0];var c_oflag=GROWABLE_HEAP_I32()[argp+4>>>2>>>0];var c_cflag=GROWABLE_HEAP_I32()[argp+8>>>2>>>0];var c_lflag=GROWABLE_HEAP_I32()[argp+12>>>2>>>0];var c_cc=[];for(var i=0;i<32;i++){c_cc.push(GROWABLE_HEAP_I8()[argp+i+17>>>0])}return stream.tty.ops.ioctl_tcsets(stream.tty,op,{c_iflag,c_oflag,c_cflag,c_lflag,c_cc})}return 0}case 21519:{if(!stream.tty)return-59;var argp=syscallGetVarargP();GROWABLE_HEAP_I32()[argp>>>2>>>0]=0;return 0}case 21520:{if(!stream.tty)return-59;return-28}case 21531:{var argp=syscallGetVarargP();return FS.ioctl(stream,op,argp)}case 21523:{if(!stream.tty)return-59;if(stream.tty.ops.ioctl_tiocgwinsz){var winsize=stream.tty.ops.ioctl_tiocgwinsz(stream.tty);var argp=syscallGetVarargP();GROWABLE_HEAP_I16()[argp>>>1>>>0]=winsize[0];GROWABLE_HEAP_I16()[argp+2>>>1>>>0]=winsize[1]}return 0}case 21524:{if(!stream.tty)return-59;return 0}case 21515:{if(!stream.tty)return-59;return 0}default:return-28}}catch(e){if(typeof FS==\"undefined\"||!(e.name===\"ErrnoError\"))throw e;return-e.errno}}function ___syscall_openat(dirfd,path,flags,varargs){if(ENVIRONMENT_IS_PTHREAD)return proxyToMainThread(5,0,1,dirfd,path,flags,varargs);path>>>=0;varargs>>>=0;SYSCALLS.varargs=varargs;try{path=SYSCALLS.getStr(path);path=SYSCALLS.calculateAt(dirfd,path);var mode=varargs?syscallGetVarargI():0;return FS.open(path,flags,mode).fd}catch(e){if(typeof FS==\"undefined\"||!(e.name===\"ErrnoError\"))throw e;return-e.errno}}var __abort_js=()=>{abort(\"\")};var tupleRegistrations={};var runDestructors=destructors=>{while(destructors.length){var ptr=destructors.pop();var del=destructors.pop();del(ptr)}};function readPointer(pointer){return this[\"fromWireType\"](GROWABLE_HEAP_U32()[pointer>>>2>>>0])}var awaitingDependencies={};var registeredTypes={};var typeDependencies={};var InternalError;var throwInternalError=message=>{throw new InternalError(message)};var whenDependentTypesAreResolved=(myTypes,dependentTypes,getTypeConverters)=>{myTypes.forEach(type=>typeDependencies[type]=dependentTypes);function onComplete(typeConverters){var myTypeConverters=getTypeConverters(typeConverters);if(myTypeConverters.length!==myTypes.length){throwInternalError(\"Mismatched type converter count\")}for(var i=0;i<myTypes.length;++i){registerType(myTypes[i],myTypeConverters[i])}}var typeConverters=new Array(dependentTypes.length);var unregisteredTypes=[];var registered=0;dependentTypes.forEach((dt,i)=>{if(registeredTypes.hasOwnProperty(dt)){typeConverters[i]=registeredTypes[dt]}else{unregisteredTypes.push(dt);if(!awaitingDependencies.hasOwnProperty(dt)){awaitingDependencies[dt]=[]}awaitingDependencies[dt].push(()=>{typeConverters[i]=registeredTypes[dt];++registered;if(registered===unregisteredTypes.length){onComplete(typeConverters)}})}});if(0===unregisteredTypes.length){onComplete(typeConverters)}};var __embind_finalize_value_array=function(rawTupleType){rawTupleType>>>=0;var reg=tupleRegistrations[rawTupleType];delete tupleRegistrations[rawTupleType];var elements=reg.elements;var elementsLength=elements.length;var elementTypes=elements.map(elt=>elt.getterReturnType).concat(elements.map(elt=>elt.setterArgumentType));var rawConstructor=reg.rawConstructor;var rawDestructor=reg.rawDestructor;whenDependentTypesAreResolved([rawTupleType],elementTypes,elementTypes=>{elements.forEach((elt,i)=>{var getterReturnType=elementTypes[i];var getter=elt.getter;var getterContext=elt.getterContext;var setterArgumentType=elementTypes[i+elementsLength];var setter=elt.setter;var setterContext=elt.setterContext;elt.read=ptr=>getterReturnType[\"fromWireType\"](getter(getterContext,ptr));elt.write=(ptr,o)=>{var destructors=[];setter(setterContext,ptr,setterArgumentType[\"toWireType\"](destructors,o));runDestructors(destructors)}});return[{name:reg.name,fromWireType:ptr=>{var rv=new Array(elementsLength);for(var i=0;i<elementsLength;++i){rv[i]=elements[i].read(ptr)}rawDestructor(ptr);return rv},toWireType:(destructors,o)=>{if(elementsLength!==o.length){throw new TypeError(`Incorrect number of tuple elements for ${reg.name}: expected=${elementsLength}, actual=${o.length}`)}var ptr=rawConstructor();for(var i=0;i<elementsLength;++i){elements[i].write(ptr,o[i])}if(destructors!==null){destructors.push(rawDestructor,ptr)}return ptr},argPackAdvance:GenericWireTypeSize,readValueFromPointer:readPointer,destructorFunction:rawDestructor}]})};var structRegistrations={};var __embind_finalize_value_object=function(structType){structType>>>=0;var reg=structRegistrations[structType];delete structRegistrations[structType];var rawConstructor=reg.rawConstructor;var rawDestructor=reg.rawDestructor;var fieldRecords=reg.fields;var fieldTypes=fieldRecords.map(field=>field.getterReturnType).concat(fieldRecords.map(field=>field.setterArgumentType));whenDependentTypesAreResolved([structType],fieldTypes,fieldTypes=>{var fields={};fieldRecords.forEach((field,i)=>{var fieldName=field.fieldName;var getterReturnType=fieldTypes[i];var getter=field.getter;var getterContext=field.getterContext;var setterArgumentType=fieldTypes[i+fieldRecords.length];var setter=field.setter;var setterContext=field.setterContext;fields[fieldName]={read:ptr=>getterReturnType[\"fromWireType\"](getter(getterContext,ptr)),write:(ptr,o)=>{var destructors=[];setter(setterContext,ptr,setterArgumentType[\"toWireType\"](destructors,o));runDestructors(destructors)}}});return[{name:reg.name,fromWireType:ptr=>{var rv={};for(var i in fields){rv[i]=fields[i].read(ptr)}rawDestructor(ptr);return rv},toWireType:(destructors,o)=>{for(var fieldName in fields){if(!(fieldName in o)){throw new TypeError(`Missing field: \"${fieldName}\"`)}}var ptr=rawConstructor();for(fieldName in fields){fields[fieldName].write(ptr,o[fieldName])}if(destructors!==null){destructors.push(rawDestructor,ptr)}return ptr},argPackAdvance:GenericWireTypeSize,readValueFromPointer:readPointer,destructorFunction:rawDestructor}]})};function __embind_register_bigint(primitiveType,name,size,minRange,maxRange){primitiveType>>>=0;name>>>=0;size>>>=0}var embind_init_charCodes=()=>{var codes=new Array(256);for(var i=0;i<256;++i){codes[i]=String.fromCharCode(i)}embind_charCodes=codes};var embind_charCodes;var readLatin1String=ptr=>{var ret=\"\";var c=ptr;while(GROWABLE_HEAP_U8()[c>>>0]){ret+=embind_charCodes[GROWABLE_HEAP_U8()[c++>>>0]]}return ret};var BindingError;var throwBindingError=message=>{throw new BindingError(message)};function sharedRegisterType(rawType,registeredInstance,options={}){var name=registeredInstance.name;if(!rawType){throwBindingError(`type \"${name}\" must have a positive integer typeid pointer`)}if(registeredTypes.hasOwnProperty(rawType)){if(options.ignoreDuplicateRegistrations){return}else{throwBindingError(`Cannot register type '${name}' twice`)}}registeredTypes[rawType]=registeredInstance;delete typeDependencies[rawType];if(awaitingDependencies.hasOwnProperty(rawType)){var callbacks=awaitingDependencies[rawType];delete awaitingDependencies[rawType];callbacks.forEach(cb=>cb())}}function registerType(rawType,registeredInstance,options={}){return sharedRegisterType(rawType,registeredInstance,options)}var GenericWireTypeSize=8;function __embind_register_bool(rawType,name,trueValue,falseValue){rawType>>>=0;name>>>=0;name=readLatin1String(name);registerType(rawType,{name,fromWireType:function(wt){return!!wt},toWireType:function(destructors,o){return o?trueValue:falseValue},argPackAdvance:GenericWireTypeSize,readValueFromPointer:function(pointer){return this[\"fromWireType\"](GROWABLE_HEAP_U8()[pointer>>>0])},destructorFunction:null})}var shallowCopyInternalPointer=o=>({count:o.count,deleteScheduled:o.deleteScheduled,preservePointerOnDelete:o.preservePointerOnDelete,ptr:o.ptr,ptrType:o.ptrType,smartPtr:o.smartPtr,smartPtrType:o.smartPtrType});var throwInstanceAlreadyDeleted=obj=>{function getInstanceTypeName(handle){return handle.$$.ptrType.registeredClass.name}throwBindingError(getInstanceTypeName(obj)+\" instance already deleted\")};var finalizationRegistry=false;var detachFinalizer=handle=>{};var runDestructor=$$=>{if($$.smartPtr){$$.smartPtrType.rawDestructor($$.smartPtr)}else{$$.ptrType.registeredClass.rawDestructor($$.ptr)}};var releaseClassHandle=$$=>{$$.count.value-=1;var toDelete=0===$$.count.value;if(toDelete){runDestructor($$)}};var downcastPointer=(ptr,ptrClass,desiredClass)=>{if(ptrClass===desiredClass){return ptr}if(undefined===desiredClass.baseClass){return null}var rv=downcastPointer(ptr,ptrClass,desiredClass.baseClass);if(rv===null){return null}return desiredClass.downcast(rv)};var registeredPointers={};var registeredInstances={};var getBasestPointer=(class_,ptr)=>{if(ptr===undefined){throwBindingError(\"ptr should not be undefined\")}while(class_.baseClass){ptr=class_.upcast(ptr);class_=class_.baseClass}return ptr};var getInheritedInstance=(class_,ptr)=>{ptr=getBasestPointer(class_,ptr);return registeredInstances[ptr]};var makeClassHandle=(prototype,record)=>{if(!record.ptrType||!record.ptr){throwInternalError(\"makeClassHandle requires ptr and ptrType\")}var hasSmartPtrType=!!record.smartPtrType;var hasSmartPtr=!!record.smartPtr;if(hasSmartPtrType!==hasSmartPtr){throwInternalError(\"Both smartPtrType and smartPtr must be specified\")}record.count={value:1};return attachFinalizer(Object.create(prototype,{$$:{value:record,writable:true}}))};function RegisteredPointer_fromWireType(ptr){var rawPointer=this.getPointee(ptr);if(!rawPointer){this.destructor(ptr);return null}var registeredInstance=getInheritedInstance(this.registeredClass,rawPointer);if(undefined!==registeredInstance){if(0===registeredInstance.$$.count.value){registeredInstance.$$.ptr=rawPointer;registeredInstance.$$.smartPtr=ptr;return registeredInstance[\"clone\"]()}else{var rv=registeredInstance[\"clone\"]();this.destructor(ptr);return rv}}function makeDefaultHandle(){if(this.isSmartPointer){return makeClassHandle(this.registeredClass.instancePrototype,{ptrType:this.pointeeType,ptr:rawPointer,smartPtrType:this,smartPtr:ptr})}else{return makeClassHandle(this.registeredClass.instancePrototype,{ptrType:this,ptr})}}var actualType=this.registeredClass.getActualType(rawPointer);var registeredPointerRecord=registeredPointers[actualType];if(!registeredPointerRecord){return makeDefaultHandle.call(this)}var toType;if(this.isConst){toType=registeredPointerRecord.constPointerType}else{toType=registeredPointerRecord.pointerType}var dp=downcastPointer(rawPointer,this.registeredClass,toType.registeredClass);if(dp===null){return makeDefaultHandle.call(this)}if(this.isSmartPointer){return makeClassHandle(toType.registeredClass.instancePrototype,{ptrType:toType,ptr:dp,smartPtrType:this,smartPtr:ptr})}else{return makeClassHandle(toType.registeredClass.instancePrototype,{ptrType:toType,ptr:dp})}}var attachFinalizer=handle=>{if(\"undefined\"===typeof FinalizationRegistry){attachFinalizer=handle=>handle;return handle}finalizationRegistry=new FinalizationRegistry(info=>{releaseClassHandle(info.$$)});attachFinalizer=handle=>{var $$=handle.$$;var hasSmartPtr=!!$$.smartPtr;if(hasSmartPtr){var info={$$};finalizationRegistry.register(handle,info,handle)}return handle};detachFinalizer=handle=>finalizationRegistry.unregister(handle);return attachFinalizer(handle)};var deletionQueue=[];var flushPendingDeletes=()=>{while(deletionQueue.length){var obj=deletionQueue.pop();obj.$$.deleteScheduled=false;obj[\"delete\"]()}};var delayFunction;var init_ClassHandle=()=>{Object.assign(ClassHandle.prototype,{isAliasOf(other){if(!(this instanceof ClassHandle)){return false}if(!(other instanceof ClassHandle)){return false}var leftClass=this.$$.ptrType.registeredClass;var left=this.$$.ptr;other.$$=other.$$;var rightClass=other.$$.ptrType.registeredClass;var right=other.$$.ptr;while(leftClass.baseClass){left=leftClass.upcast(left);leftClass=leftClass.baseClass}while(rightClass.baseClass){right=rightClass.upcast(right);rightClass=rightClass.baseClass}return leftClass===rightClass&&left===right},clone(){if(!this.$$.ptr){throwInstanceAlreadyDeleted(this)}if(this.$$.preservePointerOnDelete){this.$$.count.value+=1;return this}else{var clone=attachFinalizer(Object.create(Object.getPrototypeOf(this),{$$:{value:shallowCopyInternalPointer(this.$$)}}));clone.$$.count.value+=1;clone.$$.deleteScheduled=false;return clone}},delete(){if(!this.$$.ptr){throwInstanceAlreadyDeleted(this)}if(this.$$.deleteScheduled&&!this.$$.preservePointerOnDelete){throwBindingError(\"Object already scheduled for deletion\")}detachFinalizer(this);releaseClassHandle(this.$$);if(!this.$$.preservePointerOnDelete){this.$$.smartPtr=undefined;this.$$.ptr=undefined}},isDeleted(){return!this.$$.ptr},deleteLater(){if(!this.$$.ptr){throwInstanceAlreadyDeleted(this)}if(this.$$.deleteScheduled&&!this.$$.preservePointerOnDelete){throwBindingError(\"Object already scheduled for deletion\")}deletionQueue.push(this);if(deletionQueue.length===1&&delayFunction){delayFunction(flushPendingDeletes)}this.$$.deleteScheduled=true;return this}})};function ClassHandle(){}var createNamedFunction=(name,body)=>Object.defineProperty(body,\"name\",{value:name});var ensureOverloadTable=(proto,methodName,humanName)=>{if(undefined===proto[methodName].overloadTable){var prevFunc=proto[methodName];proto[methodName]=function(...args){if(!proto[methodName].overloadTable.hasOwnProperty(args.length)){throwBindingError(`Function '${humanName}' called with an invalid number of arguments (${args.length}) - expects one of (${proto[methodName].overloadTable})!`)}return proto[methodName].overloadTable[args.length].apply(this,args)};proto[methodName].overloadTable=[];proto[methodName].overloadTable[prevFunc.argCount]=prevFunc}};var exposePublicSymbol=(name,value,numArguments)=>{if(Module.hasOwnProperty(name)){if(undefined===numArguments||undefined!==Module[name].overloadTable&&undefined!==Module[name].overloadTable[numArguments]){throwBindingError(`Cannot register public name '${name}' twice`)}ensureOverloadTable(Module,name,name);if(Module[name].overloadTable.hasOwnProperty(numArguments)){throwBindingError(`Cannot register multiple overloads of a function with the same number of arguments (${numArguments})!`)}Module[name].overloadTable[numArguments]=value}else{Module[name]=value;Module[name].argCount=numArguments}};var char_0=48;var char_9=57;var makeLegalFunctionName=name=>{name=name.replace(/[^a-zA-Z0-9_]/g,\"$\");var f=name.charCodeAt(0);if(f>=char_0&&f<=char_9){return`_${name}`}return name};function RegisteredClass(name,constructor,instancePrototype,rawDestructor,baseClass,getActualType,upcast,downcast){this.name=name;this.constructor=constructor;this.instancePrototype=instancePrototype;this.rawDestructor=rawDestructor;this.baseClass=baseClass;this.getActualType=getActualType;this.upcast=upcast;this.downcast=downcast;this.pureVirtualFunctions=[]}var upcastPointer=(ptr,ptrClass,desiredClass)=>{while(ptrClass!==desiredClass){if(!ptrClass.upcast){throwBindingError(`Expected null or instance of ${desiredClass.name}, got an instance of ${ptrClass.name}`)}ptr=ptrClass.upcast(ptr);ptrClass=ptrClass.baseClass}return ptr};function constNoSmartPtrRawPointerToWireType(destructors,handle){if(handle===null){if(this.isReference){throwBindingError(`null is not a valid ${this.name}`)}return 0}if(!handle.$$){throwBindingError(`Cannot pass \"${embindRepr(handle)}\" as a ${this.name}`)}if(!handle.$$.ptr){throwBindingError(`Cannot pass deleted object as a pointer of type ${this.name}`)}var handleClass=handle.$$.ptrType.registeredClass;var ptr=upcastPointer(handle.$$.ptr,handleClass,this.registeredClass);return ptr}function genericPointerToWireType(destructors,handle){var ptr;if(handle===null){if(this.isReference){throwBindingError(`null is not a valid ${this.name}`)}if(this.isSmartPointer){ptr=this.rawConstructor();if(destructors!==null){destructors.push(this.rawDestructor,ptr)}return ptr}else{return 0}}if(!handle||!handle.$$){throwBindingError(`Cannot pass \"${embindRepr(handle)}\" as a ${this.name}`)}if(!handle.$$.ptr){throwBindingError(`Cannot pass deleted object as a pointer of type ${this.name}`)}if(!this.isConst&&handle.$$.ptrType.isConst){throwBindingError(`Cannot convert argument of type ${handle.$$.smartPtrType?handle.$$.smartPtrType.name:handle.$$.ptrType.name} to parameter type ${this.name}`)}var handleClass=handle.$$.ptrType.registeredClass;ptr=upcastPointer(handle.$$.ptr,handleClass,this.registeredClass);if(this.isSmartPointer){if(undefined===handle.$$.smartPtr){throwBindingError(\"Passing raw pointer to smart pointer is illegal\")}switch(this.sharingPolicy){case 0:if(handle.$$.smartPtrType===this){ptr=handle.$$.smartPtr}else{throwBindingError(`Cannot convert argument of type ${handle.$$.smartPtrType?handle.$$.smartPtrType.name:handle.$$.ptrType.name} to parameter type ${this.name}`)}break;case 1:ptr=handle.$$.smartPtr;break;case 2:if(handle.$$.smartPtrType===this){ptr=handle.$$.smartPtr}else{var clonedHandle=handle[\"clone\"]();ptr=this.rawShare(ptr,Emval.toHandle(()=>clonedHandle[\"delete\"]()));if(destructors!==null){destructors.push(this.rawDestructor,ptr)}}break;default:throwBindingError(\"Unsupporting sharing policy\")}}return ptr}function nonConstNoSmartPtrRawPointerToWireType(destructors,handle){if(handle===null){if(this.isReference){throwBindingError(`null is not a valid ${this.name}`)}return 0}if(!handle.$$){throwBindingError(`Cannot pass \"${embindRepr(handle)}\" as a ${this.name}`)}if(!handle.$$.ptr){throwBindingError(`Cannot pass deleted object as a pointer of type ${this.name}`)}if(handle.$$.ptrType.isConst){throwBindingError(`Cannot convert argument of type ${handle.$$.ptrType.name} to parameter type ${this.name}`)}var handleClass=handle.$$.ptrType.registeredClass;var ptr=upcastPointer(handle.$$.ptr,handleClass,this.registeredClass);return ptr}var init_RegisteredPointer=()=>{Object.assign(RegisteredPointer.prototype,{getPointee(ptr){if(this.rawGetPointee){ptr=this.rawGetPointee(ptr)}return ptr},destructor(ptr){this.rawDestructor?.(ptr)},argPackAdvance:GenericWireTypeSize,readValueFromPointer:readPointer,fromWireType:RegisteredPointer_fromWireType})};function RegisteredPointer(name,registeredClass,isReference,isConst,isSmartPointer,pointeeType,sharingPolicy,rawGetPointee,rawConstructor,rawShare,rawDestructor){this.name=name;this.registeredClass=registeredClass;this.isReference=isReference;this.isConst=isConst;this.isSmartPointer=isSmartPointer;this.pointeeType=pointeeType;this.sharingPolicy=sharingPolicy;this.rawGetPointee=rawGetPointee;this.rawConstructor=rawConstructor;this.rawShare=rawShare;this.rawDestructor=rawDestructor;if(!isSmartPointer&&registeredClass.baseClass===undefined){if(isConst){this[\"toWireType\"]=constNoSmartPtrRawPointerToWireType;this.destructorFunction=null}else{this[\"toWireType\"]=nonConstNoSmartPtrRawPointerToWireType;this.destructorFunction=null}}else{this[\"toWireType\"]=genericPointerToWireType}}var replacePublicSymbol=(name,value,numArguments)=>{if(!Module.hasOwnProperty(name)){throwInternalError(\"Replacing nonexistent public symbol\")}if(undefined!==Module[name].overloadTable&&undefined!==numArguments){Module[name].overloadTable[numArguments]=value}else{Module[name]=value;Module[name].argCount=numArguments}};var dynCallLegacy=(sig,ptr,args)=>{sig=sig.replace(/p/g,\"i\");var f=Module[\"dynCall_\"+sig];return f(ptr,...args)};var dynCall=(sig,ptr,args=[])=>{if(sig.includes(\"j\")){return dynCallLegacy(sig,ptr,args)}var rtn=getWasmTableEntry(ptr)(...args);return sig[0]==\"p\"?rtn>>>0:rtn};var getDynCaller=(sig,ptr)=>(...args)=>dynCall(sig,ptr,args);var embind__requireFunction=(signature,rawFunction)=>{signature=readLatin1String(signature);function makeDynCaller(){if(signature.includes(\"j\")){return getDynCaller(signature,rawFunction)}if(signature.includes(\"p\")){return getDynCaller(signature,rawFunction)}return getWasmTableEntry(rawFunction)}var fp=makeDynCaller();if(typeof fp!=\"function\"){throwBindingError(`unknown function pointer with signature ${signature}: ${rawFunction}`)}return fp};var extendError=(baseErrorType,errorName)=>{var errorClass=createNamedFunction(errorName,function(message){this.name=errorName;this.message=message;var stack=new Error(message).stack;if(stack!==undefined){this.stack=this.toString()+\"\\n\"+stack.replace(/^Error(:[^\\n]*)?\\n/,\"\")}});errorClass.prototype=Object.create(baseErrorType.prototype);errorClass.prototype.constructor=errorClass;errorClass.prototype.toString=function(){if(this.message===undefined){return this.name}else{return`${this.name}: ${this.message}`}};return errorClass};var UnboundTypeError;var getTypeName=type=>{var ptr=___getTypeName(type);var rv=readLatin1String(ptr);_free(ptr);return rv};var throwUnboundTypeError=(message,types)=>{var unboundTypes=[];var seen={};function visit(type){if(seen[type]){return}if(registeredTypes[type]){return}if(typeDependencies[type]){typeDependencies[type].forEach(visit);return}unboundTypes.push(type);seen[type]=true}types.forEach(visit);throw new UnboundTypeError(`${message}: `+unboundTypes.map(getTypeName).join([\", \"]))};function __embind_register_class(rawType,rawPointerType,rawConstPointerType,baseClassRawType,getActualTypeSignature,getActualType,upcastSignature,upcast,downcastSignature,downcast,name,destructorSignature,rawDestructor){rawType>>>=0;rawPointerType>>>=0;rawConstPointerType>>>=0;baseClassRawType>>>=0;getActualTypeSignature>>>=0;getActualType>>>=0;upcastSignature>>>=0;upcast>>>=0;downcastSignature>>>=0;downcast>>>=0;name>>>=0;destructorSignature>>>=0;rawDestructor>>>=0;name=readLatin1String(name);getActualType=embind__requireFunction(getActualTypeSignature,getActualType);upcast&&=embind__requireFunction(upcastSignature,upcast);downcast&&=embind__requireFunction(downcastSignature,downcast);rawDestructor=embind__requireFunction(destructorSignature,rawDestructor);var legalFunctionName=makeLegalFunctionName(name);exposePublicSymbol(legalFunctionName,function(){throwUnboundTypeError(`Cannot construct ${name} due to unbound types`,[baseClassRawType])});whenDependentTypesAreResolved([rawType,rawPointerType,rawConstPointerType],baseClassRawType?[baseClassRawType]:[],base=>{base=base[0];var baseClass;var basePrototype;if(baseClassRawType){baseClass=base.registeredClass;basePrototype=baseClass.instancePrototype}else{basePrototype=ClassHandle.prototype}var constructor=createNamedFunction(name,function(...args){if(Object.getPrototypeOf(this)!==instancePrototype){throw new BindingError(\"Use 'new' to construct \"+name)}if(undefined===registeredClass.constructor_body){throw new BindingError(name+\" has no accessible constructor\")}var body=registeredClass.constructor_body[args.length];if(undefined===body){throw new BindingError(`Tried to invoke ctor of ${name} with invalid number of parameters (${args.length}) - expected (${Object.keys(registeredClass.constructor_body).toString()}) parameters instead!`)}return body.apply(this,args)});var instancePrototype=Object.create(basePrototype,{constructor:{value:constructor}});constructor.prototype=instancePrototype;var registeredClass=new RegisteredClass(name,constructor,instancePrototype,rawDestructor,baseClass,getActualType,upcast,downcast);if(registeredClass.baseClass){registeredClass.baseClass.__derivedClasses??=[];registeredClass.baseClass.__derivedClasses.push(registeredClass)}var referenceConverter=new RegisteredPointer(name,registeredClass,true,false,false);var pointerConverter=new RegisteredPointer(name+\"*\",registeredClass,false,false,false);var constPointerConverter=new RegisteredPointer(name+\" const*\",registeredClass,false,true,false);registeredPointers[rawType]={pointerType:pointerConverter,constPointerType:constPointerConverter};replacePublicSymbol(legalFunctionName,constructor);return[referenceConverter,pointerConverter,constPointerConverter]})}var heap32VectorToArray=(count,firstElement)=>{var array=[];for(var i=0;i<count;i++){array.push(GROWABLE_HEAP_U32()[firstElement+i*4>>>2>>>0])}return array};function usesDestructorStack(argTypes){for(var i=1;i<argTypes.length;++i){if(argTypes[i]!==null&&argTypes[i].destructorFunction===undefined){return true}}return false}function newFunc(constructor,argumentList){if(!(constructor instanceof Function)){throw new TypeError(`new_ called with constructor type ${typeof constructor} which is not a function`)}var dummy=createNamedFunction(constructor.name||\"unknownFunctionName\",function(){});dummy.prototype=constructor.prototype;var obj=new dummy;var r=constructor.apply(obj,argumentList);return r instanceof Object?r:obj}function createJsInvoker(argTypes,isClassMethodFunc,returns,isAsync){var needsDestructorStack=usesDestructorStack(argTypes);var argCount=argTypes.length-2;var argsList=[];var argsListWired=[\"fn\"];if(isClassMethodFunc){argsListWired.push(\"thisWired\")}for(var i=0;i<argCount;++i){argsList.push(`arg${i}`);argsListWired.push(`arg${i}Wired`)}argsList=argsList.join(\",\");argsListWired=argsListWired.join(\",\");var invokerFnBody=`return function (${argsList}) {\\n`;if(needsDestructorStack){invokerFnBody+=\"var destructors = [];\\n\"}var dtorStack=needsDestructorStack?\"destructors\":\"null\";var args1=[\"humanName\",\"throwBindingError\",\"invoker\",\"fn\",\"runDestructors\",\"retType\",\"classParam\"];if(isClassMethodFunc){invokerFnBody+=`var thisWired = classParam['toWireType'](${dtorStack}, this);\\n`}for(var i=0;i<argCount;++i){invokerFnBody+=`var arg${i}Wired = argType${i}['toWireType'](${dtorStack}, arg${i});\\n`;args1.push(`argType${i}`)}invokerFnBody+=(returns||isAsync?\"var rv = \":\"\")+`invoker(${argsListWired});\\n`;if(needsDestructorStack){invokerFnBody+=\"runDestructors(destructors);\\n\"}else{for(var i=isClassMethodFunc?1:2;i<argTypes.length;++i){var paramName=i===1?\"thisWired\":\"arg\"+(i-2)+\"Wired\";if(argTypes[i].destructorFunction!==null){invokerFnBody+=`${paramName}_dtor(${paramName});\\n`;args1.push(`${paramName}_dtor`)}}}if(returns){invokerFnBody+=\"var ret = retType['fromWireType'](rv);\\n\"+\"return ret;\\n\"}else{}invokerFnBody+=\"}\\n\";return[args1,invokerFnBody]}function craftInvokerFunction(humanName,argTypes,classType,cppInvokerFunc,cppTargetFunc,isAsync){var argCount=argTypes.length;if(argCount<2){throwBindingError(\"argTypes array size mismatch! Must at least get return value and 'this' types!\")}var isClassMethodFunc=argTypes[1]!==null&&classType!==null;var needsDestructorStack=usesDestructorStack(argTypes);var returns=argTypes[0].name!==\"void\";var closureArgs=[humanName,throwBindingError,cppInvokerFunc,cppTargetFunc,runDestructors,argTypes[0],argTypes[1]];for(var i=0;i<argCount-2;++i){closureArgs.push(argTypes[i+2])}if(!needsDestructorStack){for(var i=isClassMethodFunc?1:2;i<argTypes.length;++i){if(argTypes[i].destructorFunction!==null){closureArgs.push(argTypes[i].destructorFunction)}}}let[args,invokerFnBody]=createJsInvoker(argTypes,isClassMethodFunc,returns,isAsync);args.push(invokerFnBody);var invokerFn=newFunc(Function,args)(...closureArgs);return createNamedFunction(humanName,invokerFn)}var __embind_register_class_constructor=function(rawClassType,argCount,rawArgTypesAddr,invokerSignature,invoker,rawConstructor){rawClassType>>>=0;rawArgTypesAddr>>>=0;invokerSignature>>>=0;invoker>>>=0;rawConstructor>>>=0;var rawArgTypes=heap32VectorToArray(argCount,rawArgTypesAddr);invoker=embind__requireFunction(invokerSignature,invoker);whenDependentTypesAreResolved([],[rawClassType],classType=>{classType=classType[0];var humanName=`constructor ${classType.name}`;if(undefined===classType.registeredClass.constructor_body){classType.registeredClass.constructor_body=[]}if(undefined!==classType.registeredClass.constructor_body[argCount-1]){throw new BindingError(`Cannot register multiple constructors with identical number of parameters (${argCount-1}) for class '${classType.name}'! Overload resolution is currently only performed using the parameter count, not actual type info!`)}classType.registeredClass.constructor_body[argCount-1]=()=>{throwUnboundTypeError(`Cannot construct ${classType.name} due to unbound types`,rawArgTypes)};whenDependentTypesAreResolved([],rawArgTypes,argTypes=>{argTypes.splice(1,0,null);classType.registeredClass.constructor_body[argCount-1]=craftInvokerFunction(humanName,argTypes,null,invoker,rawConstructor);return[]});return[]})};var getFunctionName=signature=>{signature=signature.trim();const argsIndex=signature.indexOf(\"(\");if(argsIndex!==-1){return signature.substr(0,argsIndex)}else{return signature}};var __embind_register_class_function=function(rawClassType,methodName,argCount,rawArgTypesAddr,invokerSignature,rawInvoker,context,isPureVirtual,isAsync,isNonnullReturn){rawClassType>>>=0;methodName>>>=0;rawArgTypesAddr>>>=0;invokerSignature>>>=0;rawInvoker>>>=0;context>>>=0;var rawArgTypes=heap32VectorToArray(argCount,rawArgTypesAddr);methodName=readLatin1String(methodName);methodName=getFunctionName(methodName);rawInvoker=embind__requireFunction(invokerSignature,rawInvoker);whenDependentTypesAreResolved([],[rawClassType],classType=>{classType=classType[0];var humanName=`${classType.name}.${methodName}`;if(methodName.startsWith(\"@@\")){methodName=Symbol[methodName.substring(2)]}if(isPureVirtual){classType.registeredClass.pureVirtualFunctions.push(methodName)}function unboundTypesHandler(){throwUnboundTypeError(`Cannot call ${humanName} due to unbound types`,rawArgTypes)}var proto=classType.registeredClass.instancePrototype;var method=proto[methodName];if(undefined===method||undefined===method.overloadTable&&method.className!==classType.name&&method.argCount===argCount-2){unboundTypesHandler.argCount=argCount-2;unboundTypesHandler.className=classType.name;proto[methodName]=unboundTypesHandler}else{ensureOverloadTable(proto,methodName,humanName);proto[methodName].overloadTable[argCount-2]=unboundTypesHandler}whenDependentTypesAreResolved([],rawArgTypes,argTypes=>{var memberFunction=craftInvokerFunction(humanName,argTypes,classType,rawInvoker,context,isAsync);if(undefined===proto[methodName].overloadTable){memberFunction.argCount=argCount-2;proto[methodName]=memberFunction}else{proto[methodName].overloadTable[argCount-2]=memberFunction}return[]});return[]})};var validateThis=(this_,classType,humanName)=>{if(!(this_ instanceof Object)){throwBindingError(`${humanName} with invalid \"this\": ${this_}`)}if(!(this_ instanceof classType.registeredClass.constructor)){throwBindingError(`${humanName} incompatible with \"this\" of type ${this_.constructor.name}`)}if(!this_.$$.ptr){throwBindingError(`cannot call emscripten binding method ${humanName} on deleted object`)}return upcastPointer(this_.$$.ptr,this_.$$.ptrType.registeredClass,classType.registeredClass)};var __embind_register_class_property=function(classType,fieldName,getterReturnType,getterSignature,getter,getterContext,setterArgumentType,setterSignature,setter,setterContext){classType>>>=0;fieldName>>>=0;getterReturnType>>>=0;getterSignature>>>=0;getter>>>=0;getterContext>>>=0;setterArgumentType>>>=0;setterSignature>>>=0;setter>>>=0;setterContext>>>=0;fieldName=readLatin1String(fieldName);getter=embind__requireFunction(getterSignature,getter);whenDependentTypesAreResolved([],[classType],classType=>{classType=classType[0];var humanName=`${classType.name}.${fieldName}`;var desc={get(){throwUnboundTypeError(`Cannot access ${humanName} due to unbound types`,[getterReturnType,setterArgumentType])},enumerable:true,configurable:true};if(setter){desc.set=()=>throwUnboundTypeError(`Cannot access ${humanName} due to unbound types`,[getterReturnType,setterArgumentType])}else{desc.set=v=>throwBindingError(humanName+\" is a read-only property\")}Object.defineProperty(classType.registeredClass.instancePrototype,fieldName,desc);whenDependentTypesAreResolved([],setter?[getterReturnType,setterArgumentType]:[getterReturnType],types=>{var getterReturnType=types[0];var desc={get(){var ptr=validateThis(this,classType,humanName+\" getter\");return getterReturnType[\"fromWireType\"](getter(getterContext,ptr))},enumerable:true};if(setter){setter=embind__requireFunction(setterSignature,setter);var setterArgumentType=types[1];desc.set=function(v){var ptr=validateThis(this,classType,humanName+\" setter\");var destructors=[];setter(setterContext,ptr,setterArgumentType[\"toWireType\"](destructors,v));runDestructors(destructors)}}Object.defineProperty(classType.registeredClass.instancePrototype,fieldName,desc);return[]});return[]})};var emval_freelist=[];var emval_handles=[];function __emval_decref(handle){handle>>>=0;if(handle>9&&0===--emval_handles[handle+1]){emval_handles[handle]=undefined;emval_freelist.push(handle)}}var count_emval_handles=()=>emval_handles.length/2-5-emval_freelist.length;var init_emval=()=>{emval_handles.push(0,1,undefined,1,null,1,true,1,false,1);Module[\"count_emval_handles\"]=count_emval_handles};var Emval={toValue:handle=>{if(!handle){throwBindingError(\"Cannot use deleted val. handle = \"+handle)}return emval_handles[handle]},toHandle:value=>{switch(value){case undefined:return 2;case null:return 4;case true:return 6;case false:return 8;default:{const handle=emval_freelist.pop()||emval_handles.length;emval_handles[handle]=value;emval_handles[handle+1]=1;return handle}}}};var EmValType={name:\"emscripten::val\",fromWireType:handle=>{var rv=Emval.toValue(handle);__emval_decref(handle);return rv},toWireType:(destructors,value)=>Emval.toHandle(value),argPackAdvance:GenericWireTypeSize,readValueFromPointer:readPointer,destructorFunction:null};function __embind_register_emval(rawType){rawType>>>=0;return registerType(rawType,EmValType)}var enumReadValueFromPointer=(name,width,signed)=>{switch(width){case 1:return signed?function(pointer){return this[\"fromWireType\"](GROWABLE_HEAP_I8()[pointer>>>0])}:function(pointer){return this[\"fromWireType\"](GROWABLE_HEAP_U8()[pointer>>>0])};case 2:return signed?function(pointer){return this[\"fromWireType\"](GROWABLE_HEAP_I16()[pointer>>>1>>>0])}:function(pointer){return this[\"fromWireType\"](GROWABLE_HEAP_U16()[pointer>>>1>>>0])};case 4:return signed?function(pointer){return this[\"fromWireType\"](GROWABLE_HEAP_I32()[pointer>>>2>>>0])}:function(pointer){return this[\"fromWireType\"](GROWABLE_HEAP_U32()[pointer>>>2>>>0])};default:throw new TypeError(`invalid integer width (${width}): ${name}`)}};function __embind_register_enum(rawType,name,size,isSigned){rawType>>>=0;name>>>=0;size>>>=0;name=readLatin1String(name);function ctor(){}ctor.values={};registerType(rawType,{name,constructor:ctor,fromWireType:function(c){return this.constructor.values[c]},toWireType:(destructors,c)=>c.value,argPackAdvance:GenericWireTypeSize,readValueFromPointer:enumReadValueFromPointer(name,size,isSigned),destructorFunction:null});exposePublicSymbol(name,ctor)}var requireRegisteredType=(rawType,humanName)=>{var impl=registeredTypes[rawType];if(undefined===impl){throwBindingError(`${humanName} has unknown type ${getTypeName(rawType)}`)}return impl};function __embind_register_enum_value(rawEnumType,name,enumValue){rawEnumType>>>=0;name>>>=0;var enumType=requireRegisteredType(rawEnumType,\"enum\");name=readLatin1String(name);var Enum=enumType.constructor;var Value=Object.create(enumType.constructor.prototype,{value:{value:enumValue},constructor:{value:createNamedFunction(`${enumType.name}_${name}`,function(){})}});Enum.values[enumValue]=Value;Enum[name]=Value}var embindRepr=v=>{if(v===null){return\"null\"}var t=typeof v;if(t===\"object\"||t===\"array\"||t===\"function\"){return v.toString()}else{return\"\"+v}};var floatReadValueFromPointer=(name,width)=>{switch(width){case 4:return function(pointer){return this[\"fromWireType\"](GROWABLE_HEAP_F32()[pointer>>>2>>>0])};case 8:return function(pointer){return this[\"fromWireType\"](GROWABLE_HEAP_F64()[pointer>>>3>>>0])};default:throw new TypeError(`invalid float width (${width}): ${name}`)}};var __embind_register_float=function(rawType,name,size){rawType>>>=0;name>>>=0;size>>>=0;name=readLatin1String(name);registerType(rawType,{name,fromWireType:value=>value,toWireType:(destructors,value)=>value,argPackAdvance:GenericWireTypeSize,readValueFromPointer:floatReadValueFromPointer(name,size),destructorFunction:null})};function __embind_register_function(name,argCount,rawArgTypesAddr,signature,rawInvoker,fn,isAsync,isNonnullReturn){name>>>=0;rawArgTypesAddr>>>=0;signature>>>=0;rawInvoker>>>=0;fn>>>=0;var argTypes=heap32VectorToArray(argCount,rawArgTypesAddr);name=readLatin1String(name);name=getFunctionName(name);rawInvoker=embind__requireFunction(signature,rawInvoker);exposePublicSymbol(name,function(){throwUnboundTypeError(`Cannot call ${name} due to unbound types`,argTypes)},argCount-1);whenDependentTypesAreResolved([],argTypes,argTypes=>{var invokerArgsArray=[argTypes[0],null].concat(argTypes.slice(1));replacePublicSymbol(name,craftInvokerFunction(name,invokerArgsArray,null,rawInvoker,fn,isAsync),argCount-1);return[]})}var integerReadValueFromPointer=(name,width,signed)=>{switch(width){case 1:return signed?pointer=>GROWABLE_HEAP_I8()[pointer>>>0]:pointer=>GROWABLE_HEAP_U8()[pointer>>>0];case 2:return signed?pointer=>GROWABLE_HEAP_I16()[pointer>>>1>>>0]:pointer=>GROWABLE_HEAP_U16()[pointer>>>1>>>0];case 4:return signed?pointer=>GROWABLE_HEAP_I32()[pointer>>>2>>>0]:pointer=>GROWABLE_HEAP_U32()[pointer>>>2>>>0];default:throw new TypeError(`invalid integer width (${width}): ${name}`)}};function __embind_register_integer(primitiveType,name,size,minRange,maxRange){primitiveType>>>=0;name>>>=0;size>>>=0;name=readLatin1String(name);if(maxRange===-1){maxRange=4294967295}var fromWireType=value=>value;if(minRange===0){var bitshift=32-8*size;fromWireType=value=>value<<bitshift>>>bitshift}var isUnsignedType=name.includes(\"unsigned\");var checkAssertions=(value,toTypeName)=>{};var toWireType;if(isUnsignedType){toWireType=function(destructors,value){checkAssertions(value,this.name);return value>>>0}}else{toWireType=function(destructors,value){checkAssertions(value,this.name);return value}}registerType(primitiveType,{name,fromWireType,toWireType,argPackAdvance:GenericWireTypeSize,readValueFromPointer:integerReadValueFromPointer(name,size,minRange!==0),destructorFunction:null})}function __embind_register_memory_view(rawType,dataTypeIndex,name){rawType>>>=0;name>>>=0;var typeMapping=[Int8Array,Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array];var TA=typeMapping[dataTypeIndex];function decodeMemoryView(handle){var size=GROWABLE_HEAP_U32()[handle>>>2>>>0];var data=GROWABLE_HEAP_U32()[handle+4>>>2>>>0];return new TA(GROWABLE_HEAP_I8().buffer,data,size)}name=readLatin1String(name);registerType(rawType,{name,fromWireType:decodeMemoryView,argPackAdvance:GenericWireTypeSize,readValueFromPointer:decodeMemoryView},{ignoreDuplicateRegistrations:true})}var EmValOptionalType=Object.assign({optional:true},EmValType);function __embind_register_optional(rawOptionalType,rawType){rawOptionalType>>>=0;rawType>>>=0;registerType(rawOptionalType,EmValOptionalType)}var stringToUTF8=(str,outPtr,maxBytesToWrite)=>stringToUTF8Array(str,GROWABLE_HEAP_U8(),outPtr,maxBytesToWrite);function __embind_register_std_string(rawType,name){rawType>>>=0;name>>>=0;name=readLatin1String(name);var stdStringIsUTF8=name===\"std::string\";registerType(rawType,{name,fromWireType(value){var length=GROWABLE_HEAP_U32()[value>>>2>>>0];var payload=value+4;var str;if(stdStringIsUTF8){var decodeStartPtr=payload;for(var i=0;i<=length;++i){var currentBytePtr=payload+i;if(i==length||GROWABLE_HEAP_U8()[currentBytePtr>>>0]==0){var maxRead=currentBytePtr-decodeStartPtr;var stringSegment=UTF8ToString(decodeStartPtr,maxRead);if(str===undefined){str=stringSegment}else{str+=String.fromCharCode(0);str+=stringSegment}decodeStartPtr=currentBytePtr+1}}}else{var a=new Array(length);for(var i=0;i<length;++i){a[i]=String.fromCharCode(GROWABLE_HEAP_U8()[payload+i>>>0])}str=a.join(\"\")}_free(value);return str},toWireType(destructors,value){if(value instanceof ArrayBuffer){value=new Uint8Array(value)}var length;var valueIsOfTypeString=typeof value==\"string\";if(!(valueIsOfTypeString||value instanceof Uint8Array||value instanceof Uint8ClampedArray||value instanceof Int8Array)){throwBindingError(\"Cannot pass non-string to std::string\")}if(stdStringIsUTF8&&valueIsOfTypeString){length=lengthBytesUTF8(value)}else{length=value.length}var base=_malloc(4+length+1);var ptr=base+4;GROWABLE_HEAP_U32()[base>>>2>>>0]=length;if(stdStringIsUTF8&&valueIsOfTypeString){stringToUTF8(value,ptr,length+1)}else{if(valueIsOfTypeString){for(var i=0;i<length;++i){var charCode=value.charCodeAt(i);if(charCode>255){_free(ptr);throwBindingError(\"String has UTF-16 code units that do not fit in 8 bits\")}GROWABLE_HEAP_U8()[ptr+i>>>0]=charCode}}else{for(var i=0;i<length;++i){GROWABLE_HEAP_U8()[ptr+i>>>0]=value[i]}}}if(destructors!==null){destructors.push(_free,base)}return base},argPackAdvance:GenericWireTypeSize,readValueFromPointer:readPointer,destructorFunction(ptr){_free(ptr)}})}var UTF16Decoder=typeof TextDecoder!=\"undefined\"?new TextDecoder(\"utf-16le\"):undefined;var UTF16ToString=(ptr,maxBytesToRead)=>{var endPtr=ptr;var idx=endPtr>>1;var maxIdx=idx+maxBytesToRead/2;while(!(idx>=maxIdx)&&GROWABLE_HEAP_U16()[idx>>>0])++idx;endPtr=idx<<1;if(endPtr-ptr>32&&UTF16Decoder)return UTF16Decoder.decode(GROWABLE_HEAP_U8().slice(ptr,endPtr));var str=\"\";for(var i=0;!(i>=maxBytesToRead/2);++i){var codeUnit=GROWABLE_HEAP_I16()[ptr+i*2>>>1>>>0];if(codeUnit==0)break;str+=String.fromCharCode(codeUnit)}return str};var stringToUTF16=(str,outPtr,maxBytesToWrite)=>{maxBytesToWrite??=2147483647;if(maxBytesToWrite<2)return 0;maxBytesToWrite-=2;var startPtr=outPtr;var numCharsToWrite=maxBytesToWrite<str.length*2?maxBytesToWrite/2:str.length;for(var i=0;i<numCharsToWrite;++i){var codeUnit=str.charCodeAt(i);GROWABLE_HEAP_I16()[outPtr>>>1>>>0]=codeUnit;outPtr+=2}GROWABLE_HEAP_I16()[outPtr>>>1>>>0]=0;return outPtr-startPtr};var lengthBytesUTF16=str=>str.length*2;var UTF32ToString=(ptr,maxBytesToRead)=>{var i=0;var str=\"\";while(!(i>=maxBytesToRead/4)){var utf32=GROWABLE_HEAP_I32()[ptr+i*4>>>2>>>0];if(utf32==0)break;++i;if(utf32>=65536){var ch=utf32-65536;str+=String.fromCharCode(55296|ch>>10,56320|ch&1023)}else{str+=String.fromCharCode(utf32)}}return str};var stringToUTF32=(str,outPtr,maxBytesToWrite)=>{outPtr>>>=0;maxBytesToWrite??=2147483647;if(maxBytesToWrite<4)return 0;var startPtr=outPtr;var endPtr=startPtr+maxBytesToWrite-4;for(var i=0;i<str.length;++i){var codeUnit=str.charCodeAt(i);if(codeUnit>=55296&&codeUnit<=57343){var trailSurrogate=str.charCodeAt(++i);codeUnit=65536+((codeUnit&1023)<<10)|trailSurrogate&1023}GROWABLE_HEAP_I32()[outPtr>>>2>>>0]=codeUnit;outPtr+=4;if(outPtr+4>endPtr)break}GROWABLE_HEAP_I32()[outPtr>>>2>>>0]=0;return outPtr-startPtr};var lengthBytesUTF32=str=>{var len=0;for(var i=0;i<str.length;++i){var codeUnit=str.charCodeAt(i);if(codeUnit>=55296&&codeUnit<=57343)++i;len+=4}return len};var __embind_register_std_wstring=function(rawType,charSize,name){rawType>>>=0;charSize>>>=0;name>>>=0;name=readLatin1String(name);var decodeString,encodeString,readCharAt,lengthBytesUTF;if(charSize===2){decodeString=UTF16ToString;encodeString=stringToUTF16;lengthBytesUTF=lengthBytesUTF16;readCharAt=pointer=>GROWABLE_HEAP_U16()[pointer>>>1>>>0]}else if(charSize===4){decodeString=UTF32ToString;encodeString=stringToUTF32;lengthBytesUTF=lengthBytesUTF32;readCharAt=pointer=>GROWABLE_HEAP_U32()[pointer>>>2>>>0]}registerType(rawType,{name,fromWireType:value=>{var length=GROWABLE_HEAP_U32()[value>>>2>>>0];var str;var decodeStartPtr=value+4;for(var i=0;i<=length;++i){var currentBytePtr=value+4+i*charSize;if(i==length||readCharAt(currentBytePtr)==0){var maxReadBytes=currentBytePtr-decodeStartPtr;var stringSegment=decodeString(decodeStartPtr,maxReadBytes);if(str===undefined){str=stringSegment}else{str+=String.fromCharCode(0);str+=stringSegment}decodeStartPtr=currentBytePtr+charSize}}_free(value);return str},toWireType:(destructors,value)=>{if(!(typeof value==\"string\")){throwBindingError(`Cannot pass non-string to C++ string type ${name}`)}var length=lengthBytesUTF(value);var ptr=_malloc(4+length+charSize);GROWABLE_HEAP_U32()[ptr>>>2>>>0]=length/charSize;encodeString(value,ptr+4,length+charSize);if(destructors!==null){destructors.push(_free,ptr)}return ptr},argPackAdvance:GenericWireTypeSize,readValueFromPointer:readPointer,destructorFunction(ptr){_free(ptr)}})};function __embind_register_value_array(rawType,name,constructorSignature,rawConstructor,destructorSignature,rawDestructor){rawType>>>=0;name>>>=0;constructorSignature>>>=0;rawConstructor>>>=0;destructorSignature>>>=0;rawDestructor>>>=0;tupleRegistrations[rawType]={name:readLatin1String(name),rawConstructor:embind__requireFunction(constructorSignature,rawConstructor),rawDestructor:embind__requireFunction(destructorSignature,rawDestructor),elements:[]}}function __embind_register_value_array_element(rawTupleType,getterReturnType,getterSignature,getter,getterContext,setterArgumentType,setterSignature,setter,setterContext){rawTupleType>>>=0;getterReturnType>>>=0;getterSignature>>>=0;getter>>>=0;getterContext>>>=0;setterArgumentType>>>=0;setterSignature>>>=0;setter>>>=0;setterContext>>>=0;tupleRegistrations[rawTupleType].elements.push({getterReturnType,getter:embind__requireFunction(getterSignature,getter),getterContext,setterArgumentType,setter:embind__requireFunction(setterSignature,setter),setterContext})}function __embind_register_value_object(rawType,name,constructorSignature,rawConstructor,destructorSignature,rawDestructor){rawType>>>=0;name>>>=0;constructorSignature>>>=0;rawConstructor>>>=0;destructorSignature>>>=0;rawDestructor>>>=0;structRegistrations[rawType]={name:readLatin1String(name),rawConstructor:embind__requireFunction(constructorSignature,rawConstructor),rawDestructor:embind__requireFunction(destructorSignature,rawDestructor),fields:[]}}function __embind_register_value_object_field(structType,fieldName,getterReturnType,getterSignature,getter,getterContext,setterArgumentType,setterSignature,setter,setterContext){structType>>>=0;fieldName>>>=0;getterReturnType>>>=0;getterSignature>>>=0;getter>>>=0;getterContext>>>=0;setterArgumentType>>>=0;setterSignature>>>=0;setter>>>=0;setterContext>>>=0;structRegistrations[structType].fields.push({fieldName:readLatin1String(fieldName),getterReturnType,getter:embind__requireFunction(getterSignature,getter),getterContext,setterArgumentType,setter:embind__requireFunction(setterSignature,setter),setterContext})}var __embind_register_void=function(rawType,name){rawType>>>=0;name>>>=0;name=readLatin1String(name);registerType(rawType,{isVoid:true,name,argPackAdvance:0,fromWireType:()=>undefined,toWireType:(destructors,o)=>undefined})};function __emscripten_init_main_thread_js(tb){tb>>>=0;__emscripten_thread_init(tb,!ENVIRONMENT_IS_WORKER,1,!ENVIRONMENT_IS_WEB,5242880,false);PThread.threadInitTLS()}var maybeExit=()=>{if(!keepRuntimeAlive()){try{if(ENVIRONMENT_IS_PTHREAD)__emscripten_thread_exit(EXITSTATUS);else _exit(EXITSTATUS)}catch(e){handleException(e)}}};var callUserCallback=func=>{if(ABORT){return}try{func();maybeExit()}catch(e){handleException(e)}};function __emscripten_thread_mailbox_await(pthread_ptr){pthread_ptr>>>=0;if(typeof Atomics.waitAsync===\"function\"){var wait=Atomics.waitAsync(GROWABLE_HEAP_I32(),pthread_ptr>>>2,pthread_ptr);wait.value.then(checkMailbox);var waitingAsync=pthread_ptr+128;Atomics.store(GROWABLE_HEAP_I32(),waitingAsync>>>2,1)}}var checkMailbox=()=>{var pthread_ptr=_pthread_self();if(pthread_ptr){__emscripten_thread_mailbox_await(pthread_ptr);callUserCallback(__emscripten_check_mailbox)}};function __emscripten_notify_mailbox_postmessage(targetThread,currThreadId){targetThread>>>=0;currThreadId>>>=0;if(targetThread==currThreadId){setTimeout(checkMailbox)}else if(ENVIRONMENT_IS_PTHREAD){postMessage({targetThread,cmd:\"checkMailbox\"})}else{var worker=PThread.pthreads[targetThread];if(!worker){return}worker.postMessage({cmd:\"checkMailbox\"})}}var proxiedJSCallArgs=[];function __emscripten_receive_on_main_thread_js(funcIndex,emAsmAddr,callingThread,numCallArgs,args){emAsmAddr>>>=0;callingThread>>>=0;args>>>=0;proxiedJSCallArgs.length=numCallArgs;var b=args>>>3;for(var i=0;i<numCallArgs;i++){proxiedJSCallArgs[i]=GROWABLE_HEAP_F64()[b+i>>>0]}var func=emAsmAddr?ASM_CONSTS[emAsmAddr]:proxiedFunctionTable[funcIndex];PThread.currentProxiedOperationCallerThread=callingThread;var rtn=func(...proxiedJSCallArgs);PThread.currentProxiedOperationCallerThread=0;return rtn}var __emscripten_runtime_keepalive_clear=()=>{noExitRuntime=false;runtimeKeepaliveCounter=0};function __emscripten_thread_cleanup(thread){thread>>>=0;if(!ENVIRONMENT_IS_PTHREAD)cleanupThread(thread);else postMessage({cmd:\"cleanupThread\",thread})}function __emscripten_thread_set_strongref(thread){thread>>>=0}var emval_returnValue=(returnType,destructorsRef,handle)=>{var destructors=[];var result=returnType[\"toWireType\"](destructors,handle);if(destructors.length){GROWABLE_HEAP_U32()[destructorsRef>>>2>>>0]=Emval.toHandle(destructors)}return result};function __emval_as(handle,returnType,destructorsRef){handle>>>=0;returnType>>>=0;destructorsRef>>>=0;handle=Emval.toValue(handle);returnType=requireRegisteredType(returnType,\"emval::as\");return emval_returnValue(returnType,destructorsRef,handle)}function __emval_get_property(handle,key){handle>>>=0;key>>>=0;handle=Emval.toValue(handle);key=Emval.toValue(key);return Emval.toHandle(handle[key])}function __emval_new_array(){return Emval.toHandle([])}function __emval_run_destructors(handle){handle>>>=0;var destructors=Emval.toValue(handle);runDestructors(destructors);__emval_decref(handle)}function __emval_set_property(handle,key,value){handle>>>=0;key>>>=0;value>>>=0;handle=Emval.toValue(handle);key=Emval.toValue(key);value=Emval.toValue(value);handle[key]=value}function __emval_take_value(type,arg){type>>>=0;arg>>>=0;type=requireRegisteredType(type,\"_emval_take_value\");var v=type[\"readValueFromPointer\"](arg);return Emval.toHandle(v)}var timers={};var _emscripten_get_now=()=>performance.timeOrigin+performance.now();function __setitimer_js(which,timeout_ms){if(ENVIRONMENT_IS_PTHREAD)return proxyToMainThread(6,0,1,which,timeout_ms);if(timers[which]){clearTimeout(timers[which].id);delete timers[which]}if(!timeout_ms)return 0;var id=setTimeout(()=>{delete timers[which];callUserCallback(()=>__emscripten_timeout(which,_emscripten_get_now()))},timeout_ms);timers[which]={id,timeout_ms};return 0}var __tzset_js=function(timezone,daylight,std_name,dst_name){timezone>>>=0;daylight>>>=0;std_name>>>=0;dst_name>>>=0;var currentYear=(new Date).getFullYear();var winter=new Date(currentYear,0,1);var summer=new Date(currentYear,6,1);var winterOffset=winter.getTimezoneOffset();var summerOffset=summer.getTimezoneOffset();var stdTimezoneOffset=Math.max(winterOffset,summerOffset);GROWABLE_HEAP_U32()[timezone>>>2>>>0]=stdTimezoneOffset*60;GROWABLE_HEAP_I32()[daylight>>>2>>>0]=Number(winterOffset!=summerOffset);var extractZone=timezoneOffset=>{var sign=timezoneOffset>=0?\"-\":\"+\";var absOffset=Math.abs(timezoneOffset);var hours=String(Math.floor(absOffset/60)).padStart(2,\"0\");var minutes=String(absOffset%60).padStart(2,\"0\");return`UTC${sign}${hours}${minutes}`};var winterName=extractZone(winterOffset);var summerName=extractZone(summerOffset);if(summerOffset<winterOffset){stringToUTF8(winterName,std_name,17);stringToUTF8(summerName,dst_name,17)}else{stringToUTF8(winterName,dst_name,17);stringToUTF8(summerName,std_name,17)}};var readEmAsmArgsArray=[];var readEmAsmArgs=(sigPtr,buf)=>{readEmAsmArgsArray.length=0;var ch;while(ch=GROWABLE_HEAP_U8()[sigPtr++>>>0]){var wide=ch!=105;wide&=ch!=112;buf+=wide&&buf%8?4:0;readEmAsmArgsArray.push(ch==112?GROWABLE_HEAP_U32()[buf>>>2>>>0]:ch==105?GROWABLE_HEAP_I32()[buf>>>2>>>0]:GROWABLE_HEAP_F64()[buf>>>3>>>0]);buf+=wide?8:4}return readEmAsmArgsArray};var runEmAsmFunction=(code,sigPtr,argbuf)=>{var args=readEmAsmArgs(sigPtr,argbuf);return ASM_CONSTS[code](...args)};function _emscripten_asm_const_int(code,sigPtr,argbuf){code>>>=0;sigPtr>>>=0;argbuf>>>=0;return runEmAsmFunction(code,sigPtr,argbuf)}var warnOnce=text=>{warnOnce.shown||={};if(!warnOnce.shown[text]){warnOnce.shown[text]=1;err(text)}};var _emscripten_check_blocking_allowed=()=>{};var _emscripten_date_now=()=>Date.now();var runtimeKeepalivePush=()=>{runtimeKeepaliveCounter+=1};var _emscripten_exit_with_live_runtime=()=>{runtimeKeepalivePush();throw\"unwind\"};var _emscripten_num_logical_cores=()=>navigator[\"hardwareConcurrency\"];var getHeapMax=()=>4294901760;var growMemory=size=>{var b=wasmMemory.buffer;var pages=(size-b.byteLength+65535)/65536|0;try{wasmMemory.grow(pages);updateMemoryViews();return 1}catch(e){}};function _emscripten_resize_heap(requestedSize){requestedSize>>>=0;var oldSize=GROWABLE_HEAP_U8().length;if(requestedSize<=oldSize){return false}var maxHeapSize=getHeapMax();if(requestedSize>maxHeapSize){return false}for(var cutDown=1;cutDown<=4;cutDown*=2){var overGrownHeapSize=oldSize*(1+.2/cutDown);overGrownHeapSize=Math.min(overGrownHeapSize,requestedSize+100663296);var newSize=Math.min(maxHeapSize,alignMemory(Math.max(requestedSize,overGrownHeapSize),65536));var replacement=growMemory(newSize);if(replacement){return true}}return false}var ENV={};var getExecutableName=()=>thisProgram||\"./this.program\";var getEnvStrings=()=>{if(!getEnvStrings.strings){var lang=(typeof navigator==\"object\"&&navigator.languages&&navigator.languages[0]||\"C\").replace(\"-\",\"_\")+\".UTF-8\";var env={USER:\"web_user\",LOGNAME:\"web_user\",PATH:\"/\",PWD:\"/\",HOME:\"/home/web_user\",LANG:lang,_:getExecutableName()};for(var x in ENV){if(ENV[x]===undefined)delete env[x];else env[x]=ENV[x]}var strings=[];for(var x in env){strings.push(`${x}=${env[x]}`)}getEnvStrings.strings=strings}return getEnvStrings.strings};var stringToAscii=(str,buffer)=>{for(var i=0;i<str.length;++i){GROWABLE_HEAP_I8()[buffer++>>>0]=str.charCodeAt(i)}GROWABLE_HEAP_I8()[buffer>>>0]=0};var _environ_get=function(__environ,environ_buf){if(ENVIRONMENT_IS_PTHREAD)return proxyToMainThread(7,0,1,__environ,environ_buf);__environ>>>=0;environ_buf>>>=0;var bufSize=0;getEnvStrings().forEach((string,i)=>{var ptr=environ_buf+bufSize;GROWABLE_HEAP_U32()[__environ+i*4>>>2>>>0]=ptr;stringToAscii(string,ptr);bufSize+=string.length+1});return 0};var _environ_sizes_get=function(penviron_count,penviron_buf_size){if(ENVIRONMENT_IS_PTHREAD)return proxyToMainThread(8,0,1,penviron_count,penviron_buf_size);penviron_count>>>=0;penviron_buf_size>>>=0;var strings=getEnvStrings();GROWABLE_HEAP_U32()[penviron_count>>>2>>>0]=strings.length;var bufSize=0;strings.forEach(string=>bufSize+=string.length+1);GROWABLE_HEAP_U32()[penviron_buf_size>>>2>>>0]=bufSize;return 0};function _fd_close(fd){if(ENVIRONMENT_IS_PTHREAD)return proxyToMainThread(9,0,1,fd);try{var stream=SYSCALLS.getStreamFromFD(fd);FS.close(stream);return 0}catch(e){if(typeof FS==\"undefined\"||!(e.name===\"ErrnoError\"))throw e;return e.errno}}var doReadv=(stream,iov,iovcnt,offset)=>{var ret=0;for(var i=0;i<iovcnt;i++){var ptr=GROWABLE_HEAP_U32()[iov>>>2>>>0];var len=GROWABLE_HEAP_U32()[iov+4>>>2>>>0];iov+=8;var curr=FS.read(stream,GROWABLE_HEAP_I8(),ptr,len,offset);if(curr<0)return-1;ret+=curr;if(curr<len)break;if(typeof offset!=\"undefined\"){offset+=curr}}return ret};function _fd_read(fd,iov,iovcnt,pnum){if(ENVIRONMENT_IS_PTHREAD)return proxyToMainThread(10,0,1,fd,iov,iovcnt,pnum);iov>>>=0;iovcnt>>>=0;pnum>>>=0;try{var stream=SYSCALLS.getStreamFromFD(fd);var num=doReadv(stream,iov,iovcnt);GROWABLE_HEAP_U32()[pnum>>>2>>>0]=num;return 0}catch(e){if(typeof FS==\"undefined\"||!(e.name===\"ErrnoError\"))throw e;return e.errno}}function _fd_seek(fd,offset_low,offset_high,whence,newOffset){if(ENVIRONMENT_IS_PTHREAD)return proxyToMainThread(11,0,1,fd,offset_low,offset_high,whence,newOffset);var offset=convertI32PairToI53Checked(offset_low,offset_high);newOffset>>>=0;try{if(isNaN(offset))return 61;var stream=SYSCALLS.getStreamFromFD(fd);FS.llseek(stream,offset,whence);tempI64=[stream.position>>>0,(tempDouble=stream.position,+Math.abs(tempDouble)>=1?tempDouble>0?+Math.floor(tempDouble/4294967296)>>>0:~~+Math.ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],GROWABLE_HEAP_I32()[newOffset>>>2>>>0]=tempI64[0],GROWABLE_HEAP_I32()[newOffset+4>>>2>>>0]=tempI64[1];if(stream.getdents&&offset===0&&whence===0)stream.getdents=null;return 0}catch(e){if(typeof FS==\"undefined\"||!(e.name===\"ErrnoError\"))throw e;return e.errno}}var doWritev=(stream,iov,iovcnt,offset)=>{var ret=0;for(var i=0;i<iovcnt;i++){var ptr=GROWABLE_HEAP_U32()[iov>>>2>>>0];var len=GROWABLE_HEAP_U32()[iov+4>>>2>>>0];iov+=8;var curr=FS.write(stream,GROWABLE_HEAP_I8(),ptr,len,offset);if(curr<0)return-1;ret+=curr;if(curr<len){break}if(typeof offset!=\"undefined\"){offset+=curr}}return ret};function _fd_write(fd,iov,iovcnt,pnum){if(ENVIRONMENT_IS_PTHREAD)return proxyToMainThread(12,0,1,fd,iov,iovcnt,pnum);iov>>>=0;iovcnt>>>=0;pnum>>>=0;try{var stream=SYSCALLS.getStreamFromFD(fd);var num=doWritev(stream,iov,iovcnt);GROWABLE_HEAP_U32()[pnum>>>2>>>0]=num;return 0}catch(e){if(typeof FS==\"undefined\"||!(e.name===\"ErrnoError\"))throw e;return e.errno}}function _llvm_eh_typeid_for(type){type>>>=0;return type}var FS_createPath=FS.createPath;var FS_unlink=path=>FS.unlink(path);var FS_createLazyFile=FS.createLazyFile;var FS_createDevice=FS.createDevice;PThread.init();FS.createPreloadedFile=FS_createPreloadedFile;FS.staticInit();Module[\"FS_createPath\"]=FS.createPath;Module[\"FS_createDataFile\"]=FS.createDataFile;Module[\"FS_createPreloadedFile\"]=FS.createPreloadedFile;Module[\"FS_unlink\"]=FS.unlink;Module[\"FS_createLazyFile\"]=FS.createLazyFile;Module[\"FS_createDevice\"]=FS.createDevice;MEMFS.doesNotExistError=new FS.ErrnoError(44);MEMFS.doesNotExistError.stack=\"<generic error, no stack>\";InternalError=Module[\"InternalError\"]=class InternalError extends Error{constructor(message){super(message);this.name=\"InternalError\"}};embind_init_charCodes();BindingError=Module[\"BindingError\"]=class BindingError extends Error{constructor(message){super(message);this.name=\"BindingError\"}};init_ClassHandle();init_RegisteredPointer();UnboundTypeError=Module[\"UnboundTypeError\"]=extendError(Error,\"UnboundTypeError\");init_emval();var proxiedFunctionTable=[_proc_exit,exitOnMainThread,pthreadCreateProxied,___syscall_fcntl64,___syscall_ioctl,___syscall_openat,__setitimer_js,_environ_get,_environ_sizes_get,_fd_close,_fd_read,_fd_seek,_fd_write];var wasmImports;function assignWasmImports(){wasmImports={x:___cxa_begin_catch,H:___cxa_end_catch,b:___cxa_find_matching_catch_2,l:___cxa_find_matching_catch_3,ha:___cxa_find_matching_catch_4,W:___cxa_rethrow,D:___cxa_throw,oa:___cxa_uncaught_exceptions,va:___pthread_create_js,d:___resumeException,Z:___syscall_fcntl64,ma:___syscall_ioctl,na:___syscall_openat,pa:__abort_js,Oa:__embind_finalize_value_array,Sa:__embind_finalize_value_object,cb:__embind_register_bigint,Da:__embind_register_bool,v:__embind_register_class,u:__embind_register_class_constructor,o:__embind_register_class_function,y:__embind_register_class_property,Ca:__embind_register_emval,Ra:__embind_register_enum,X:__embind_register_enum_value,ca:__embind_register_float,p:__embind_register_function,I:__embind_register_integer,B:__embind_register_memory_view,A:__embind_register_optional,da:__embind_register_std_string,R:__embind_register_std_wstring,Qa:__embind_register_value_array,Pa:__embind_register_value_array_element,s:__embind_register_value_object,Ta:__embind_register_value_object_field,Ea:__embind_register_void,xa:__emscripten_init_main_thread_js,ra:__emscripten_notify_mailbox_postmessage,ya:__emscripten_receive_on_main_thread_js,hb:__emscripten_runtime_keepalive_clear,_:__emscripten_thread_cleanup,wa:__emscripten_thread_mailbox_await,Aa:__emscripten_thread_set_strongref,Va:__emval_as,mb:__emval_decref,Wa:__emval_get_property,ea:__emval_new_array,Ua:__emval_run_destructors,sa:__emval_set_property,w:__emval_take_value,ib:__setitimer_js,kb:__tzset_js,S:_emscripten_asm_const_int,$:_emscripten_check_blocking_allowed,Ba:_emscripten_date_now,za:_emscripten_exit_with_live_runtime,K:_emscripten_get_now,jb:_emscripten_num_logical_cores,qa:_emscripten_resize_heap,lb:_environ_get,ka:_environ_sizes_get,ua:_exit,Y:_fd_close,la:_fd_read,Ya:_fd_seek,ta:_fd_write,Ja:invoke_diiddddiiid,E:invoke_diii,ba:invoke_fiiif,Fa:invoke_i,c:invoke_ii,z:invoke_iid,e:invoke_iii,m:invoke_iiii,ga:invoke_iiiid,n:invoke_iiiii,fb:invoke_iiiiid,aa:invoke_iiiiif,t:invoke_iiiiii,F:invoke_iiiiiii,fa:invoke_iiiiiiii,Q:invoke_iiiiiiiiiiii,Xa:invoke_iij,$a:invoke_iiji,_a:invoke_iji,db:invoke_ji,Za:invoke_jii,bb:invoke_jiiii,i:invoke_v,f:invoke_vi,Ma:invoke_vidddddddi,La:invoke_viddddddi,ja:invoke_viddddidi,ia:invoke_vidddidddi,O:invoke_viddi,L:invoke_viddiiddii,Ia:invoke_vidiidiii,J:invoke_vidiiii,g:invoke_vii,T:invoke_viidd,h:invoke_viii,U:invoke_viiid,Ka:invoke_viiidddi,M:invoke_viiidii,j:invoke_viiii,Ga:invoke_viiiid,q:invoke_viiiii,V:invoke_viiiiid,r:invoke_viiiiii,Ha:invoke_viiiiiidd,G:invoke_viiiiiii,Na:invoke_viiiiiiii,C:invoke_viiiiiiiii,k:invoke_viiiiiiiiii,P:invoke_viiiiiiiiiiiiiii,eb:invoke_viiiiiijj,ab:invoke_vij,N:_llvm_eh_typeid_for,a:wasmMemory,gb:_proc_exit}}var wasmExports=createWasm();var ___wasm_call_ctors=()=>(___wasm_call_ctors=wasmExports[\"nb\"])();var _pthread_self=()=>(_pthread_self=wasmExports[\"ob\"])();var _malloc=Module[\"_malloc\"]=a0=>(_malloc=Module[\"_malloc\"]=wasmExports[\"qb\"])(a0);var ___getTypeName=a0=>(___getTypeName=wasmExports[\"rb\"])(a0);var __embind_initialize_bindings=()=>(__embind_initialize_bindings=wasmExports[\"sb\"])();var _free=Module[\"_free\"]=a0=>(_free=Module[\"_free\"]=wasmExports[\"tb\"])(a0);var __emscripten_tls_init=()=>(__emscripten_tls_init=wasmExports[\"ub\"])();var __emscripten_thread_init=(a0,a1,a2,a3,a4,a5)=>(__emscripten_thread_init=wasmExports[\"vb\"])(a0,a1,a2,a3,a4,a5);var __emscripten_thread_crashed=()=>(__emscripten_thread_crashed=wasmExports[\"wb\"])();var __emscripten_run_on_main_thread_js=(a0,a1,a2,a3,a4)=>(__emscripten_run_on_main_thread_js=wasmExports[\"xb\"])(a0,a1,a2,a3,a4);var __emscripten_thread_free_data=a0=>(__emscripten_thread_free_data=wasmExports[\"yb\"])(a0);var __emscripten_thread_exit=a0=>(__emscripten_thread_exit=wasmExports[\"zb\"])(a0);var __emscripten_timeout=(a0,a1)=>(__emscripten_timeout=wasmExports[\"Ab\"])(a0,a1);var __emscripten_check_mailbox=()=>(__emscripten_check_mailbox=wasmExports[\"Bb\"])();var _setThrew=(a0,a1)=>(_setThrew=wasmExports[\"Cb\"])(a0,a1);var __emscripten_tempret_set=a0=>(__emscripten_tempret_set=wasmExports[\"Db\"])(a0);var _emscripten_stack_set_limits=(a0,a1)=>(_emscripten_stack_set_limits=wasmExports[\"Eb\"])(a0,a1);var __emscripten_stack_restore=a0=>(__emscripten_stack_restore=wasmExports[\"Fb\"])(a0);var __emscripten_stack_alloc=a0=>(__emscripten_stack_alloc=wasmExports[\"Gb\"])(a0);var _emscripten_stack_get_current=()=>(_emscripten_stack_get_current=wasmExports[\"Hb\"])();var ___cxa_decrement_exception_refcount=a0=>(___cxa_decrement_exception_refcount=wasmExports[\"Ib\"])(a0);var ___cxa_increment_exception_refcount=a0=>(___cxa_increment_exception_refcount=wasmExports[\"Jb\"])(a0);var ___cxa_can_catch=(a0,a1,a2)=>(___cxa_can_catch=wasmExports[\"Kb\"])(a0,a1,a2);var ___cxa_get_exception_ptr=a0=>(___cxa_get_exception_ptr=wasmExports[\"Lb\"])(a0);var dynCall_viiiiiijj=Module[\"dynCall_viiiiiijj\"]=(a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10)=>(dynCall_viiiiiijj=Module[\"dynCall_viiiiiijj\"]=wasmExports[\"Mb\"])(a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10);var dynCall_ji=Module[\"dynCall_ji\"]=(a0,a1)=>(dynCall_ji=Module[\"dynCall_ji\"]=wasmExports[\"Nb\"])(a0,a1);var dynCall_jiiii=Module[\"dynCall_jiiii\"]=(a0,a1,a2,a3,a4)=>(dynCall_jiiii=Module[\"dynCall_jiiii\"]=wasmExports[\"Ob\"])(a0,a1,a2,a3,a4);var dynCall_vij=Module[\"dynCall_vij\"]=(a0,a1,a2,a3)=>(dynCall_vij=Module[\"dynCall_vij\"]=wasmExports[\"Pb\"])(a0,a1,a2,a3);var dynCall_iiji=Module[\"dynCall_iiji\"]=(a0,a1,a2,a3,a4)=>(dynCall_iiji=Module[\"dynCall_iiji\"]=wasmExports[\"Qb\"])(a0,a1,a2,a3,a4);var dynCall_iji=Module[\"dynCall_iji\"]=(a0,a1,a2,a3)=>(dynCall_iji=Module[\"dynCall_iji\"]=wasmExports[\"Rb\"])(a0,a1,a2,a3);var dynCall_jii=Module[\"dynCall_jii\"]=(a0,a1,a2)=>(dynCall_jii=Module[\"dynCall_jii\"]=wasmExports[\"Sb\"])(a0,a1,a2);var dynCall_viij=Module[\"dynCall_viij\"]=(a0,a1,a2,a3,a4)=>(dynCall_viij=Module[\"dynCall_viij\"]=wasmExports[\"Tb\"])(a0,a1,a2,a3,a4);var dynCall_jiji=Module[\"dynCall_jiji\"]=(a0,a1,a2,a3,a4)=>(dynCall_jiji=Module[\"dynCall_jiji\"]=wasmExports[\"Ub\"])(a0,a1,a2,a3,a4);var dynCall_iij=Module[\"dynCall_iij\"]=(a0,a1,a2,a3)=>(dynCall_iij=Module[\"dynCall_iij\"]=wasmExports[\"Vb\"])(a0,a1,a2,a3);var dynCall_viijii=Module[\"dynCall_viijii\"]=(a0,a1,a2,a3,a4,a5,a6)=>(dynCall_viijii=Module[\"dynCall_viijii\"]=wasmExports[\"Wb\"])(a0,a1,a2,a3,a4,a5,a6);var dynCall_iiiiij=Module[\"dynCall_iiiiij\"]=(a0,a1,a2,a3,a4,a5,a6)=>(dynCall_iiiiij=Module[\"dynCall_iiiiij\"]=wasmExports[\"Xb\"])(a0,a1,a2,a3,a4,a5,a6);var dynCall_iiiiijj=Module[\"dynCall_iiiiijj\"]=(a0,a1,a2,a3,a4,a5,a6,a7,a8)=>(dynCall_iiiiijj=Module[\"dynCall_iiiiijj\"]=wasmExports[\"Yb\"])(a0,a1,a2,a3,a4,a5,a6,a7,a8);var dynCall_iiiiiijj=Module[\"dynCall_iiiiiijj\"]=(a0,a1,a2,a3,a4,a5,a6,a7,a8,a9)=>(dynCall_iiiiiijj=Module[\"dynCall_iiiiiijj\"]=wasmExports[\"Zb\"])(a0,a1,a2,a3,a4,a5,a6,a7,a8,a9);function invoke_viii(index,a1,a2,a3){var sp=stackSave();try{getWasmTableEntry(index)(a1,a2,a3)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_viiiiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9){var sp=stackSave();try{getWasmTableEntry(index)(a1,a2,a3,a4,a5,a6,a7,a8,a9)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_vii(index,a1,a2){var sp=stackSave();try{getWasmTableEntry(index)(a1,a2)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_viiii(index,a1,a2,a3,a4){var sp=stackSave();try{getWasmTableEntry(index)(a1,a2,a3,a4)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_iii(index,a1,a2){var sp=stackSave();try{return getWasmTableEntry(index)(a1,a2)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_vi(index,a1){var sp=stackSave();try{getWasmTableEntry(index)(a1)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_diii(index,a1,a2,a3){var sp=stackSave();try{return getWasmTableEntry(index)(a1,a2,a3)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_v(index){var sp=stackSave();try{getWasmTableEntry(index)()}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_ii(index,a1){var sp=stackSave();try{return getWasmTableEntry(index)(a1)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_viiiiiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10){var sp=stackSave();try{getWasmTableEntry(index)(a1,a2,a3,a4,a5,a6,a7,a8,a9,a10)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_iiiii(index,a1,a2,a3,a4){var sp=stackSave();try{return getWasmTableEntry(index)(a1,a2,a3,a4)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_iiii(index,a1,a2,a3){var sp=stackSave();try{return getWasmTableEntry(index)(a1,a2,a3)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_viiiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8){var sp=stackSave();try{getWasmTableEntry(index)(a1,a2,a3,a4,a5,a6,a7,a8)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_viddddidi(index,a1,a2,a3,a4,a5,a6,a7,a8){var sp=stackSave();try{getWasmTableEntry(index)(a1,a2,a3,a4,a5,a6,a7,a8)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_vidddidddi(index,a1,a2,a3,a4,a5,a6,a7,a8,a9){var sp=stackSave();try{getWasmTableEntry(index)(a1,a2,a3,a4,a5,a6,a7,a8,a9)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_vidddddddi(index,a1,a2,a3,a4,a5,a6,a7,a8,a9){var sp=stackSave();try{getWasmTableEntry(index)(a1,a2,a3,a4,a5,a6,a7,a8,a9)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_viddddddi(index,a1,a2,a3,a4,a5,a6,a7,a8){var sp=stackSave();try{getWasmTableEntry(index)(a1,a2,a3,a4,a5,a6,a7,a8)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_viddi(index,a1,a2,a3,a4){var sp=stackSave();try{getWasmTableEntry(index)(a1,a2,a3,a4)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_viiiiid(index,a1,a2,a3,a4,a5,a6){var sp=stackSave();try{getWasmTableEntry(index)(a1,a2,a3,a4,a5,a6)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_viiidddi(index,a1,a2,a3,a4,a5,a6,a7){var sp=stackSave();try{getWasmTableEntry(index)(a1,a2,a3,a4,a5,a6,a7)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_viiiii(index,a1,a2,a3,a4,a5){var sp=stackSave();try{getWasmTableEntry(index)(a1,a2,a3,a4,a5)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_viiidii(index,a1,a2,a3,a4,a5,a6){var sp=stackSave();try{getWasmTableEntry(index)(a1,a2,a3,a4,a5,a6)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_viiid(index,a1,a2,a3,a4){var sp=stackSave();try{getWasmTableEntry(index)(a1,a2,a3,a4)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_viidd(index,a1,a2,a3,a4){var sp=stackSave();try{getWasmTableEntry(index)(a1,a2,a3,a4)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_diiddddiiid(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10){var sp=stackSave();try{return getWasmTableEntry(index)(a1,a2,a3,a4,a5,a6,a7,a8,a9,a10)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_iiiiii(index,a1,a2,a3,a4,a5){var sp=stackSave();try{return getWasmTableEntry(index)(a1,a2,a3,a4,a5)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_viiiiii(index,a1,a2,a3,a4,a5,a6){var sp=stackSave();try{getWasmTableEntry(index)(a1,a2,a3,a4,a5,a6)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_viddiiddii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9){var sp=stackSave();try{getWasmTableEntry(index)(a1,a2,a3,a4,a5,a6,a7,a8,a9)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_vidiidiii(index,a1,a2,a3,a4,a5,a6,a7,a8){var sp=stackSave();try{getWasmTableEntry(index)(a1,a2,a3,a4,a5,a6,a7,a8)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_vidiiii(index,a1,a2,a3,a4,a5,a6){var sp=stackSave();try{getWasmTableEntry(index)(a1,a2,a3,a4,a5,a6)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_viiiiiidd(index,a1,a2,a3,a4,a5,a6,a7,a8){var sp=stackSave();try{getWasmTableEntry(index)(a1,a2,a3,a4,a5,a6,a7,a8)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_viiiid(index,a1,a2,a3,a4,a5){var sp=stackSave();try{getWasmTableEntry(index)(a1,a2,a3,a4,a5)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_iiiiiii(index,a1,a2,a3,a4,a5,a6){var sp=stackSave();try{return getWasmTableEntry(index)(a1,a2,a3,a4,a5,a6)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_i(index){var sp=stackSave();try{return getWasmTableEntry(index)()}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_iiiid(index,a1,a2,a3,a4){var sp=stackSave();try{return getWasmTableEntry(index)(a1,a2,a3,a4)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_iid(index,a1,a2){var sp=stackSave();try{return getWasmTableEntry(index)(a1,a2)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_iiiiiiii(index,a1,a2,a3,a4,a5,a6,a7){var sp=stackSave();try{return getWasmTableEntry(index)(a1,a2,a3,a4,a5,a6,a7)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_fiiif(index,a1,a2,a3,a4){var sp=stackSave();try{return getWasmTableEntry(index)(a1,a2,a3,a4)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_iiiiif(index,a1,a2,a3,a4,a5){var sp=stackSave();try{return getWasmTableEntry(index)(a1,a2,a3,a4,a5)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_iiiiid(index,a1,a2,a3,a4,a5){var sp=stackSave();try{return getWasmTableEntry(index)(a1,a2,a3,a4,a5)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_viiiiiii(index,a1,a2,a3,a4,a5,a6,a7){var sp=stackSave();try{getWasmTableEntry(index)(a1,a2,a3,a4,a5,a6,a7)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_iiiiiiiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11){var sp=stackSave();try{return getWasmTableEntry(index)(a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_viiiiiiiiiiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15){var sp=stackSave();try{getWasmTableEntry(index)(a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_viiiiiijj(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10){var sp=stackSave();try{dynCall_viiiiiijj(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_ji(index,a1){var sp=stackSave();try{return dynCall_ji(index,a1)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_jiiii(index,a1,a2,a3,a4){var sp=stackSave();try{return dynCall_jiiii(index,a1,a2,a3,a4)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_vij(index,a1,a2,a3){var sp=stackSave();try{dynCall_vij(index,a1,a2,a3)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_iiji(index,a1,a2,a3,a4){var sp=stackSave();try{return dynCall_iiji(index,a1,a2,a3,a4)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_iji(index,a1,a2,a3){var sp=stackSave();try{return dynCall_iji(index,a1,a2,a3)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_jii(index,a1,a2){var sp=stackSave();try{return dynCall_jii(index,a1,a2)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_iij(index,a1,a2,a3){var sp=stackSave();try{return dynCall_iij(index,a1,a2,a3)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function applySignatureConversions(wasmExports){wasmExports=Object.assign({},wasmExports);var makeWrapper_p=f=>()=>f()>>>0;var makeWrapper_pp=f=>a0=>f(a0)>>>0;wasmExports[\"ob\"]=makeWrapper_p(wasmExports[\"ob\"]);wasmExports[\"qb\"]=makeWrapper_pp(wasmExports[\"qb\"]);wasmExports[\"rb\"]=makeWrapper_pp(wasmExports[\"rb\"]);wasmExports[\"emscripten_main_runtime_thread_id\"]=makeWrapper_p(wasmExports[\"emscripten_main_runtime_thread_id\"]);wasmExports[\"Gb\"]=makeWrapper_pp(wasmExports[\"Gb\"]);wasmExports[\"Hb\"]=makeWrapper_p(wasmExports[\"Hb\"]);wasmExports[\"Lb\"]=makeWrapper_pp(wasmExports[\"Lb\"]);return wasmExports}Module[\"addRunDependency\"]=addRunDependency;Module[\"removeRunDependency\"]=removeRunDependency;Module[\"FS_createPreloadedFile\"]=FS_createPreloadedFile;Module[\"FS_unlink\"]=FS_unlink;Module[\"FS_createPath\"]=FS_createPath;Module[\"FS_createDevice\"]=FS_createDevice;Module[\"FS\"]=FS;Module[\"FS_createDataFile\"]=FS_createDataFile;Module[\"FS_createLazyFile\"]=FS_createLazyFile;Module[\"WORKERFS\"]=WORKERFS;var calledRun;dependenciesFulfilled=function runCaller(){if(!calledRun)run();if(!calledRun)dependenciesFulfilled=runCaller};function run(){if(runDependencies>0){return}if(ENVIRONMENT_IS_PTHREAD){readyPromiseResolve(Module);initRuntime();startWorker(Module);return}preRun();if(runDependencies>0){return}function doRun(){if(calledRun)return;calledRun=true;Module[\"calledRun\"]=true;if(ABORT)return;initRuntime();readyPromiseResolve(Module);Module[\"onRuntimeInitialized\"]?.();postRun()}if(Module[\"setStatus\"]){Module[\"setStatus\"](\"Running...\");setTimeout(()=>{setTimeout(()=>Module[\"setStatus\"](\"\"),1);doRun()},1)}else{doRun()}}if(Module[\"preInit\"]){if(typeof Module[\"preInit\"]==\"function\")Module[\"preInit\"]=[Module[\"preInit\"]];while(Module[\"preInit\"].length>0){Module[\"preInit\"].pop()()}}run();moduleRtn=readyPromise;\n\n\n  return moduleRtn;\n}\n);\n})();\nexport default ConwayGeomWasm;\nvar isPthread = globalThis.self?.name?.startsWith('em-pthread');\n// When running as a pthread, construct a new instance on startup\nisPthread && ConwayGeomWasm();\n"],"names":["$parcel$global","globalThis","parcelRegister","parcelRequire","register","module","exports","Object","defineProperty","get","$a023ed70d02b2fd9$export$2e2bcd8739ae039","set","s","enumerable","configurable","_scriptName","$a023ed70d02b2fd9$var$ConwayGeomWasm","document","currentScript","src","undefined","moduleArg","GROWABLE_HEAP_I8","wasmMemory","buffer","HEAP8","updateMemoryViews","GROWABLE_HEAP_U8","HEAPU8","GROWABLE_HEAP_I16","HEAP16","GROWABLE_HEAP_U16","HEAPU16","GROWABLE_HEAP_I32","HEAP32","GROWABLE_HEAP_U32","HEAPU32","GROWABLE_HEAP_F64","HEAPF64","baseErrorType","errorName","errorClass","readyPromise","Promise","resolve","reject","readyPromiseResolve","readyPromiseReject","ENVIRONMENT_IS_WEB","window","ENVIRONMENT_IS_WORKER","WorkerGlobalScope","ENVIRONMENT_IS_PTHREAD","self","name","startsWith","moduleOverrides","assign","thisProgram","quit_","status","toThrow","scriptDirectory","location","href","substr","replace","lastIndexOf","readBinary","url","xhr","XMLHttpRequest","open","responseType","send","Uint8Array","response","readAsync","fetch","credentials","then","ok","arrayBuffer","Error","out","Module","console","log","bind","err","error","wasmBinary","ABORT","b","Int8Array","Int16Array","Uint16Array","Int32Array","Uint32Array","HEAPF32","Float32Array","Float64Array","wasmBinaryFile","tempDouble","tempI64","wasmTable","InternalError","embind_charCodes","BindingError","delayFunction","UnboundTypeError","wasmImports","calledRun","wasmModule","EXITSTATUS","wasmModuleReceived","initializedJS","args","join","alert","postMessage","cmd","text","threadId","_pthread_self","onunhandledrejection","e","reason","onmessage","handleMessage","msgData","messageQueue","handler","push","startWorker","instance","msg","handlers","proxy","establishStackSpace","pthread_ptr","__emscripten_thread_init","PThread","receiveObjectTransfer","threadInitTLS","__emscripten_thread_mailbox_await","__embind_initialize_bindings","invokeEntryPoint","start_routine","arg","ex","target","checkMailbox","__emscripten_thread_crashed","INITIAL_MEMORY","WebAssembly","Memory","initial","maximum","shared","__ATPRERUN__","__ATINIT__","__ATPOSTRUN__","initRuntime","FS","initialized","init","ignorePermissions","TTY","callRuntimeCallbacks","addOnPreRun","cb","unshift","runDependencies","runDependencyWatcher","dependenciesFulfilled","addRunDependency","id","removeRunDependency","clearInterval","callback","abort","what","RuntimeError","isDataURI","filename","getBinarySync","file","instantiateArrayBuffer","binaryFile","imports","receiver","getBinaryPromise","binary","instantiate","ASM_CONSTS","$0","globalScope","UTF8ToString","ExitStatus","constructor","message","terminateWorker","worker","terminate","cleanupThread","pthreads","returnWorkerToPool","spawnThread","threadParams","getNewWorker","runningWorkers","startRoutine","transferList","runtimeKeepaliveCounter","keepRuntimeAlive","noExitRuntime","stackSave","_emscripten_stack_get_current","stackRestore","val","__emscripten_stack_restore","stackAlloc","sz","__emscripten_stack_alloc","convertI32PairToI53Checked","lo","hi","NaN","proxyToMainThread","funcIndex","emAsmAddr","sync","callArgs","serializedNumCallArgs","length","sp","i","rtn","__emscripten_run_on_main_thread_js","_proc_exit","code","terminateAllThreads","handleException","exitOnMainThread","returnCode","_exit","implicit","unusedWorkers","tlsInitFunctions","initMainThread","pthreadPoolSize","Math","max","navigator","hardwareConcurrency","allocateUnusedWorker","loadWasmModuleToAllWorkers","splice","indexOf","__emscripten_thread_free_data","data","forEach","f","loadWasmModuleToWorker","onFinishedLoading","d","targetThread","targetWorker","thread","loaded","onerror","lineno","propertyIsEnumerable","onMaybeReady","pthreadPoolReady","all","map","pthreadMainJs","URL","createObjectURL","Worker","type","pop","callbacks","shift","stackHigh","stackLow","_emscripten_stack_set_limits","wasmTableMirror","getWasmTableEntry","funcPtr","func","ptr","result","__emscripten_thread_exit","registerTLSInit","tlsInitFunc","exceptionCaught","uncaughtExceptionCount","___cxa_begin_catch","info","ExceptionInfo","get_caught","set_caught","set_rethrown","___cxa_increment_exception_refcount","___cxa_get_exception_ptr","exceptionLast","___cxa_end_catch","_setThrew","___cxa_decrement_exception_refcount","excPtr","set_type","get_type","set_destructor","destructor","get_destructor","caught","rethrown","get_rethrown","set_adjusted_ptr","adjustedPtr","get_adjusted_ptr","___resumeException","setTempRet0","__emscripten_tempret_set","findMatchingCatch","thrown","thrownType","caughtType","adjusted_ptr_addr","___cxa_can_catch","___cxa_find_matching_catch_2","___cxa_find_matching_catch_3","arg0","___cxa_find_matching_catch_4","arg1","___cxa_rethrow","___cxa_throw","___cxa_uncaught_exceptions","pthreadCreateProxied","attr","___pthread_create_js","_emscripten_has_threading_support","SharedArrayBuffer","syscallGetVarargI","ret","SYSCALLS","varargs","PATH","isAbs","path","charAt","splitPath","splitPathRe","exec","slice","normalizeArray","parts","allowAboveRoot","up","last","normalize","isAbsolute","trailingSlash","split","filter","p","dirname","root","dir","basename","lastSlash","paths","join2","l","r","initRandomFill","crypto","view","getRandomValues","byteLength","randomFill","PATH_FS","resolvedPath","resolvedAbsolute","cwd","TypeError","relative","from","to","trim","arr","start","end","fromParts","toParts","min","samePartsLength","outputParts","concat","UTF8Decoder","TextDecoder","UTF8ArrayToString","heapOrArray","idx","maxBytesToRead","endIdx","endPtr","decode","ArrayBuffer","subarray","str","u0","String","fromCharCode","u1","u2","ch","FS_stdin_getChar_buffer","lengthBytesUTF8","len","c","charCodeAt","stringToUTF8Array","heap","outIdx","maxBytesToWrite","startIdx","u","intArrayFromString","stringy","dontAddNull","u8array","Array","numBytesWritten","FS_stdin_getChar","prompt","ttys","shutdown","dev","ops","input","output","registerDevice","stream_ops","stream","tty","node","rdev","ErrnoError","seekable","close","fsync","read","offset","pos","get_char","bytesRead","timestamp","Date","now","write","put_char","default_tty_ops","ioctl_tcgets","c_iflag","c_oflag","c_cflag","c_lflag","c_cc","ioctl_tcsets","optional_actions","ioctl_tiocgwinsz","default_tty1_ops","alignMemory","size","alignment","ceil","mmapAlloc","MEMFS","ops_table","mount","createNode","parent","mode","isBlkdev","isFIFO","getattr","node_ops","setattr","lookup","mknod","rename","unlink","rmdir","readdir","symlink","llseek","allocate","mmap","msync","link","readlink","chrdev","chrdev_stream_ops","isDir","contents","isFile","usedBytes","isLink","isChrdev","getFileDataAsTypedArray","expandFileStorage","newCapacity","prevCapacity","oldContents","resizeFileStorage","newSize","ino","nlink","uid","gid","atime","mtime","ctime","blksize","blocks","doesNotExistError","old_node","new_dir","new_name","new_node","lookupNode","entries","key","keys","newname","oldpath","position","canOwn","whence","prot","flags","allocated","byteOffset","prototype","call","mmapFlags","asyncLoad","onload","noRunDep","dep","FS_createDataFile","fileData","canRead","canWrite","createDataFile","preloadPlugins","FS_handledByPreloadPlugin","byteArray","fullname","finish","Browser","handled","plugin","FS_createPreloadedFile","dontCreateFile","preFinish","processData","FS_modeStringToFlags","flagModes","w","a","FS_getMode","WORKERFS","DIR_MODE","FILE_MODE","reader","FileReaderSync","createdParents","ensureParent","curr","base","opts","lastModifiedDate","obj","pack","files","getTime","oldNode","newDir","newName","oldPath","chunk","ab","readAsArrayBuffer","mounts","devices","streams","nextInode","nameTable","currentPath","errno","filesystems","syncFSRequests","readFiles","FSStream","object","isRead","isWrite","isAppend","FSNode","readMode","writeMode","mounted","isFolder","isDevice","lookupPath","follow_mount","recurse_count","current","current_path","islast","isMountpoint","follow","count","getPath","isRoot","mountpoint","hashName","parentid","hash","hashAddNode","name_next","hashRemoveNode","errCode","mayLookup","nodeName","destroyNode","isSocket","flagsToPermissionString","flag","perms","nodePermissions","includes","mayCreate","mayDelete","isdir","mayOpen","MAX_OPEN_FDS","nextfd","fd","getStreamChecked","getStream","createStream","closeStream","dupStream","origStream","dup","device","getDevice","major","minor","makedev","ma","mi","getMounts","check","m","syncfs","populate","completed","doCallback","done","errored","pseudo","mountRoot","unmount","next","create","mkdir","mkdirTree","dirs","mkdev","newpath","old_path","new_path","old_dir","old_dirname","new_dirname","old_name","stat","dontFollow","lstat","chmod","lchmod","fchmod","chown","lchown","fchown","truncate","ftruncate","utime","created","ungotten","isClosed","getdents","seeking","bytesWritten","ioctl","readFile","encoding","buf","writeFile","actualNumBytes","isView","chdir","createDefaultDirectories","createDefaultDevices","randomBuffer","randomLeft","randomByte","createDevice","createSpecialDirectories","proc_self","createStandardStreams","staticInit","quit","findObject","dontResolveLastLink","analyzePath","exists","parentExists","parentPath","parentObject","createPath","reverse","part","createFile","properties","forceLoadFile","createLazyFile","lengthKnown","chunks","chunkOffset","chunkSize","chunkNum","getter","setDataGetter","cacheLength","header","datalength","Number","getResponseHeader","hasByteServing","usesGzip","doXHR","setRequestHeader","overrideMimeType","responseText","lazyArray","_length","_chunkSize","defineProperties","writeChunks","fn","DEFAULT_POLLMASK","calculateAt","dirfd","allowEmpty","dirstream","getStreamFromFD","doStat","abs","floor","doMsync","addr","getStr","___syscall_fcntl64","newStream","syscallGetVarargP","___syscall_ioctl","op","termios","argp","winsize","___syscall_openat","__abort_js","tupleRegistrations","runDestructors","destructors","del","readPointer","pointer","awaitingDependencies","registeredTypes","typeDependencies","throwInternalError","whenDependentTypesAreResolved","myTypes","dependentTypes","getTypeConverters","onComplete","typeConverters","myTypeConverters","registerType","unregisteredTypes","registered","dt","hasOwnProperty","__embind_finalize_value_array","rawTupleType","reg","elements","elementsLength","elementTypes","elt","getterReturnType","setterArgumentType","rawConstructor","rawDestructor","getterContext","setter","setterContext","o","fromWireType","rv","toWireType","argPackAdvance","GenericWireTypeSize","readValueFromPointer","destructorFunction","structRegistrations","__embind_finalize_value_object","structType","fieldRecords","fields","field","fieldTypes","fieldName","__embind_register_bigint","primitiveType","minRange","maxRange","readLatin1String","throwBindingError","rawType","registeredInstance","options","sharedRegisterType","ignoreDuplicateRegistrations","__embind_register_bool","trueValue","falseValue","wt","shallowCopyInternalPointer","deleteScheduled","preservePointerOnDelete","ptrType","smartPtr","smartPtrType","throwInstanceAlreadyDeleted","getInstanceTypeName","handle","$$","registeredClass","finalizationRegistry","detachFinalizer","runDestructor","releaseClassHandle","value","downcastPointer","ptrClass","desiredClass","baseClass","downcast","registeredPointers","registeredInstances","getBasestPointer","class_","upcast","getInheritedInstance","makeClassHandle","record","attachFinalizer","writable","FinalizationRegistry","unregister","deletionQueue","flushPendingDeletes","ClassHandle","createNamedFunction","body","ensureOverloadTable","proto","methodName","humanName","overloadTable","prevFunc","apply","argCount","exposePublicSymbol","numArguments","makeLegalFunctionName","RegisteredClass","instancePrototype","getActualType","pureVirtualFunctions","upcastPointer","constNoSmartPtrRawPointerToWireType","isReference","embindRepr","handleClass","genericPointerToWireType","isSmartPointer","isConst","sharingPolicy","clonedHandle","rawShare","Emval","toHandle","nonConstNoSmartPtrRawPointerToWireType","RegisteredPointer","pointeeType","rawGetPointee","replacePublicSymbol","dynCallLegacy","sig","dynCall","getDynCaller","embind__requireFunction","signature","rawFunction","fp","getTypeName","___getTypeName","_free","throwUnboundTypeError","types","unboundTypes","seen","visit","__embind_register_class","rawPointerType","rawConstPointerType","baseClassRawType","getActualTypeSignature","upcastSignature","downcastSignature","destructorSignature","legalFunctionName","basePrototype","getPrototypeOf","constructor_body","toString","__derivedClasses","referenceConverter","pointerConverter","constPointerConverter","pointerType","constPointerType","heap32VectorToArray","firstElement","array","usesDestructorStack","argTypes","craftInvokerFunction","classType","cppInvokerFunc","cppTargetFunc","isAsync","isClassMethodFunc","needsDestructorStack","returns","closureArgs","invokerFnBody","createJsInvoker","argsList","argsListWired","dtorStack","args1","paramName","invokerFn","newFunc","argumentList","Function","dummy","__embind_register_class_constructor","rawClassType","rawArgTypesAddr","invokerSignature","invoker","rawArgTypes","getFunctionName","argsIndex","__embind_register_class_function","rawInvoker","context","isPureVirtual","isNonnullReturn","unboundTypesHandler","Symbol","substring","method","className","memberFunction","validateThis","this_","__embind_register_class_property","getterSignature","setterSignature","desc","v","emval_freelist","emval_handles","__emval_decref","toValue","EmValType","__embind_register_emval","enumReadValueFromPointer","width","signed","__embind_register_enum","isSigned","ctor","values","requireRegisteredType","impl","__embind_register_enum_value","rawEnumType","enumValue","enumType","Enum","Value","t","floatReadValueFromPointer","GROWABLE_HEAP_F32","__embind_register_float","__embind_register_function","invokerArgsArray","integerReadValueFromPointer","__embind_register_integer","bitshift","isUnsignedType","checkAssertions","toTypeName","__embind_register_memory_view","dataTypeIndex","TA","typeMapping","decodeMemoryView","EmValOptionalType","optional","__embind_register_optional","rawOptionalType","stringToUTF8","outPtr","__embind_register_std_string","stdStringIsUTF8","payload","decodeStartPtr","currentBytePtr","maxRead","stringSegment","valueIsOfTypeString","Uint8ClampedArray","_malloc","charCode","UTF16Decoder","UTF16ToString","maxIdx","codeUnit","stringToUTF16","startPtr","numCharsToWrite","lengthBytesUTF16","UTF32ToString","utf32","stringToUTF32","trailSurrogate","lengthBytesUTF32","__embind_register_std_wstring","charSize","decodeString","encodeString","readCharAt","lengthBytesUTF","maxReadBytes","__embind_register_value_array","constructorSignature","__embind_register_value_array_element","__embind_register_value_object","__embind_register_value_object_field","__embind_register_void","isVoid","__emscripten_init_main_thread_js","tb","maybeExit","callUserCallback","Atomics","waitAsync","wait","waitingAsync","store","__emscripten_check_mailbox","__emscripten_notify_mailbox_postmessage","currThreadId","setTimeout","proxiedJSCallArgs","__emscripten_receive_on_main_thread_js","callingThread","numCallArgs","proxiedFunctionTable","currentProxiedOperationCallerThread","__emscripten_runtime_keepalive_clear","__emscripten_thread_cleanup","__emscripten_thread_set_strongref","emval_returnValue","returnType","destructorsRef","__emval_as","__emval_get_property","__emval_new_array","__emval_run_destructors","__emval_set_property","__emval_take_value","timers","_emscripten_get_now","performance","timeOrigin","__setitimer_js","which","timeout_ms","clearTimeout","__emscripten_timeout","__tzset_js","timezone","daylight","std_name","dst_name","currentYear","getFullYear","winter","summer","winterOffset","getTimezoneOffset","summerOffset","stdTimezoneOffset","extractZone","timezoneOffset","absOffset","hours","padStart","minutes","winterName","summerName","readEmAsmArgsArray","readEmAsmArgs","sigPtr","wide","runEmAsmFunction","argbuf","_emscripten_asm_const_int","warnOnce","shown","_emscripten_check_blocking_allowed","_emscripten_date_now","runtimeKeepalivePush","_emscripten_exit_with_live_runtime","_emscripten_num_logical_cores","getHeapMax","growMemory","pages","grow","_emscripten_resize_heap","requestedSize","oldSize","maxHeapSize","cutDown","overGrownHeapSize","ENV","getExecutableName","getEnvStrings","strings","env","USER","LOGNAME","PWD","HOME","LANG","languages","_","x","stringToAscii","_environ_get","__environ","environ_buf","bufSize","string","_environ_sizes_get","penviron_count","penviron_buf_size","_fd_close","doReadv","iov","iovcnt","_fd_read","pnum","num","_fd_seek","offset_low","offset_high","newOffset","isNaN","doWritev","_fd_write","_llvm_eh_typeid_for","FS_createPath","FS_createLazyFile","FS_createDevice","createPreloadedFile","stack","codes","isAliasOf","other","leftClass","left","rightClass","right","clone","delete","isDeleted","deleteLater","getPointee","toType","rawPointer","makeDefaultHandle","registeredPointerRecord","dp","assignWasmImports","H","ha","W","D","oa","va","Z","na","pa","Oa","Sa","Da","y","Ca","Ra","X","ca","I","B","A","da","R","Qa","Pa","Ta","Ea","xa","ra","ya","hb","wa","Aa","Va","mb","Wa","ea","Ua","sa","ib","kb","S","$","Ba","za","K","jb","qa","lb","ka","ua","Y","la","Ya","ta","Ja","invoke_diiddddiiid","E","invoke_diii","ba","invoke_fiiif","Fa","invoke_i","invoke_ii","z","invoke_iid","invoke_iii","invoke_iiii","ga","invoke_iiiid","n","invoke_iiiii","fb","invoke_iiiiid","aa","invoke_iiiiif","invoke_iiiiii","F","invoke_iiiiiii","fa","invoke_iiiiiiii","Q","invoke_iiiiiiiiiiii","Xa","invoke_iij","$a","invoke_iiji","_a","invoke_iji","db","invoke_ji","Za","invoke_jii","bb","invoke_jiiii","invoke_v","invoke_vi","Ma","invoke_vidddddddi","La","invoke_viddddddi","ja","invoke_viddddidi","ia","invoke_vidddidddi","O","invoke_viddi","L","invoke_viddiiddii","Ia","invoke_vidiidiii","J","invoke_vidiiii","g","invoke_vii","T","invoke_viidd","h","invoke_viii","U","invoke_viiid","Ka","invoke_viiidddi","M","invoke_viiidii","j","invoke_viiii","Ga","invoke_viiiid","q","invoke_viiiii","V","invoke_viiiiid","invoke_viiiiii","Ha","invoke_viiiiiidd","G","invoke_viiiiiii","Na","invoke_viiiiiiii","C","invoke_viiiiiiiii","k","invoke_viiiiiiiiii","P","invoke_viiiiiiiiiiiiiii","eb","invoke_viiiiiijj","invoke_vij","N","gb","wasmExports","createWasm","receiveInstance","makeWrapper_p","makeWrapper_pp","a0","Instance","instantiateAsync","findWasmBinary","instantiateStreaming","catch","a1","a2","a3","a4","a5","dynCall_viiiiiijj","a6","a7","a8","a9","a10","dynCall_ji","dynCall_jiiii","dynCall_vij","dynCall_iiji","dynCall_iji","dynCall_jii","dynCall_iij","index","a11","a12","a13","a14","a15","run","doRun","addOnPostRun","runCaller","$a023ed70d02b2fd9$var$isPthread"],"version":3,"file":"ConwayGeomWasmWebMT.fe679e06.js.map"}